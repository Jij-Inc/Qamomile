{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qamomile","text":""},{"location":"#what-is-qamomile","title":"What is Qamomile","text":"<p>Qamomile is Quantum Algorithm for Mathematical OptiMization with jIjmodeLing Extension.</p> <p>You can easily create Ising Hamiltonians and encoded Hamiltonians from mathematical models using Qamomile.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install \"jijmodeling-transpiler-quantum[qiskit]\"\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>In the following example, QAOA for the graph colouring problem is implemented using Qamomile.</p> <pre><code>import jijmodeling as jm\nimport jijmodeling_transpiler.core as jtc\nimport jijmodeling_transpiler_quantum.qiskit as jt_qk\n\nfrom qiskit.primitives import Estimator, Sampler\nfrom qiskit.algorithms.minimum_eigensolvers import QAOA\nfrom qiskit.algorithms.optimizers import COBYLA\n\nimport networkx as nx\n\n# Create Mathematical Model\n# define variables\nV = jm.Placeholder(\"V\")\nE = jm.Placeholder(\"E\", ndim=2)\nN = jm.Placeholder(\"N\")\nx = jm.BinaryVar(\"x\", shape=(V, N))\nn = jm.Element(\"i\", belong_to=(0, N))\nv = jm.Element(\"v\", belong_to=(0, V))\ne = jm.Element(\"e\", belong_to=E)\n# set problem\nproblem = jm.Problem(\"Graph Coloring\")\n# set one-hot constraint that each vertex has only one color\n\nproblem += jm.Constraint(\"one-color\", x[v, :].sum() == 1, forall=v)\n# set objective function: minimize edges whose vertices connected by edges are the same color\nproblem += jm.sum([n, e], x[e[0], n] * x[e[1], n])\n\n# Create Problem Instance\nG = nx.Graph()\nG.add_nodes_from([0, 1, 2, 3, 4])\nG.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])\ninst_E = [list(edge) for edge in G.edges]\ncolor_num = 3\nnum_nodes = G.number_of_nodes()\ninstance_data = {\"V\": num_nodes, \"N\": color_num, \"E\": inst_E}\nnum_qubits = num_nodes * color_num\n\n# Transpile mathematical model to Qiskit Ising Hamiltonian\ncompiled_instance = jtc.compile_model(problem, instance_data)\nqaoa_builder = jt_qk.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False,relax_method=jtc.pubo.RelaxationMethod.SquaredPenalty)\nhamiltonian, _ = qaoa_builder.get_hamiltonian(multipliers={\"one-color\": 1})\n\n# Run QAOA by Qiskit\nsampler = Sampler()\noptimizer = COBYLA()\nqaoa = QAOA(sampler, optimizer, reps=1)\nresult = qaoa.compute_minimum_eigenvalue(hamiltonian)\n\n# Analyze Result\nsampleset = qaoa_builder.decode_from_quasi_dist(result.eigenstate)\nsampleset.feasible()\n</code></pre>"},{"location":"#dicord","title":"Dicord","text":"<p>Join our discord channel!</p>"},{"location":"overrides/gen_ref_pages/","title":"Gen ref pages","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"\nGenerate the code reference pages from the docstrings in the source code.\nThis script is reffred to the URL: https://mkdocstrings.github.io/recipes/ .\n\"\"\"\n</pre> \"\"\" Generate the code reference pages from the docstrings in the source code. This script is reffred to the URL: https://mkdocstrings.github.io/recipes/ . \"\"\" In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>SOURCE_DIR = \"jijmodeling_transpiler_quantum\"\n</pre> SOURCE_DIR = \"jijmodeling_transpiler_quantum\" In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\n</pre> nav = mkdocs_gen_files.Nav() In\u00a0[\u00a0]: Copied! <pre>for path in sorted(Path(SOURCE_DIR).rglob(\"*.py\")):\n    module_python_file_path = path.relative_to(SOURCE_DIR)\n    module_path = module_python_file_path.with_suffix(\"\")\n    doc_path = module_python_file_path.with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = list(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n    elif parts[-1][0] == \"_\":\n        # \"_\" prefix file is secret for user.\n        continue\n\n    if len(parts) == 0:\n        continue\n\n    nav[parts] = doc_path.as_posix()\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        identifier = SOURCE_DIR + \".\" + \".\".join(parts)\n        fd.write(f\"::: {identifier}\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, path)  #\n</pre> for path in sorted(Path(SOURCE_DIR).rglob(\"*.py\")):     module_python_file_path = path.relative_to(SOURCE_DIR)     module_path = module_python_file_path.with_suffix(\"\")     doc_path = module_python_file_path.with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = list(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue     elif parts[-1][0] == \"_\":         # \"_\" prefix file is secret for user.         continue      if len(parts) == 0:         continue      nav[parts] = doc_path.as_posix()      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         identifier = SOURCE_DIR + \".\" + \".\".join(parts)         fd.write(f\"::: {identifier}\")      mkdocs_gen_files.set_edit_path(full_doc_path, path)  # In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"},{"location":"reference/SUMMARY/","title":"Reference","text":"<ul> <li>core<ul> <li>ising_qubo<ul> <li>ising_qubo</li> </ul> </li> <li>qrac<ul> <li>graph_coloring</li> </ul> </li> </ul> </li> <li>qiskit<ul> <li>minimal_encoding<ul> <li>cost_function</li> <li>to_minimal_encoding</li> </ul> </li> <li>qaoa<ul> <li>ising_hamiltonian</li> <li>to_qaoa</li> </ul> </li> <li>qrao<ul> <li>qrao21</li> <li>qrao31</li> <li>qrao32</li> <li>qrao_space_efficient</li> <li>to_qrac</li> </ul> </li> </ul> </li> <li>quri_parts<ul> <li>qaoa<ul> <li>to_qaoa</li> </ul> </li> <li>qrao<ul> <li>qrao21</li> <li>qrao31</li> <li>qrao32</li> <li>to_qrac</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/core/","title":"Core","text":""},{"location":"reference/core/#jijmodeling_transpiler_quantum.core.IsingModel","title":"<code>IsingModel</code>  <code>dataclass</code>","text":"Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>@dataclasses.dataclass\nclass IsingModel:\n    quad: dict[tuple[int, int], float]\n    linear: dict[int, float]\n    constant: float\n\n    def calc_energy(self, state: list[int]) -&gt; float:\n        \"\"\"Calculates the energy of the state.\n\n        Examples:\n            &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n            &gt;&gt;&gt; ising.calc_energy([1, -1])\n            3.0\n\n        \"\"\"\n        energy = self.constant\n        for (i, j), value in self.quad.items():\n            energy += value * state[i] * state[j]\n        for i, value in self.linear.items():\n            energy += value * state[i]\n        return energy\n</code></pre>"},{"location":"reference/core/#jijmodeling_transpiler_quantum.core.IsingModel.calc_energy","title":"<code>calc_energy(state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n&gt;&gt;&gt; ising.calc_energy([1, -1])\n3.0\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_energy(self, state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n        &gt;&gt;&gt; ising.calc_energy([1, -1])\n        3.0\n\n    \"\"\"\n    energy = self.constant\n    for (i, j), value in self.quad.items():\n        energy += value * state[i] * state[j]\n    for i, value in self.linear.items():\n        energy += value * state[i]\n    return energy\n</code></pre>"},{"location":"reference/core/#jijmodeling_transpiler_quantum.core.greedy_graph_coloring","title":"<code>greedy_graph_coloring(graph: typ.Iterable[tuple[int, int]], max_color_group_size: int, init_coloring: typ.Optional[dict[int, int]] = None) -&gt; tuple[dict[int, int], dict[int, list[int]]]</code>","text":"<p>graph coloring for QRAC</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Iterable[tuple[int, int]]</code> <p>description</p> required <code>max_color_group_size</code> <code>int</code> <p>if you want to use for the qrac31, set 3.</p> required <code>init_coloring</code> <code>Optional[dict[int, int]]</code> <p>initial coloring. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[int, int], dict[int, list[int]]]</code> <p>tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n&gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/qrac/graph_coloring.py</code> <pre><code>def greedy_graph_coloring(\n    graph: typ.Iterable[tuple[int, int]],\n    max_color_group_size: int,\n    init_coloring: typ.Optional[dict[int, int]] = None,\n) -&gt; tuple[dict[int, int], dict[int, list[int]]]:\n    \"\"\"graph coloring for QRAC\n\n    Args:\n        graph (typ.Iterable[tuple[int, int]]): _description_\n        max_color_group_size (int): if you want to use for the qrac31, set 3.\n        init_coloring (typ.Optional[dict[int, int]], optional): initial coloring. Defaults to None.\n\n    Returns:\n        tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group\n\n\n    Examples:\n        &gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n        &gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n        ({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n\n    \"\"\"\n    coloring = {}\n    if init_coloring:\n        coloring.update(init_coloring)\n\n    max_color = max(coloring.values()) if coloring else -1\n\n    adj_matrix: dict[int, list[int]] = {}\n    for i, j in graph:\n        if i == j:\n            continue\n        if i not in adj_matrix:\n            adj_matrix[i] = []\n        if j not in adj_matrix:\n            adj_matrix[j] = []\n        adj_matrix[i].append(j)\n        adj_matrix[j].append(i)\n\n    color_group: dict[int, list[int]] = {}\n    for index, color in coloring.items():\n        if color not in coloring:\n            color_group[color] = []\n        color_group[color].append(index)\n\n    for i, neigborhoors in adj_matrix.items():\n        if i in coloring:\n            continue\n\n        neighbor_colors = [coloring[k] for k in neigborhoors if k in coloring]\n\n        done_coloring = False\n        for color in range(max_color + 1):\n            if color not in color_group or color not in neighbor_colors:\n                if color not in color_group or max_color_group_size &gt; len(\n                    color_group[color]\n                ):\n                    coloring[i] = color\n                    done_coloring = True\n                    if color not in color_group:\n                        color_group[color] = []\n                    color_group[color].append(i)\n                    break\n        if not done_coloring:\n            coloring[i] = max_color + 1\n            color_group[max_color + 1] = [i]\n            max_color += 1\n\n    return coloring, color_group\n</code></pre>"},{"location":"reference/core/#jijmodeling_transpiler_quantum.core.qubo_to_ising","title":"<code>qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel</code>","text":"<p>Converts a QUBO to an Ising model.</p> <p>QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; binary = [1, 0]\n&gt;&gt;&gt; spin = [-1, 1]\n&gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n&gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n</code></pre> <pre><code>&gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; assert ising.constant == -0.5\n&gt;&gt;&gt; assert ising.linear == {}\n&gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>def qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel:\n    \"\"\"Converts a QUBO to an Ising model.\n\n    QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i\n    Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}\n\n    Examples:\n        &gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; binary = [1, 0]\n        &gt;&gt;&gt; spin = [-1, 1]\n        &gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n        &gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n\n        &gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; assert ising.constant == -0.5\n        &gt;&gt;&gt; assert ising.linear == {}\n        &gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n\n    \"\"\"\n    ising_J: dict[tuple[int, int], float] = {}\n    ising_h: dict[int, float] = {}\n    constant = 0.0\n    for (i, j), value in qubo.items():\n        if i != j:\n            ising_J[(i, j)] = value / 4.0 + ising_J.get((i, j), 0.0)\n            constant += value / 4.0\n        else:\n            constant += value / 2.0\n        ising_h[i] = -value / 4.0 + ising_h.get(i, 0.0)\n        ising_h[j] = -value / 4.0 + ising_h.get(j, 0.0)\n\n    if simplify:\n        ising_J = {ij: value for ij, value in ising_J.items() if value != 0.0}\n        ising_h = {i: value for i, value in ising_h.items() if value != 0.0}\n    return IsingModel(ising_J, ising_h, constant)\n</code></pre>"},{"location":"reference/core/ising_qubo/","title":"Ising qubo","text":""},{"location":"reference/core/ising_qubo/#jijmodeling_transpiler_quantum.core.ising_qubo.IsingModel","title":"<code>IsingModel</code>  <code>dataclass</code>","text":"Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>@dataclasses.dataclass\nclass IsingModel:\n    quad: dict[tuple[int, int], float]\n    linear: dict[int, float]\n    constant: float\n\n    def calc_energy(self, state: list[int]) -&gt; float:\n        \"\"\"Calculates the energy of the state.\n\n        Examples:\n            &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n            &gt;&gt;&gt; ising.calc_energy([1, -1])\n            3.0\n\n        \"\"\"\n        energy = self.constant\n        for (i, j), value in self.quad.items():\n            energy += value * state[i] * state[j]\n        for i, value in self.linear.items():\n            energy += value * state[i]\n        return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/#jijmodeling_transpiler_quantum.core.ising_qubo.IsingModel.calc_energy","title":"<code>calc_energy(state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n&gt;&gt;&gt; ising.calc_energy([1, -1])\n3.0\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_energy(self, state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n        &gt;&gt;&gt; ising.calc_energy([1, -1])\n        3.0\n\n    \"\"\"\n    energy = self.constant\n    for (i, j), value in self.quad.items():\n        energy += value * state[i] * state[j]\n    for i, value in self.linear.items():\n        energy += value * state[i]\n    return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/#jijmodeling_transpiler_quantum.core.ising_qubo.calc_qubo_energy","title":"<code>calc_qubo_energy(qubo: dict[tuple[int, int], float], state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calc_qubo_energy({(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}, [1, 1])\n6.0\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_qubo_energy(qubo: dict[tuple[int, int], float], state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; calc_qubo_energy({(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}, [1, 1])\n        6.0\n    \"\"\"\n    energy = 0.0\n    for (i, j), value in qubo.items():\n        energy += value * state[i] * state[j]\n    return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/#jijmodeling_transpiler_quantum.core.ising_qubo.qubo_to_ising","title":"<code>qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel</code>","text":"<p>Converts a QUBO to an Ising model.</p> <p>QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; binary = [1, 0]\n&gt;&gt;&gt; spin = [-1, 1]\n&gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n&gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n</code></pre> <pre><code>&gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; assert ising.constant == -0.5\n&gt;&gt;&gt; assert ising.linear == {}\n&gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>def qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel:\n    \"\"\"Converts a QUBO to an Ising model.\n\n    QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i\n    Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}\n\n    Examples:\n        &gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; binary = [1, 0]\n        &gt;&gt;&gt; spin = [-1, 1]\n        &gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n        &gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n\n        &gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; assert ising.constant == -0.5\n        &gt;&gt;&gt; assert ising.linear == {}\n        &gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n\n    \"\"\"\n    ising_J: dict[tuple[int, int], float] = {}\n    ising_h: dict[int, float] = {}\n    constant = 0.0\n    for (i, j), value in qubo.items():\n        if i != j:\n            ising_J[(i, j)] = value / 4.0 + ising_J.get((i, j), 0.0)\n            constant += value / 4.0\n        else:\n            constant += value / 2.0\n        ising_h[i] = -value / 4.0 + ising_h.get(i, 0.0)\n        ising_h[j] = -value / 4.0 + ising_h.get(j, 0.0)\n\n    if simplify:\n        ising_J = {ij: value for ij, value in ising_J.items() if value != 0.0}\n        ising_h = {i: value for i, value in ising_h.items() if value != 0.0}\n    return IsingModel(ising_J, ising_h, constant)\n</code></pre>"},{"location":"reference/core/ising_qubo/ising_qubo/","title":"Ising qubo","text":""},{"location":"reference/core/ising_qubo/ising_qubo/#jijmodeling_transpiler_quantum.core.ising_qubo.ising_qubo.IsingModel","title":"<code>IsingModel</code>  <code>dataclass</code>","text":"Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>@dataclasses.dataclass\nclass IsingModel:\n    quad: dict[tuple[int, int], float]\n    linear: dict[int, float]\n    constant: float\n\n    def calc_energy(self, state: list[int]) -&gt; float:\n        \"\"\"Calculates the energy of the state.\n\n        Examples:\n            &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n            &gt;&gt;&gt; ising.calc_energy([1, -1])\n            3.0\n\n        \"\"\"\n        energy = self.constant\n        for (i, j), value in self.quad.items():\n            energy += value * state[i] * state[j]\n        for i, value in self.linear.items():\n            energy += value * state[i]\n        return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/ising_qubo/#jijmodeling_transpiler_quantum.core.ising_qubo.ising_qubo.IsingModel.calc_energy","title":"<code>calc_energy(state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n&gt;&gt;&gt; ising.calc_energy([1, -1])\n3.0\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_energy(self, state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n        &gt;&gt;&gt; ising.calc_energy([1, -1])\n        3.0\n\n    \"\"\"\n    energy = self.constant\n    for (i, j), value in self.quad.items():\n        energy += value * state[i] * state[j]\n    for i, value in self.linear.items():\n        energy += value * state[i]\n    return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/ising_qubo/#jijmodeling_transpiler_quantum.core.ising_qubo.ising_qubo.calc_qubo_energy","title":"<code>calc_qubo_energy(qubo: dict[tuple[int, int], float], state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calc_qubo_energy({(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}, [1, 1])\n6.0\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_qubo_energy(qubo: dict[tuple[int, int], float], state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; calc_qubo_energy({(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}, [1, 1])\n        6.0\n    \"\"\"\n    energy = 0.0\n    for (i, j), value in qubo.items():\n        energy += value * state[i] * state[j]\n    return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/ising_qubo/#jijmodeling_transpiler_quantum.core.ising_qubo.ising_qubo.qubo_to_ising","title":"<code>qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel</code>","text":"<p>Converts a QUBO to an Ising model.</p> <p>QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; binary = [1, 0]\n&gt;&gt;&gt; spin = [-1, 1]\n&gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n&gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n</code></pre> <pre><code>&gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; assert ising.constant == -0.5\n&gt;&gt;&gt; assert ising.linear == {}\n&gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/ising_qubo/ising_qubo.py</code> <pre><code>def qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel:\n    \"\"\"Converts a QUBO to an Ising model.\n\n    QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i\n    Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}\n\n    Examples:\n        &gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; binary = [1, 0]\n        &gt;&gt;&gt; spin = [-1, 1]\n        &gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n        &gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n\n        &gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; assert ising.constant == -0.5\n        &gt;&gt;&gt; assert ising.linear == {}\n        &gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n\n    \"\"\"\n    ising_J: dict[tuple[int, int], float] = {}\n    ising_h: dict[int, float] = {}\n    constant = 0.0\n    for (i, j), value in qubo.items():\n        if i != j:\n            ising_J[(i, j)] = value / 4.0 + ising_J.get((i, j), 0.0)\n            constant += value / 4.0\n        else:\n            constant += value / 2.0\n        ising_h[i] = -value / 4.0 + ising_h.get(i, 0.0)\n        ising_h[j] = -value / 4.0 + ising_h.get(j, 0.0)\n\n    if simplify:\n        ising_J = {ij: value for ij, value in ising_J.items() if value != 0.0}\n        ising_h = {i: value for i, value in ising_h.items() if value != 0.0}\n    return IsingModel(ising_J, ising_h, constant)\n</code></pre>"},{"location":"reference/core/qrac/","title":"Qrac","text":"<p>This module provides utilities for the Quantum Random Access Coding (QRAC). Ex: QRAC utilizes are used Quantum Random Access Optimization (QRAO).</p>"},{"location":"reference/core/qrac/#jijmodeling_transpiler_quantum.core.qrac.check_linear_term","title":"<code>check_linear_term(color_group: dict[int, list[int]], linear_term_index: list[int], max_color_group_size: int) -&gt; dict[int, list[int]]</code>","text":"<p>Search for items within the index of linear term that have not been assigned to the color_group, and add them.</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>color_group</p> required <code>linear_term_index</code> <code>list[int]</code> <p>list of index of linear term</p> required <code>max_color_group_size</code> <code>int</code> <p>the maximum number of encoding qubits. if you want to use for the qrac31, set 3.</p> required <p>Returns:</p> Type Description <code>dict[int, list[int]]</code> <p>dict[int, list[int]]: color_group which added items within the index of linear term that have not been assigned to the color_group.</p> Source code in <code>jijmodeling_transpiler_quantum/core/qrac/graph_coloring.py</code> <pre><code>def check_linear_term(\n    color_group: dict[int, list[int]],\n    linear_term_index: list[int],\n    max_color_group_size: int,\n) -&gt; dict[int, list[int]]:\n    \"\"\"Search for items within the index of linear term that have not been assigned to the color_group, and add them.\n\n    Args:\n        color_group (dict[int, list[int]]): color_group\n        linear_term_index (list[int]): list of index of linear term\n        max_color_group_size (int): the maximum number of encoding qubits. if you want to use for the qrac31, set 3.\n\n    Returns:\n        dict[int, list[int]]: color_group which added items within the index of linear term that have not been assigned to the color_group.\n    \"\"\"\n    idx_in_color_group = []\n    for v in color_group.values():\n        idx_in_color_group.extend(v)\n\n    # We're adding a bit to the next index of the 'quad' qubit, affecting only the linear term. \n    # If the Ising Hamiltonian has only linear terms, making 'quad' empty and causing a 'max' error, we return index 0 to avoid this.\n    qubit_index_for_linear = max(color_group.keys()) + 1 if color_group else 0\n    bits_in_qubits_counter = 1\n    for idx in linear_term_index:\n        if idx not in idx_in_color_group:\n            if bits_in_qubits_counter == 1:\n                color_group[qubit_index_for_linear] = []\n\n            color_group[qubit_index_for_linear].append(idx)\n            bits_in_qubits_counter += 1\n\n            if bits_in_qubits_counter &gt; max_color_group_size:\n                qubit_index_for_linear += 1\n                bits_in_qubits_counter = 1\n\n    return color_group\n</code></pre>"},{"location":"reference/core/qrac/#jijmodeling_transpiler_quantum.core.qrac.greedy_graph_coloring","title":"<code>greedy_graph_coloring(graph: typ.Iterable[tuple[int, int]], max_color_group_size: int, init_coloring: typ.Optional[dict[int, int]] = None) -&gt; tuple[dict[int, int], dict[int, list[int]]]</code>","text":"<p>graph coloring for QRAC</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Iterable[tuple[int, int]]</code> <p>description</p> required <code>max_color_group_size</code> <code>int</code> <p>if you want to use for the qrac31, set 3.</p> required <code>init_coloring</code> <code>Optional[dict[int, int]]</code> <p>initial coloring. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[int, int], dict[int, list[int]]]</code> <p>tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n&gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/qrac/graph_coloring.py</code> <pre><code>def greedy_graph_coloring(\n    graph: typ.Iterable[tuple[int, int]],\n    max_color_group_size: int,\n    init_coloring: typ.Optional[dict[int, int]] = None,\n) -&gt; tuple[dict[int, int], dict[int, list[int]]]:\n    \"\"\"graph coloring for QRAC\n\n    Args:\n        graph (typ.Iterable[tuple[int, int]]): _description_\n        max_color_group_size (int): if you want to use for the qrac31, set 3.\n        init_coloring (typ.Optional[dict[int, int]], optional): initial coloring. Defaults to None.\n\n    Returns:\n        tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group\n\n\n    Examples:\n        &gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n        &gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n        ({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n\n    \"\"\"\n    coloring = {}\n    if init_coloring:\n        coloring.update(init_coloring)\n\n    max_color = max(coloring.values()) if coloring else -1\n\n    adj_matrix: dict[int, list[int]] = {}\n    for i, j in graph:\n        if i == j:\n            continue\n        if i not in adj_matrix:\n            adj_matrix[i] = []\n        if j not in adj_matrix:\n            adj_matrix[j] = []\n        adj_matrix[i].append(j)\n        adj_matrix[j].append(i)\n\n    color_group: dict[int, list[int]] = {}\n    for index, color in coloring.items():\n        if color not in coloring:\n            color_group[color] = []\n        color_group[color].append(index)\n\n    for i, neigborhoors in adj_matrix.items():\n        if i in coloring:\n            continue\n\n        neighbor_colors = [coloring[k] for k in neigborhoors if k in coloring]\n\n        done_coloring = False\n        for color in range(max_color + 1):\n            if color not in color_group or color not in neighbor_colors:\n                if color not in color_group or max_color_group_size &gt; len(\n                    color_group[color]\n                ):\n                    coloring[i] = color\n                    done_coloring = True\n                    if color not in color_group:\n                        color_group[color] = []\n                    color_group[color].append(i)\n                    break\n        if not done_coloring:\n            coloring[i] = max_color + 1\n            color_group[max_color + 1] = [i]\n            max_color += 1\n\n    return coloring, color_group\n</code></pre>"},{"location":"reference/core/qrac/graph_coloring/","title":"Graph coloring","text":""},{"location":"reference/core/qrac/graph_coloring/#jijmodeling_transpiler_quantum.core.qrac.graph_coloring.check_linear_term","title":"<code>check_linear_term(color_group: dict[int, list[int]], linear_term_index: list[int], max_color_group_size: int) -&gt; dict[int, list[int]]</code>","text":"<p>Search for items within the index of linear term that have not been assigned to the color_group, and add them.</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>color_group</p> required <code>linear_term_index</code> <code>list[int]</code> <p>list of index of linear term</p> required <code>max_color_group_size</code> <code>int</code> <p>the maximum number of encoding qubits. if you want to use for the qrac31, set 3.</p> required <p>Returns:</p> Type Description <code>dict[int, list[int]]</code> <p>dict[int, list[int]]: color_group which added items within the index of linear term that have not been assigned to the color_group.</p> Source code in <code>jijmodeling_transpiler_quantum/core/qrac/graph_coloring.py</code> <pre><code>def check_linear_term(\n    color_group: dict[int, list[int]],\n    linear_term_index: list[int],\n    max_color_group_size: int,\n) -&gt; dict[int, list[int]]:\n    \"\"\"Search for items within the index of linear term that have not been assigned to the color_group, and add them.\n\n    Args:\n        color_group (dict[int, list[int]]): color_group\n        linear_term_index (list[int]): list of index of linear term\n        max_color_group_size (int): the maximum number of encoding qubits. if you want to use for the qrac31, set 3.\n\n    Returns:\n        dict[int, list[int]]: color_group which added items within the index of linear term that have not been assigned to the color_group.\n    \"\"\"\n    idx_in_color_group = []\n    for v in color_group.values():\n        idx_in_color_group.extend(v)\n\n    # We're adding a bit to the next index of the 'quad' qubit, affecting only the linear term. \n    # If the Ising Hamiltonian has only linear terms, making 'quad' empty and causing a 'max' error, we return index 0 to avoid this.\n    qubit_index_for_linear = max(color_group.keys()) + 1 if color_group else 0\n    bits_in_qubits_counter = 1\n    for idx in linear_term_index:\n        if idx not in idx_in_color_group:\n            if bits_in_qubits_counter == 1:\n                color_group[qubit_index_for_linear] = []\n\n            color_group[qubit_index_for_linear].append(idx)\n            bits_in_qubits_counter += 1\n\n            if bits_in_qubits_counter &gt; max_color_group_size:\n                qubit_index_for_linear += 1\n                bits_in_qubits_counter = 1\n\n    return color_group\n</code></pre>"},{"location":"reference/core/qrac/graph_coloring/#jijmodeling_transpiler_quantum.core.qrac.graph_coloring.greedy_graph_coloring","title":"<code>greedy_graph_coloring(graph: typ.Iterable[tuple[int, int]], max_color_group_size: int, init_coloring: typ.Optional[dict[int, int]] = None) -&gt; tuple[dict[int, int], dict[int, list[int]]]</code>","text":"<p>graph coloring for QRAC</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Iterable[tuple[int, int]]</code> <p>description</p> required <code>max_color_group_size</code> <code>int</code> <p>if you want to use for the qrac31, set 3.</p> required <code>init_coloring</code> <code>Optional[dict[int, int]]</code> <p>initial coloring. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[int, int], dict[int, list[int]]]</code> <p>tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n&gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/core/qrac/graph_coloring.py</code> <pre><code>def greedy_graph_coloring(\n    graph: typ.Iterable[tuple[int, int]],\n    max_color_group_size: int,\n    init_coloring: typ.Optional[dict[int, int]] = None,\n) -&gt; tuple[dict[int, int], dict[int, list[int]]]:\n    \"\"\"graph coloring for QRAC\n\n    Args:\n        graph (typ.Iterable[tuple[int, int]]): _description_\n        max_color_group_size (int): if you want to use for the qrac31, set 3.\n        init_coloring (typ.Optional[dict[int, int]], optional): initial coloring. Defaults to None.\n\n    Returns:\n        tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group\n\n\n    Examples:\n        &gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n        &gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n        ({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n\n    \"\"\"\n    coloring = {}\n    if init_coloring:\n        coloring.update(init_coloring)\n\n    max_color = max(coloring.values()) if coloring else -1\n\n    adj_matrix: dict[int, list[int]] = {}\n    for i, j in graph:\n        if i == j:\n            continue\n        if i not in adj_matrix:\n            adj_matrix[i] = []\n        if j not in adj_matrix:\n            adj_matrix[j] = []\n        adj_matrix[i].append(j)\n        adj_matrix[j].append(i)\n\n    color_group: dict[int, list[int]] = {}\n    for index, color in coloring.items():\n        if color not in coloring:\n            color_group[color] = []\n        color_group[color].append(index)\n\n    for i, neigborhoors in adj_matrix.items():\n        if i in coloring:\n            continue\n\n        neighbor_colors = [coloring[k] for k in neigborhoors if k in coloring]\n\n        done_coloring = False\n        for color in range(max_color + 1):\n            if color not in color_group or color not in neighbor_colors:\n                if color not in color_group or max_color_group_size &gt; len(\n                    color_group[color]\n                ):\n                    coloring[i] = color\n                    done_coloring = True\n                    if color not in color_group:\n                        color_group[color] = []\n                    color_group[color].append(i)\n                    break\n        if not done_coloring:\n            coloring[i] = max_color + 1\n            color_group[max_color + 1] = [i]\n            max_color += 1\n\n    return coloring, color_group\n</code></pre>"},{"location":"reference/qiskit/","title":"Qiskit","text":""},{"location":"reference/qiskit/#jijmodeling_transpiler_quantum.qiskit.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method: jmt.core.pubo.RelaxationMethod = jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method: jmt.core.pubo.RelaxationMethod = jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/#jijmodeling_transpiler_quantum.qiskit.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/#jijmodeling_transpiler_quantum.qiskit.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/#jijmodeling_transpiler_quantum.qiskit.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/#jijmodeling_transpiler_quantum.qiskit.transpile_to_qrac_space_efficient_hamiltonian","title":"<code>transpile_to_qrac_space_efficient_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize=True) -&gt; QRACSpaceEfficientBuilder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.</p> <pre><code>This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\nIn this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRACSpaceEfficientBuilder</code> <code>QRACSpaceEfficientBuilder</code> <p>Space-efficient QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac_space_efficient_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize=True\n) -&gt; QRACSpaceEfficientBuilder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.\n\n        This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n        In this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRACSpaceEfficientBuilder: Space-efficient QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRACSpaceEfficientBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/","title":"Minimal encoding","text":""},{"location":"reference/qiskit/minimal_encoding/#jijmodeling_transpiler_quantum.qiskit.minimal_encoding.transpile_to_minimal_encoding","title":"<code>transpile_to_minimal_encoding(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; MinimalEncodingBuilder</code>","text":"<p>Function to transpile a compiled instance to a minimal encoding builder</p> <pre><code>Generating Minimal Encoding Builder from a compiled instance.\nMinimal encoding is a method to reduce the number of qubits and classical bits.\nThe method is first proposed by Tan, Benjamin, et al. \"Qubit-efficient encoding schemes for binary optimisation problems.\" Quantum 5 (2021): 454.\nMore information is on https://quantum-journal.org/papers/q-2021-05-04-454/\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>compiled instance</p> required <code>normalize</code> <code>bool</code> <p>whether to normalize the coefficients or not. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>MinimalEncodingBuilder</code> <code>MinimalEncodingBuilder</code> <p>minimal encoding builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def transpile_to_minimal_encoding(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; MinimalEncodingBuilder:\n    \"\"\"Function to transpile a compiled instance to a minimal encoding builder\n\n        Generating Minimal Encoding Builder from a compiled instance.\n        Minimal encoding is a method to reduce the number of qubits and classical bits.\n        The method is first proposed by Tan, Benjamin, et al. \"Qubit-efficient encoding schemes for binary optimisation problems.\" Quantum 5 (2021): 454.\n        More information is on https://quantum-journal.org/papers/q-2021-05-04-454/\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): compiled instance\n        normalize (bool, optional): whether to normalize the coefficients or not. Defaults to True.\n\n    Returns:\n        MinimalEncodingBuilder: minimal encoding builder\n    \"\"\"\n\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return MinimalEncodingBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/cost_function/","title":"Cost function","text":""},{"location":"reference/qiskit/minimal_encoding/cost_function/#jijmodeling_transpiler_quantum.qiskit.minimal_encoding.cost_function.define_pauli_op","title":"<code>define_pauli_op(num_register_bits: int, ancilla: bool = False) -&gt; list[qk_info.SparsePauliOp]</code>","text":"<p>Function to define pauli operators</p> <p>Parameters:</p> Name Type Description Default <code>num_register_bits</code> <code>int</code> <p>number of register bits</p> required <code>ancilla</code> <code>bool</code> <p>whether to add ancilla qubit |1&gt; or not. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if num_register_bits &lt; 1</p> <p>Returns:</p> Type Description <code>list[SparsePauliOp]</code> <p>list[qk_info.SparsePauliOp]: list of pauli operators</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/minimal_encoding/cost_function.py</code> <pre><code>def define_pauli_op(\n    num_register_bits: int, ancilla: bool = False\n) -&gt; list[qk_info.SparsePauliOp]:\n    \"\"\"Function to define pauli operators\n\n    Args:\n        num_register_bits (int): number of register bits\n        ancilla (bool, optional): whether to add ancilla qubit |1&gt; or not. Defaults to False.\n\n    Raises:\n        ValueError: if num_register_bits &lt; 1\n\n    Returns:\n        list[qk_info.SparsePauliOp]: list of pauli operators\n    \"\"\"\n\n    if num_register_bits &lt; 1:\n        raise ValueError(\"num_register_bits must be greater than 0\")\n\n    z = [[False], [True]]\n    x = [[False], [False]]\n    zero_op = qk_info.SparsePauliOp(\n        qk_info.PauliList.from_symplectic(z, x), coeffs=[1 / 2, 1 / 2]\n    )\n\n    one_op = qk_info.SparsePauliOp(\n        qk_info.PauliList.from_symplectic(z, x), coeffs=[1 / 2, -1 / 2]\n    )\n\n    identity_op = qk_info.SparsePauliOp(qk_info.Pauli(([0], [0])))\n\n    ancilla_operator = one_op if ancilla else identity_op\n\n    pauli_ops = []\n\n    if num_register_bits == 1:\n        for _op in [one_op, zero_op]:\n            pauli_ops.append(_op.tensor(ancilla_operator))\n    else:\n        for val in itertools.product(\n            [one_op, zero_op], repeat=num_register_bits\n        ):\n            pauli_op = val[0]\n            for _op in val[1:]:\n                pauli_op = pauli_op.tensor(_op)\n\n            pauli_ops.append(pauli_op.tensor(ancilla_operator))\n\n    return pauli_ops\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/cost_function/#jijmodeling_transpiler_quantum.qiskit.minimal_encoding.cost_function.initialize_cost_function","title":"<code>initialize_cost_function(qubo: dict[tuple[int, int], float], num_cbits: int) -&gt; Callable[[np.array], float]</code>","text":"<p>Function to initialize cost function for minimal encoding</p> <p>Parameters:</p> Name Type Description Default <code>qubo</code> <code>dict[tuple[int, int], float]</code> <p>QUBO Matrix</p> required <code>num_cbit</code> <code>int</code> <p>number of classical bits</p> required <p>Returns:</p> Type Description <code>Callable[[array], float]</code> <p>Callable[[np.array], float]: cost function for minimal encoding</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/minimal_encoding/cost_function.py</code> <pre><code>def initialize_cost_function(\n    qubo: dict[tuple[int, int], float], num_cbits: int\n) -&gt; Callable[[np.array], float]:\n    \"\"\"Function to initialize cost function for minimal encoding\n\n    Args:\n        qubo (dict[tuple[int, int], float]): QUBO Matrix\n        num_cbit (int): number of classical bits\n\n    Returns:\n        Callable[[np.array], float]: cost function for minimal encoding\n    \"\"\"\n\n    # define cost function\n    def cost_function(one_coeffs: np.array) -&gt; float:\n        \"\"\"Function to compute value of cost function for minimal encoding\n\n        Args:\n            one_coeffs (np.array): the ratio of the expectation value of each pauli operator for when ancilla qubit is |1&gt; and the expectation value of each pauli operator ignoring ancilla qubit\n\n        Returns:\n            float: value of cost function\n        \"\"\"\n\n        cost = 0\n        for i in range(num_cbits):\n            for j in range(i, num_cbits):\n                if i != j:\n                    cost += 2 * qubo[(i, j)] * one_coeffs[i] * one_coeffs[j]\n                else:\n                    cost += qubo[(i, j)] * one_coeffs[i]\n\n        return cost\n\n    return cost_function\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/","title":"To minimal encoding","text":""},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#jijmodeling_transpiler_quantum.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodedInstance","title":"<code>MinimalEncodedInstance</code>","text":"Source code in <code>jijmodeling_transpiler_quantum/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>class MinimalEncodedInstance:\n    def __init__(\n        self,\n        qubo: dict[tuple[int, int], float],\n        constant: float,\n        minimal_encoding_builder: MinimalEncodingBuilder,\n    ):\n        self.qubo = qubo\n        self.constant = constant\n        self.minimal_encoding_builder = minimal_encoding_builder\n        self._calculate_register_qubits(self.qubo)\n\n    def _calculate_register_qubits(self, qubo: dict[tuple[int, int], float]):\n        \"\"\"Function to calculate the number of register qubits\n\n        Args:\n            qubo (dict[tuple[int, int], float]): QUBO Matrix\n\n        Returns:\n            int: number of register qubits\n        \"\"\"\n        self.num_cbits = max(max(i, j) for i, j in qubo.keys()) + 1\n        self.num_register_bits = np.ceil(np.log2(self.num_cbits)).astype(int)\n\n    def _get_cost_function(self) -&gt; Callable[[np.array], float]:\n        return initialize_cost_function(self.qubo, self.num_cbits)\n\n    def get_minimized_function(\n        self,\n        ansatz: qk.circuit.quantumcircuit.QuantumCircuit,\n        num_shots: int = None,\n    ) -&gt; Callable[[dict], float]:\n        \"\"\"Method to generate cost function which should be minimized by classical optimizer\n\n            In minimal encoding, rather than directly minimizing the value of the Hamiltonian,\n            we minimize the cost function calculated using the expected values obtained from the quantum device.\n            Therefore, this function returns a function that carries out a process not just for the Hamiltonian,\n            but also for the calculation of expected values and the subsequent calculation of the cost function.\n\n        Args:\n            ansatz (qk.circuit.quantumcircuit.QuantumCircuit): variational ansatz (parameterized quantum circuit)\n            num_shots (int, optional): The number of shots. If None, it calculates the exact expectation values. Otherwise, it samples from normal distributions with standard errors as standard deviations using normal distribution approximation. Defaults to None.\n\n        Returns:\n            Callable[[dict], float]: function to be minimized by classical optimizer\n        \"\"\"\n        # get expectation values from a circuit\n        # get a list of H (observables), which is a list of SparsePauliOp\n        H = define_pauli_op(self.num_register_bits)\n        Ha = define_pauli_op(self.num_register_bits, ancilla=True)\n\n        cost_function = self._get_cost_function()\n\n        estimator = Estimator()\n        if num_shots is not None:\n            estimator.set_options(shots=num_shots)\n\n        def minimized_func(params: Sequence[float]) -&gt; float:\n            \"\"\"Function to be minimized by classical optimizer\n\n            Args:\n                params (Sequence[float]): parameters of the circuit\n\n            Returns:\n                float: value of the cost function\n            \"\"\"\n\n            job1 = estimator.run([ansatz] * len(H), H, [params] * len(H))\n            P = job1.result()\n\n            job2 = estimator.run([ansatz] * len(Ha), Ha, [params] * len(Ha))\n            P1 = job2.result()\n\n            one_coeffs = P1.values / P.values\n\n            cost = cost_function(one_coeffs)\n\n            return cost\n\n        return minimized_func\n\n    def get_optimized_state(\n        self,\n        circuit: qk.circuit.quantumcircuit.QuantumCircuit,\n        params: Sequence[float],\n    ) -&gt; jm.SampleSet:\n        \"\"\"Function to get final binary list from the circuit and optimised parameters.\n\n            In minimal encoding, we estimate the state not through simple quantum state sampling,\n            but as a specific amount of expected values.\n            Therefore, in this function, we calculate the expected values for state estimation based on the parameters obtained through optimization.\n\n        Args:\n            circuit (qk.circuit.quantumcircuit.QuantumCircuit): parameterised quantum circuit\n            params (Sequence[float]): optimised parameters\n\n        Returns:\n            jm.Sampleset: samplset of the results\n        \"\"\"\n        estimator = Estimator()\n        # define observable to calculate expectation value\n        H = define_pauli_op(self.num_register_bits, ancilla=False)\n        Ha = define_pauli_op(self.num_register_bits, ancilla=True)\n        # get expectation values from\n        job1 = estimator.run([circuit] * len(H), H, [params] * len(H))\n        P = job1.result()\n\n        job2 = estimator.run([circuit] * len(Ha), Ha, [params] * len(Ha))\n        P1 = job2.result()\n        prob_one = (P1.values / P.values) ** 2\n        final_binary = np.array(prob_one &gt;= 0.5, dtype=int)\n\n        sample_set = self._decode_from_binary_values(\n            [final_binary[: self.num_cbits]]\n        )\n\n        return sample_set\n\n    def _decode_from_binary_values(\n        self, binary_list: typ.Iterable[list[int]]\n    ) -&gt; jm.SampleSet:\n        binary_results = [\n            {i: value for i, value in enumerate(binary)}\n            for binary in binary_list\n        ]\n        binary_encoder = (\n            self.minimal_encoding_builder.pubo_builder.binary_encoder\n        )\n        decoded: jm.SampleSet = (\n            jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n                binary_results,\n                binary_encoder,\n                self.minimal_encoding_builder.compiled_instance,\n            )\n        )\n\n        num_occurrences = [1] * len(binary_results)\n        decoded = jm.SampleSet(\n            record=jm.Record(\n                num_occurrences=num_occurrences,\n                solution=decoded.record.solution,\n            ),\n            evaluation=decoded.evaluation,\n            measuring_time=decoded.measuring_time,\n            metadata=decoded.metadata,\n        )\n        return decoded\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#jijmodeling_transpiler_quantum.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodedInstance.get_minimized_function","title":"<code>get_minimized_function(ansatz: qk.circuit.quantumcircuit.QuantumCircuit, num_shots: int = None) -&gt; Callable[[dict], float]</code>","text":"<p>Method to generate cost function which should be minimized by classical optimizer</p> <pre><code>In minimal encoding, rather than directly minimizing the value of the Hamiltonian,\nwe minimize the cost function calculated using the expected values obtained from the quantum device.\nTherefore, this function returns a function that carries out a process not just for the Hamiltonian,\nbut also for the calculation of expected values and the subsequent calculation of the cost function.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ansatz</code> <code>QuantumCircuit</code> <p>variational ansatz (parameterized quantum circuit)</p> required <code>num_shots</code> <code>int</code> <p>The number of shots. If None, it calculates the exact expectation values. Otherwise, it samples from normal distributions with standard errors as standard deviations using normal distribution approximation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[dict], float]</code> <p>Callable[[dict], float]: function to be minimized by classical optimizer</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def get_minimized_function(\n    self,\n    ansatz: qk.circuit.quantumcircuit.QuantumCircuit,\n    num_shots: int = None,\n) -&gt; Callable[[dict], float]:\n    \"\"\"Method to generate cost function which should be minimized by classical optimizer\n\n        In minimal encoding, rather than directly minimizing the value of the Hamiltonian,\n        we minimize the cost function calculated using the expected values obtained from the quantum device.\n        Therefore, this function returns a function that carries out a process not just for the Hamiltonian,\n        but also for the calculation of expected values and the subsequent calculation of the cost function.\n\n    Args:\n        ansatz (qk.circuit.quantumcircuit.QuantumCircuit): variational ansatz (parameterized quantum circuit)\n        num_shots (int, optional): The number of shots. If None, it calculates the exact expectation values. Otherwise, it samples from normal distributions with standard errors as standard deviations using normal distribution approximation. Defaults to None.\n\n    Returns:\n        Callable[[dict], float]: function to be minimized by classical optimizer\n    \"\"\"\n    # get expectation values from a circuit\n    # get a list of H (observables), which is a list of SparsePauliOp\n    H = define_pauli_op(self.num_register_bits)\n    Ha = define_pauli_op(self.num_register_bits, ancilla=True)\n\n    cost_function = self._get_cost_function()\n\n    estimator = Estimator()\n    if num_shots is not None:\n        estimator.set_options(shots=num_shots)\n\n    def minimized_func(params: Sequence[float]) -&gt; float:\n        \"\"\"Function to be minimized by classical optimizer\n\n        Args:\n            params (Sequence[float]): parameters of the circuit\n\n        Returns:\n            float: value of the cost function\n        \"\"\"\n\n        job1 = estimator.run([ansatz] * len(H), H, [params] * len(H))\n        P = job1.result()\n\n        job2 = estimator.run([ansatz] * len(Ha), Ha, [params] * len(Ha))\n        P1 = job2.result()\n\n        one_coeffs = P1.values / P.values\n\n        cost = cost_function(one_coeffs)\n\n        return cost\n\n    return minimized_func\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#jijmodeling_transpiler_quantum.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodedInstance.get_optimized_state","title":"<code>get_optimized_state(circuit: qk.circuit.quantumcircuit.QuantumCircuit, params: Sequence[float]) -&gt; jm.SampleSet</code>","text":"<p>Function to get final binary list from the circuit and optimised parameters.</p> <pre><code>In minimal encoding, we estimate the state not through simple quantum state sampling,\nbut as a specific amount of expected values.\nTherefore, in this function, we calculate the expected values for state estimation based on the parameters obtained through optimization.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>parameterised quantum circuit</p> required <code>params</code> <code>Sequence[float]</code> <p>optimised parameters</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.Sampleset: samplset of the results</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def get_optimized_state(\n    self,\n    circuit: qk.circuit.quantumcircuit.QuantumCircuit,\n    params: Sequence[float],\n) -&gt; jm.SampleSet:\n    \"\"\"Function to get final binary list from the circuit and optimised parameters.\n\n        In minimal encoding, we estimate the state not through simple quantum state sampling,\n        but as a specific amount of expected values.\n        Therefore, in this function, we calculate the expected values for state estimation based on the parameters obtained through optimization.\n\n    Args:\n        circuit (qk.circuit.quantumcircuit.QuantumCircuit): parameterised quantum circuit\n        params (Sequence[float]): optimised parameters\n\n    Returns:\n        jm.Sampleset: samplset of the results\n    \"\"\"\n    estimator = Estimator()\n    # define observable to calculate expectation value\n    H = define_pauli_op(self.num_register_bits, ancilla=False)\n    Ha = define_pauli_op(self.num_register_bits, ancilla=True)\n    # get expectation values from\n    job1 = estimator.run([circuit] * len(H), H, [params] * len(H))\n    P = job1.result()\n\n    job2 = estimator.run([circuit] * len(Ha), Ha, [params] * len(Ha))\n    P1 = job2.result()\n    prob_one = (P1.values / P.values) ** 2\n    final_binary = np.array(prob_one &gt;= 0.5, dtype=int)\n\n    sample_set = self._decode_from_binary_values(\n        [final_binary[: self.num_cbits]]\n    )\n\n    return sample_set\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#jijmodeling_transpiler_quantum.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodingBuilder","title":"<code>MinimalEncodingBuilder</code>","text":"Source code in <code>jijmodeling_transpiler_quantum/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>class MinimalEncodingBuilder:\n    def __init__(\n        self,\n        pubo_builder: jmt.core.pubo.PuboBuilder,\n        compiled_instance: jmt.core.CompiledInstance,\n    ):\n        self.pubo_builder = pubo_builder\n        self.compiled_instance = compiled_instance\n\n    def get_encoded_instance(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[Callable[[np.array], float], float]:\n        \"\"\"method to get encoded instance\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[Callable[[np.array], float], float]: _description_\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        return MinimalEncodedInstance(qubo, constant, self)\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#jijmodeling_transpiler_quantum.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodingBuilder.get_encoded_instance","title":"<code>get_encoded_instance(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[Callable[[np.array], float], float]</code>","text":"<p>method to get encoded instance</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Callable[[array], float], float]</code> <p>tuple[Callable[[np.array], float], float]: description</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def get_encoded_instance(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[Callable[[np.array], float], float]:\n    \"\"\"method to get encoded instance\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[Callable[[np.array], float], float]: _description_\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    return MinimalEncodedInstance(qubo, constant, self)\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#jijmodeling_transpiler_quantum.qiskit.minimal_encoding.to_minimal_encoding.transpile_to_minimal_encoding","title":"<code>transpile_to_minimal_encoding(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; MinimalEncodingBuilder</code>","text":"<p>Function to transpile a compiled instance to a minimal encoding builder</p> <pre><code>Generating Minimal Encoding Builder from a compiled instance.\nMinimal encoding is a method to reduce the number of qubits and classical bits.\nThe method is first proposed by Tan, Benjamin, et al. \"Qubit-efficient encoding schemes for binary optimisation problems.\" Quantum 5 (2021): 454.\nMore information is on https://quantum-journal.org/papers/q-2021-05-04-454/\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>compiled instance</p> required <code>normalize</code> <code>bool</code> <p>whether to normalize the coefficients or not. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>MinimalEncodingBuilder</code> <code>MinimalEncodingBuilder</code> <p>minimal encoding builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def transpile_to_minimal_encoding(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; MinimalEncodingBuilder:\n    \"\"\"Function to transpile a compiled instance to a minimal encoding builder\n\n        Generating Minimal Encoding Builder from a compiled instance.\n        Minimal encoding is a method to reduce the number of qubits and classical bits.\n        The method is first proposed by Tan, Benjamin, et al. \"Qubit-efficient encoding schemes for binary optimisation problems.\" Quantum 5 (2021): 454.\n        More information is on https://quantum-journal.org/papers/q-2021-05-04-454/\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): compiled instance\n        normalize (bool, optional): whether to normalize the coefficients or not. Defaults to True.\n\n    Returns:\n        MinimalEncodingBuilder: minimal encoding builder\n    \"\"\"\n\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return MinimalEncodingBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qaoa/","title":"Qaoa","text":""},{"location":"reference/qiskit/qaoa/ising_hamiltonian/","title":"Ising hamiltonian","text":""},{"location":"reference/qiskit/qaoa/ising_hamiltonian/#jijmodeling_transpiler_quantum.qiskit.qaoa.ising_hamiltonian.to_ising_operator_from_qubo","title":"<code>to_ising_operator_from_qubo(qubo: dict[tuple[int, int], float], n_qubit: int) -&gt; tuple[qk_ope.SparsePauliOp, float]</code>","text":"<p>Returns a quantum circuit that represents the QUBO.</p> <p>Parameters:</p> Name Type Description Default <code>qubo</code> <code>dict[tuple[int, int], float]</code> <p>QUBO dictionary</p> required <code>n_qubit</code> <code>int</code> <p>number of qubits</p> required <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float]</code> <p>tuple[qk_ope.SparsePauliOp, float]: The Ising operator and the constant offset.</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qaoa/ising_hamiltonian.py</code> <pre><code>def to_ising_operator_from_qubo(\n    qubo: dict[tuple[int, int], float], n_qubit: int\n) -&gt; tuple[qk_ope.SparsePauliOp, float]:\n    \"\"\"Returns a quantum circuit that represents the QUBO.\n\n    Args:\n        qubo (dict[tuple[int, int], float]): QUBO dictionary\n        n_qubit (int):number of qubits\n\n    Returns:\n        tuple[qk_ope.SparsePauliOp, float]: The Ising operator and the constant offset.\n    \"\"\"\n    ising = qubo_to_ising(qubo)\n    pauli_terms: list[qk_ope.SparsePauliOp] = []\n\n    offset = ising.constant\n    zero = np.zeros(n_qubit, dtype=bool)\n\n    # convert linear parts of the objective function into Hamiltonian.\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        z_p = zero.copy()\n        z_p[idx] = True\n\n        pauli_terms.append(qk_ope.SparsePauliOp(qk_ope.Pauli((z_p, zero)), coeff))\n\n    # create Pauli terms\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n        else:\n            z_p = zero.copy()\n            z_p[i] = True\n            z_p[j] = True\n            pauli_terms.append(qk_ope.SparsePauliOp(qk_ope.Pauli((z_p, zero)), coeff))\n\n    if pauli_terms:\n        # Remove paulis whose coefficients are zeros.\n        qubit_op = sum(pauli_terms).simplify(atol=0)\n    else:\n        # If there is no variable, we set num_nodes=1 so that qubit_op should be an operator.\n        # If num_nodes=0, I^0 = 1 (int).\n        n_qubit = max(1, n_qubit)\n        qubit_op = qk_ope.SparsePauliOp(\"I\" * n_qubit, 0)\n\n    return qubit_op, offset\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/","title":"To qaoa","text":""},{"location":"reference/qiskit/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder","title":"<code>QAOAAnsatzBuilder</code>","text":"Source code in <code>jijmodeling_transpiler_quantum/qiskit/qaoa/to_qaoa.py</code> <pre><code>class QAOAAnsatzBuilder:\n    def __init__(\n        self,\n        pubo_builder: jmt.core.pubo.PuboBuilder,\n        num_vars: int,\n        compiled_instance: jmt.core.CompiledInstance,\n    ):\n        \"\"\"Initialize the QAOAAnsatzBuilder.\n\n        Args:\n            pubo_builder (jmt.core.pubo.PuboBuilder): The PUBO builder to be used.\n            num_vars (int): The number of variables.\n            compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        \"\"\"\n        self.pubo_builder = pubo_builder\n        self.num_vars = num_vars\n        self.compiled_instance = compiled_instance\n\n    @property\n    def var_map(self) -&gt; dict[str, tuple[int, ...]]:\n        return self.compiled_instance.var_map.var_map\n\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float]:\n        \"\"\"Get the Ising Hamiltonian\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float]: The Ising operator and the constant offset.\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising_operator, ising_const = to_ising_operator_from_qubo(\n            qubo, self.num_vars\n        )\n        return ising_operator, ising_const + constant\n\n    def get_qaoa_ansatz(\n        self,\n        p: int,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]:\n        \"\"\"Get the QAOA Ansatz.\n\n        Args:\n            p (int): The number of layers in the QAOA circuit.\n            multipliers (typ.Optional[dict[str, float]], optional):Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]: The QAOA ansatz, the Ising operator, and the constant offset.\n        \"\"\"\n        ising_operator, constant = self.get_hamiltonian(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        qaoa_ansatz = qk.circuit.library.QAOAAnsatz(ising_operator, reps=p)\n        return qaoa_ansatz, ising_operator, constant\n\n    def decode_from_counts(self, counts: dict[str, int]) -&gt; jm.SampleSet:\n        \"\"\"Decode the counts to the SampleSet.\n\n        Args:\n            counts (dict[str, int]): The counts to be decoded.\n\n        Returns:\n            jm.SampleSet: The decoded sample set.\n        \"\"\"\n        samples = []\n        num_occurrences = []\n        for binary_str, count_num in counts.items():\n            binary_values = {idx: int(b) for idx, b in enumerate(binary_str)}\n            samples.append(binary_values)\n            num_occurrences.append(count_num)\n\n        binary_encoder = self.pubo_builder.binary_encoder\n        decoded: jm.SampleSet = (\n            jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n                samples, binary_encoder, self.compiled_instance\n            )\n        )\n        decoded = jm.SampleSet(\n            record=jm.Record(\n                num_occurrences=num_occurrences,\n                solution=decoded.record.solution,\n            ),\n            evaluation=decoded.evaluation,\n            measuring_time=decoded.measuring_time,\n            metadata=decoded.metadata,\n        )\n        return decoded\n\n    def decode_from_quasi_dist(\n        self, quasi_dist: qk.result.QuasiDistribution\n    ) -&gt; jm.SampleSet:\n        \"\"\"Decode the result from the probabilities.\n\n        Args:\n            quasi_dist (qk.result.QuasiDistribution): The probabilities to be decoded.\n\n        Returns:\n            jm.SampleSet: The decoded sample set.\n        \"\"\"\n        binary_prob: dict[str, float] = quasi_dist.binary_probabilities()\n\n        shots: int\n        if quasi_dist.shots:\n            shots = quasi_dist.shots\n        else:\n            if self.num_vars &lt; 15:\n                shots = max(2**self.num_vars, 100)\n            else:\n                shots = 30000\n\n        binary_counts = {\n            key: int(prob * shots) for key, prob in binary_prob.items()\n        }\n\n        return self.decode_from_counts(binary_counts)\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.__init__","title":"<code>__init__(pubo_builder: jmt.core.pubo.PuboBuilder, num_vars: int, compiled_instance: jmt.core.CompiledInstance)</code>","text":"<p>Initialize the QAOAAnsatzBuilder.</p> <p>Parameters:</p> Name Type Description Default <code>pubo_builder</code> <code>PuboBuilder</code> <p>The PUBO builder to be used.</p> required <code>num_vars</code> <code>int</code> <p>The number of variables.</p> required <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required Source code in <code>jijmodeling_transpiler_quantum/qiskit/qaoa/to_qaoa.py</code> <pre><code>def __init__(\n    self,\n    pubo_builder: jmt.core.pubo.PuboBuilder,\n    num_vars: int,\n    compiled_instance: jmt.core.CompiledInstance,\n):\n    \"\"\"Initialize the QAOAAnsatzBuilder.\n\n    Args:\n        pubo_builder (jmt.core.pubo.PuboBuilder): The PUBO builder to be used.\n        num_vars (int): The number of variables.\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n    \"\"\"\n    self.pubo_builder = pubo_builder\n    self.num_vars = num_vars\n    self.compiled_instance = compiled_instance\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.decode_from_counts","title":"<code>decode_from_counts(counts: dict[str, int]) -&gt; jm.SampleSet</code>","text":"<p>Decode the counts to the SampleSet.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>dict[str, int]</code> <p>The counts to be decoded.</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.SampleSet: The decoded sample set.</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qaoa/to_qaoa.py</code> <pre><code>def decode_from_counts(self, counts: dict[str, int]) -&gt; jm.SampleSet:\n    \"\"\"Decode the counts to the SampleSet.\n\n    Args:\n        counts (dict[str, int]): The counts to be decoded.\n\n    Returns:\n        jm.SampleSet: The decoded sample set.\n    \"\"\"\n    samples = []\n    num_occurrences = []\n    for binary_str, count_num in counts.items():\n        binary_values = {idx: int(b) for idx, b in enumerate(binary_str)}\n        samples.append(binary_values)\n        num_occurrences.append(count_num)\n\n    binary_encoder = self.pubo_builder.binary_encoder\n    decoded: jm.SampleSet = (\n        jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n            samples, binary_encoder, self.compiled_instance\n        )\n    )\n    decoded = jm.SampleSet(\n        record=jm.Record(\n            num_occurrences=num_occurrences,\n            solution=decoded.record.solution,\n        ),\n        evaluation=decoded.evaluation,\n        measuring_time=decoded.measuring_time,\n        metadata=decoded.metadata,\n    )\n    return decoded\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.decode_from_quasi_dist","title":"<code>decode_from_quasi_dist(quasi_dist: qk.result.QuasiDistribution) -&gt; jm.SampleSet</code>","text":"<p>Decode the result from the probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>quasi_dist</code> <code>QuasiDistribution</code> <p>The probabilities to be decoded.</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.SampleSet: The decoded sample set.</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qaoa/to_qaoa.py</code> <pre><code>def decode_from_quasi_dist(\n    self, quasi_dist: qk.result.QuasiDistribution\n) -&gt; jm.SampleSet:\n    \"\"\"Decode the result from the probabilities.\n\n    Args:\n        quasi_dist (qk.result.QuasiDistribution): The probabilities to be decoded.\n\n    Returns:\n        jm.SampleSet: The decoded sample set.\n    \"\"\"\n    binary_prob: dict[str, float] = quasi_dist.binary_probabilities()\n\n    shots: int\n    if quasi_dist.shots:\n        shots = quasi_dist.shots\n    else:\n        if self.num_vars &lt; 15:\n            shots = max(2**self.num_vars, 100)\n        else:\n            shots = 30000\n\n    binary_counts = {\n        key: int(prob * shots) for key, prob in binary_prob.items()\n    }\n\n    return self.decode_from_counts(binary_counts)\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float]</code>","text":"<p>Get the Ising Hamiltonian</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float]</code> <p>tuple[qk_info.SparsePauliOp, float]: The Ising operator and the constant offset.</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qaoa/to_qaoa.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float]:\n    \"\"\"Get the Ising Hamiltonian\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float]: The Ising operator and the constant offset.\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising_operator, ising_const = to_ising_operator_from_qubo(\n        qubo, self.num_vars\n    )\n    return ising_operator, ising_const + constant\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.get_qaoa_ansatz","title":"<code>get_qaoa_ansatz(p: int, multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]</code>","text":"<p>Get the QAOA Ansatz.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>The number of layers in the QAOA circuit.</p> required <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[QAOAAnsatz, SparsePauliOp, float]</code> <p>tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]: The QAOA ansatz, the Ising operator, and the constant offset.</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qaoa/to_qaoa.py</code> <pre><code>def get_qaoa_ansatz(\n    self,\n    p: int,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]:\n    \"\"\"Get the QAOA Ansatz.\n\n    Args:\n        p (int): The number of layers in the QAOA circuit.\n        multipliers (typ.Optional[dict[str, float]], optional):Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]: The QAOA ansatz, the Ising operator, and the constant offset.\n    \"\"\"\n    ising_operator, constant = self.get_hamiltonian(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    qaoa_ansatz = qk.circuit.library.QAOAAnsatz(ising_operator, reps=p)\n    return qaoa_ansatz, ising_operator, constant\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.qiskit.qaoa.to_qaoa.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method: jmt.core.pubo.RelaxationMethod = jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method: jmt.core.pubo.RelaxationMethod = jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/","title":"Qrao","text":""},{"location":"reference/qiskit/qrao/#jijmodeling_transpiler_quantum.qiskit.qrao.color_group_to_qrac_encode","title":"<code>color_group_to_qrac_encode(color_group: dict[int, list[int]]) -&gt; dict[int, tuple[int, Pauli]]</code>","text":"<p>qrac encode</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>key is color (qubit's index). value is list of bit's index.</p> required <p>Returns:</p> Type Description <code>dict[int, tuple[int, Pauli]]</code> <p>dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n&gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n{0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/qrao31.py</code> <pre><code>def color_group_to_qrac_encode(\n    color_group: dict[int, list[int]]\n) -&gt; dict[int, tuple[int, Pauli]]:\n    \"\"\"qrac encode\n\n    Args:\n        color_group (dict[int, list[int]]): key is color (qubit's index). value is list of bit's index.\n\n    Returns:\n        dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.\n\n    Examples:\n        &gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n        &gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n        {0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n\n    \"\"\"\n    qrac31 = {}\n    pauli_ope = [Pauli.Z, Pauli.X, Pauli.Y]\n    for color, group in color_group.items():\n        for ope_idx, bit_index in enumerate(group):\n            qrac31[bit_index] = (color, pauli_ope[ope_idx])\n    return qrac31\n</code></pre>"},{"location":"reference/qiskit/qrao/#jijmodeling_transpiler_quantum.qiskit.qrao.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/#jijmodeling_transpiler_quantum.qiskit.qrao.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/#jijmodeling_transpiler_quantum.qiskit.qrao.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/#jijmodeling_transpiler_quantum.qiskit.qrao.transpile_to_qrac_space_efficient_hamiltonian","title":"<code>transpile_to_qrac_space_efficient_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize=True) -&gt; QRACSpaceEfficientBuilder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.</p> <pre><code>This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\nIn this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRACSpaceEfficientBuilder</code> <code>QRACSpaceEfficientBuilder</code> <p>Space-efficient QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac_space_efficient_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize=True\n) -&gt; QRACSpaceEfficientBuilder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.\n\n        This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n        In this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRACSpaceEfficientBuilder: Space-efficient QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRACSpaceEfficientBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/qrao21/","title":"Qrao21","text":""},{"location":"reference/qiskit/qrao/qrao31/","title":"Qrao31","text":""},{"location":"reference/qiskit/qrao/qrao31/#jijmodeling_transpiler_quantum.qiskit.qrao.qrao31.color_group_to_qrac_encode","title":"<code>color_group_to_qrac_encode(color_group: dict[int, list[int]]) -&gt; dict[int, tuple[int, Pauli]]</code>","text":"<p>qrac encode</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>key is color (qubit's index). value is list of bit's index.</p> required <p>Returns:</p> Type Description <code>dict[int, tuple[int, Pauli]]</code> <p>dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n&gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n{0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/qrao31.py</code> <pre><code>def color_group_to_qrac_encode(\n    color_group: dict[int, list[int]]\n) -&gt; dict[int, tuple[int, Pauli]]:\n    \"\"\"qrac encode\n\n    Args:\n        color_group (dict[int, list[int]]): key is color (qubit's index). value is list of bit's index.\n\n    Returns:\n        dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.\n\n    Examples:\n        &gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n        &gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n        {0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n\n    \"\"\"\n    qrac31 = {}\n    pauli_ope = [Pauli.Z, Pauli.X, Pauli.Y]\n    for color, group in color_group.items():\n        for ope_idx, bit_index in enumerate(group):\n            qrac31[bit_index] = (color, pauli_ope[ope_idx])\n    return qrac31\n</code></pre>"},{"location":"reference/qiskit/qrao/qrao32/","title":"Qrao32","text":""},{"location":"reference/qiskit/qrao/qrao_space_efficient/","title":"Qrao space efficient","text":""},{"location":"reference/qiskit/qrao/to_qrac/","title":"To qrac","text":""},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.QRAC21Builder","title":"<code>QRAC21Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>class QRAC21Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 2\n\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac21_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.QRAC21Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float, QRACEncodingCache]</code> <p>tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 2\n\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac21_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.QRAC31Builder","title":"<code>QRAC31Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>class QRAC31Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 3\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac31_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.QRAC31Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float, QRACEncodingCache]</code> <p>tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 3\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac31_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.QRAC32Builder","title":"<code>QRAC32Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>class QRAC32Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 3\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac32_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.QRAC32Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float, QRACEncodingCache]</code> <p>tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 3\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac32_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.QRACSpaceEfficientBuilder","title":"<code>QRACSpaceEfficientBuilder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>class QRACSpaceEfficientBuilder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on space-efficient QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: Space-efficient QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        qrac_hamiltonian, offset, encoding = qrac_space_efficient_encode_ising(\n            ising\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group={}, encoding=encoding),\n        )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.QRACSpaceEfficientBuilder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on space-efficient QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float, QRACEncodingCache]</code> <p>tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: Space-efficient QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on space-efficient QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: Space-efficient QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    qrac_hamiltonian, offset, encoding = qrac_space_efficient_encode_ising(\n        ising\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group={}, encoding=encoding),\n    )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#jijmodeling_transpiler_quantum.qiskit.qrao.to_qrac.transpile_to_qrac_space_efficient_hamiltonian","title":"<code>transpile_to_qrac_space_efficient_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize=True) -&gt; QRACSpaceEfficientBuilder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.</p> <pre><code>This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\nIn this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRACSpaceEfficientBuilder</code> <code>QRACSpaceEfficientBuilder</code> <p>Space-efficient QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac_space_efficient_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize=True\n) -&gt; QRACSpaceEfficientBuilder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.\n\n        This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n        In this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRACSpaceEfficientBuilder: Space-efficient QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRACSpaceEfficientBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/","title":"Quri parts","text":""},{"location":"reference/quri_parts/#jijmodeling_transpiler_quantum.quri_parts.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/","title":"Qaoa","text":""},{"location":"reference/quri_parts/qaoa/#jijmodeling_transpiler_quantum.quri_parts.qaoa.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/","title":"To qaoa","text":""},{"location":"reference/quri_parts/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder","title":"<code>QAOAAnsatzBuilder</code>","text":"Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>class QAOAAnsatzBuilder:\n    def __init__(\n        self,\n        pubo_builder: jmt.core.pubo.PuboBuilder,\n        num_vars: int,\n        compiled_instance: jmt.core.CompiledInstance,\n    ):\n        \"\"\"Initialize the QAOAAnsatzBuilder.\n\n        Args:\n            pubo_builder (jmt.core.pubo.PuboBuilder): The PUBO builder to be used.\n            num_vars (int): The number of variables.\n            compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        \"\"\"\n        self.pubo_builder = pubo_builder\n        self.num_vars = num_vars\n        self.compiled_instance = compiled_instance\n\n    @property\n    def var_map(self) -&gt; dict[str, tuple[int, ...]]:\n        return self.compiled_instance.var_map.var_map\n\n    def get_ising_dict(\n        self,\n        multipliers: dict = None,\n        detail_parameters: dict = None,\n    ) -&gt; IsingModel:\n        \"\"\"Get the Ising dictionary.\n\n        Args:\n            multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[dict[tuple[int, int], float], dict[int, float], float]: The Ising dictionary, the constant offset, and the constant offset.\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = qubo_to_ising(qubo)\n        ising.constant += constant\n        return ising\n\n    def get_hamiltonian(\n        self,\n        multipliers: dict = None,\n        detail_parameters: dict = None,\n    ) -&gt; tuple[Operator, float]:\n        \"\"\"Get the Ising Hamiltonian.\n\n        Args:\n            multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[Operator, float]: The Ising operator and the constant offset.\n        \"\"\"\n        ising = self.get_ising_dict(multipliers, detail_parameters)\n\n        return ising_to_hamiltonian(ising)\n\n    def get_qaoa_ansatz(\n        self,\n        p: int,\n        multipliers: dict = None,\n        detail_parameters: dict = None,\n    ) -&gt; tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]:\n        \"\"\"Get the QAOA ansatz.\n\n        Args:\n            p (int): The number of layers in the QAOA circuit.\n            multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]: The QAOA ansatz, the Ising operator, and the constant offset.\n        \"\"\"\n        ising = self.get_ising_dict(multipliers, detail_parameters)\n        QAOAAnsatz = LinearMappedUnboundParametricQuantumCircuit(self.num_vars)\n        # Create the QAOA ansatz\n        for i in range(self.num_vars):\n            QAOAAnsatz.add_H_gate(i)\n\n        for p_level in range(p):\n            gamma = QAOAAnsatz.add_parameter(f\"gamma{p_level}\")\n            beta = QAOAAnsatz.add_parameter(f\"beta{p_level}\")\n\n            for idx, coeff in ising.linear.items():\n                if coeff != 0.0:\n                    QAOAAnsatz.add_ParametricRZ_gate(\n                        idx,\n                        angle={gamma: 2 * coeff}\n                    )\n            for (i, j), coeff in ising.quad.items():\n                if coeff != 0.0:\n                    QAOAAnsatz.add_ParametricPauliRotation_gate(\n                        [i, j],\n                        pauli_ids=(3, 3),\n                        angle={gamma: 2 * coeff},\n                    )\n            for i in range(self.num_vars):\n                QAOAAnsatz.add_ParametricRX_gate(\n                    i, {beta: 2}\n                )\n\n        ising_operator, constant = ising_to_hamiltonian(ising)\n\n        return QAOAAnsatz, ising_operator, constant\n\n    def decode_from_counts(self, counts: dict[str, int]) -&gt; jm.SampleSet:\n        \"\"\"Decode the result from the counts.\n\n        Args:\n            counts (dict[str, int]): The counts to be decoded.\n\n        Returns:\n            jm.SampleSet: The decoded sample set.\n        \"\"\"\n        samples = []\n        num_occurrences = []\n        for binary_str, count_num in counts.items():\n            binary_values = {idx: int(b) for idx, b in enumerate(binary_str)}\n            samples.append(binary_values)\n            num_occurrences.append(count_num)\n\n        binary_encoder = self.pubo_builder.binary_encoder\n        decoded: jm.SampleSet = (\n            jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n                samples, binary_encoder, self.compiled_instance\n            )\n        )\n        decoded = jm.SampleSet(\n            record=jm.Record(\n                num_occurrences=num_occurrences,\n                solution=decoded.record.solution,\n            ),\n            evaluation=decoded.evaluation,\n            measuring_time=decoded.measuring_time,\n            metadata=decoded.metadata,\n        )\n        return decoded\n\n    def decode_from_probs(self, probs: np.array) -&gt; jm.SampleSet:\n        \"\"\"Decode the result from the probabilities.\n\n        Args:\n            probs (np.array): The probabilities to be decoded.\n\n        Returns:\n            jm.SampleSet: The decoded sample set.\n        \"\"\"\n        shots = 10000\n        z_basis = [\n            format(i, \"b\").zfill(self.num_vars) for i in range(len(probs))\n        ]\n        binary_counts = {\n            i: int(value * shots) for i, value in zip(z_basis, probs)\n        }\n\n        return self.decode_from_counts(binary_counts)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.__init__","title":"<code>__init__(pubo_builder: jmt.core.pubo.PuboBuilder, num_vars: int, compiled_instance: jmt.core.CompiledInstance)</code>","text":"<p>Initialize the QAOAAnsatzBuilder.</p> <p>Parameters:</p> Name Type Description Default <code>pubo_builder</code> <code>PuboBuilder</code> <p>The PUBO builder to be used.</p> required <code>num_vars</code> <code>int</code> <p>The number of variables.</p> required <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def __init__(\n    self,\n    pubo_builder: jmt.core.pubo.PuboBuilder,\n    num_vars: int,\n    compiled_instance: jmt.core.CompiledInstance,\n):\n    \"\"\"Initialize the QAOAAnsatzBuilder.\n\n    Args:\n        pubo_builder (jmt.core.pubo.PuboBuilder): The PUBO builder to be used.\n        num_vars (int): The number of variables.\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n    \"\"\"\n    self.pubo_builder = pubo_builder\n    self.num_vars = num_vars\n    self.compiled_instance = compiled_instance\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.decode_from_counts","title":"<code>decode_from_counts(counts: dict[str, int]) -&gt; jm.SampleSet</code>","text":"<p>Decode the result from the counts.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>dict[str, int]</code> <p>The counts to be decoded.</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.SampleSet: The decoded sample set.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def decode_from_counts(self, counts: dict[str, int]) -&gt; jm.SampleSet:\n    \"\"\"Decode the result from the counts.\n\n    Args:\n        counts (dict[str, int]): The counts to be decoded.\n\n    Returns:\n        jm.SampleSet: The decoded sample set.\n    \"\"\"\n    samples = []\n    num_occurrences = []\n    for binary_str, count_num in counts.items():\n        binary_values = {idx: int(b) for idx, b in enumerate(binary_str)}\n        samples.append(binary_values)\n        num_occurrences.append(count_num)\n\n    binary_encoder = self.pubo_builder.binary_encoder\n    decoded: jm.SampleSet = (\n        jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n            samples, binary_encoder, self.compiled_instance\n        )\n    )\n    decoded = jm.SampleSet(\n        record=jm.Record(\n            num_occurrences=num_occurrences,\n            solution=decoded.record.solution,\n        ),\n        evaluation=decoded.evaluation,\n        measuring_time=decoded.measuring_time,\n        metadata=decoded.metadata,\n    )\n    return decoded\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.decode_from_probs","title":"<code>decode_from_probs(probs: np.array) -&gt; jm.SampleSet</code>","text":"<p>Decode the result from the probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>probs</code> <code>array</code> <p>The probabilities to be decoded.</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.SampleSet: The decoded sample set.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def decode_from_probs(self, probs: np.array) -&gt; jm.SampleSet:\n    \"\"\"Decode the result from the probabilities.\n\n    Args:\n        probs (np.array): The probabilities to be decoded.\n\n    Returns:\n        jm.SampleSet: The decoded sample set.\n    \"\"\"\n    shots = 10000\n    z_basis = [\n        format(i, \"b\").zfill(self.num_vars) for i in range(len(probs))\n    ]\n    binary_counts = {\n        i: int(value * shots) for i, value in zip(z_basis, probs)\n    }\n\n    return self.decode_from_counts(binary_counts)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: dict = None, detail_parameters: dict = None) -&gt; tuple[Operator, float]</code>","text":"<p>Get the Ising Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>dict</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>dict</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Operator, float]</code> <p>tuple[Operator, float]: The Ising operator and the constant offset.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: dict = None,\n    detail_parameters: dict = None,\n) -&gt; tuple[Operator, float]:\n    \"\"\"Get the Ising Hamiltonian.\n\n    Args:\n        multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[Operator, float]: The Ising operator and the constant offset.\n    \"\"\"\n    ising = self.get_ising_dict(multipliers, detail_parameters)\n\n    return ising_to_hamiltonian(ising)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.get_ising_dict","title":"<code>get_ising_dict(multipliers: dict = None, detail_parameters: dict = None) -&gt; IsingModel</code>","text":"<p>Get the Ising dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>dict</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>dict</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>IsingModel</code> <p>tuple[dict[tuple[int, int], float], dict[int, float], float]: The Ising dictionary, the constant offset, and the constant offset.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def get_ising_dict(\n    self,\n    multipliers: dict = None,\n    detail_parameters: dict = None,\n) -&gt; IsingModel:\n    \"\"\"Get the Ising dictionary.\n\n    Args:\n        multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[dict[tuple[int, int], float], dict[int, float], float]: The Ising dictionary, the constant offset, and the constant offset.\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = qubo_to_ising(qubo)\n    ising.constant += constant\n    return ising\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.get_qaoa_ansatz","title":"<code>get_qaoa_ansatz(p: int, multipliers: dict = None, detail_parameters: dict = None) -&gt; tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]</code>","text":"<p>Get the QAOA ansatz.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>The number of layers in the QAOA circuit.</p> required <code>multipliers</code> <code>dict</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>dict</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]</code> <p>tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]: The QAOA ansatz, the Ising operator, and the constant offset.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def get_qaoa_ansatz(\n    self,\n    p: int,\n    multipliers: dict = None,\n    detail_parameters: dict = None,\n) -&gt; tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]:\n    \"\"\"Get the QAOA ansatz.\n\n    Args:\n        p (int): The number of layers in the QAOA circuit.\n        multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]: The QAOA ansatz, the Ising operator, and the constant offset.\n    \"\"\"\n    ising = self.get_ising_dict(multipliers, detail_parameters)\n    QAOAAnsatz = LinearMappedUnboundParametricQuantumCircuit(self.num_vars)\n    # Create the QAOA ansatz\n    for i in range(self.num_vars):\n        QAOAAnsatz.add_H_gate(i)\n\n    for p_level in range(p):\n        gamma = QAOAAnsatz.add_parameter(f\"gamma{p_level}\")\n        beta = QAOAAnsatz.add_parameter(f\"beta{p_level}\")\n\n        for idx, coeff in ising.linear.items():\n            if coeff != 0.0:\n                QAOAAnsatz.add_ParametricRZ_gate(\n                    idx,\n                    angle={gamma: 2 * coeff}\n                )\n        for (i, j), coeff in ising.quad.items():\n            if coeff != 0.0:\n                QAOAAnsatz.add_ParametricPauliRotation_gate(\n                    [i, j],\n                    pauli_ids=(3, 3),\n                    angle={gamma: 2 * coeff},\n                )\n        for i in range(self.num_vars):\n            QAOAAnsatz.add_ParametricRX_gate(\n                i, {beta: 2}\n            )\n\n    ising_operator, constant = ising_to_hamiltonian(ising)\n\n    return QAOAAnsatz, ising_operator, constant\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#jijmodeling_transpiler_quantum.quri_parts.qaoa.to_qaoa.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/","title":"Qrao","text":""},{"location":"reference/quri_parts/qrao/#jijmodeling_transpiler_quantum.quri_parts.qrao.color_group_to_qrac_encode","title":"<code>color_group_to_qrac_encode(color_group: dict[int, list[int]]) -&gt; dict[int, tuple[int, Pauli]]</code>","text":"<p>qrac encode</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>key is color (qubit's index). value is list of bit's index.</p> required <p>Returns:</p> Type Description <code>dict[int, tuple[int, Pauli]]</code> <p>dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n&gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n{0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/qrao31.py</code> <pre><code>def color_group_to_qrac_encode(\n    color_group: dict[int, list[int]]\n) -&gt; dict[int, tuple[int, Pauli]]:\n    \"\"\"qrac encode\n\n    Args:\n        color_group (dict[int, list[int]]): key is color (qubit's index). value is list of bit's index.\n\n    Returns:\n        dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.\n\n    Examples:\n        &gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n        &gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n        {0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n\n    \"\"\"\n    qrac31 = {}\n    pauli_ope = [Pauli.Z, Pauli.X, Pauli.Y]\n    for color, group in color_group.items():\n        for ope_idx, bit_index in enumerate(group):\n            qrac31[bit_index] = (color, pauli_ope[ope_idx])\n    return qrac31\n</code></pre>"},{"location":"reference/quri_parts/qrao/#jijmodeling_transpiler_quantum.quri_parts.qrao.qrac21_encode_ising","title":"<code>qrac21_encode_ising(ising: IsingModel, color_group: dict[int, list[int]]) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]</code>","text":"<p>Encode an Ising model and a color group into QRAC21.</p> <p>This function encodes an Ising model into the operators, and returns as the QURI Parts Operator, the offset(constant) of the Ising model, and the encoded operation as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>ising</code> <code>IsingModel</code> <p>The Ising model to be encoded.</p> required <code>color_group</code> <code>dict[int, list[int]]</code> <p>The color group mapping for encoding.</p> required <p>Returns:</p> Type Description <code>Operator</code> <p>tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,</p> <code>float</code> <p>the offset of the Ising model, and the encoded operation as a dictionary.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/qrao21.py</code> <pre><code>def qrac21_encode_ising(\n    ising: IsingModel, color_group: dict[int, list[int]]\n) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]:\n    \"\"\"Encode an Ising model and a color group into QRAC21.\n\n    This function encodes an Ising model into the operators, and returns as the QURI Parts Operator,\n    the offset(constant) of the Ising model, and the encoded operation as a dictionary.\n\n    Args:\n        ising (IsingModel): The Ising model to be encoded.\n        color_group (dict[int, list[int]]): The color group mapping for encoding.\n\n    Returns:\n        tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,\n        the offset of the Ising model, and the encoded operation as a dictionary.\n    \"\"\"\n    encoded_ope = color_group_to_qrac_encode(color_group)\n\n    pauli_terms: list[Operator] = []\n\n    offset = ising.constant\n    n_qubit = len(color_group)\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        color, pauli_kind = encoded_ope[idx]\n        pauli_str = create_pauli_term([pauli_kind], [color], n_qubit)\n        pauli_terms.append(\n            Operator({pauli_label(pauli_str): np.sqrt(2) * coeff})\n        )\n\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n            continue\n\n        color_i, pauli_kind_i = encoded_ope[i]\n\n        color_j, pauli_kind_j = encoded_ope[j]\n\n        pauli_str = create_pauli_term(\n            [pauli_kind_i, pauli_kind_j], [color_i, color_j], n_qubit\n        )\n\n        pauli_terms.append(Operator({pauli_label(pauli_str): 2 * coeff}))\n\n    if pauli_terms:\n        qubit_op = Operator()\n        for term in pauli_terms:\n            qubit_op += term\n    else:\n        n_qubit = max(1, n_qubit)\n        qubit_op = Operator({PAULI_IDENTITY * n_qubit: 0})\n\n    return qubit_op, offset, encoded_ope\n</code></pre>"},{"location":"reference/quri_parts/qrao/#jijmodeling_transpiler_quantum.quri_parts.qrao.qrac31_encode_ising","title":"<code>qrac31_encode_ising(ising: IsingModel, color_group: dict[int, list[int]]) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]</code>","text":"<p>Encode an Ising model and a color group into QRAC31.</p> <p>Parameters:</p> Name Type Description Default <code>ising</code> <code>IsingModel</code> <p>The Ising model to be encoded.</p> required <code>color_group</code> <code>dict[int, list[int]]</code> <p>The color group mapping for encoding.</p> required <p>Returns:</p> Type Description <code>Operator</code> <p>tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,</p> <code>float</code> <p>the offset of the Ising model, and the encoded operation as a dictionary.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/qrao31.py</code> <pre><code>def qrac31_encode_ising(\n    ising: IsingModel, color_group: dict[int, list[int]]\n) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]:\n    \"\"\"Encode an Ising model and a color group into QRAC31.\n\n    Args:\n        ising (IsingModel): The Ising model to be encoded.\n        color_group (dict[int, list[int]]): The color group mapping for encoding.\n\n    Returns:\n        tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,\n        the offset of the Ising model, and the encoded operation as a dictionary.\n    \"\"\"\n    encoded_ope = color_group_to_qrac_encode(color_group)\n\n    pauli_terms: list[Operator] = []\n\n    offset = ising.constant\n    n_qubit = len(color_group)\n\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        color, pauli_kind = encoded_ope[idx]\n        pauli_operator = create_pauli_term([pauli_kind], [color], n_qubit)\n\n        pauli_terms.append(\n            Operator({pauli_label(pauli_operator): np.sqrt(3) * coeff})\n        )\n\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n            continue\n\n        color_i, pauli_kind_i = encoded_ope[i]\n\n        color_j, pauli_kind_j = encoded_ope[j]\n\n        pauli_ope = create_pauli_term(\n            [pauli_kind_i, pauli_kind_j], [color_i, color_j], n_qubit\n        )\n        pauli_terms.append(Operator({pauli_label(pauli_ope): 3 * coeff}))\n\n    if pauli_terms:\n        qubit_op = Operator()\n        for term in pauli_terms:\n            qubit_op += term\n    else:\n        n_qubit = max(1, n_qubit)\n        qubit_op = Operator({PAULI_IDENTITY * n_qubit: 0})\n\n    return qubit_op, offset, encoded_ope\n</code></pre>"},{"location":"reference/quri_parts/qrao/#jijmodeling_transpiler_quantum.quri_parts.qrao.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/#jijmodeling_transpiler_quantum.quri_parts.qrao.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/#jijmodeling_transpiler_quantum.quri_parts.qrao.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao21/","title":"Qrao21","text":""},{"location":"reference/quri_parts/qrao/qrao21/#jijmodeling_transpiler_quantum.quri_parts.qrao.qrao21.qrac21_encode_ising","title":"<code>qrac21_encode_ising(ising: IsingModel, color_group: dict[int, list[int]]) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]</code>","text":"<p>Encode an Ising model and a color group into QRAC21.</p> <p>This function encodes an Ising model into the operators, and returns as the QURI Parts Operator, the offset(constant) of the Ising model, and the encoded operation as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>ising</code> <code>IsingModel</code> <p>The Ising model to be encoded.</p> required <code>color_group</code> <code>dict[int, list[int]]</code> <p>The color group mapping for encoding.</p> required <p>Returns:</p> Type Description <code>Operator</code> <p>tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,</p> <code>float</code> <p>the offset of the Ising model, and the encoded operation as a dictionary.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/qrao21.py</code> <pre><code>def qrac21_encode_ising(\n    ising: IsingModel, color_group: dict[int, list[int]]\n) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]:\n    \"\"\"Encode an Ising model and a color group into QRAC21.\n\n    This function encodes an Ising model into the operators, and returns as the QURI Parts Operator,\n    the offset(constant) of the Ising model, and the encoded operation as a dictionary.\n\n    Args:\n        ising (IsingModel): The Ising model to be encoded.\n        color_group (dict[int, list[int]]): The color group mapping for encoding.\n\n    Returns:\n        tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,\n        the offset of the Ising model, and the encoded operation as a dictionary.\n    \"\"\"\n    encoded_ope = color_group_to_qrac_encode(color_group)\n\n    pauli_terms: list[Operator] = []\n\n    offset = ising.constant\n    n_qubit = len(color_group)\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        color, pauli_kind = encoded_ope[idx]\n        pauli_str = create_pauli_term([pauli_kind], [color], n_qubit)\n        pauli_terms.append(\n            Operator({pauli_label(pauli_str): np.sqrt(2) * coeff})\n        )\n\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n            continue\n\n        color_i, pauli_kind_i = encoded_ope[i]\n\n        color_j, pauli_kind_j = encoded_ope[j]\n\n        pauli_str = create_pauli_term(\n            [pauli_kind_i, pauli_kind_j], [color_i, color_j], n_qubit\n        )\n\n        pauli_terms.append(Operator({pauli_label(pauli_str): 2 * coeff}))\n\n    if pauli_terms:\n        qubit_op = Operator()\n        for term in pauli_terms:\n            qubit_op += term\n    else:\n        n_qubit = max(1, n_qubit)\n        qubit_op = Operator({PAULI_IDENTITY * n_qubit: 0})\n\n    return qubit_op, offset, encoded_ope\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao31/","title":"Qrao31","text":""},{"location":"reference/quri_parts/qrao/qrao31/#jijmodeling_transpiler_quantum.quri_parts.qrao.qrao31.color_group_to_qrac_encode","title":"<code>color_group_to_qrac_encode(color_group: dict[int, list[int]]) -&gt; dict[int, tuple[int, Pauli]]</code>","text":"<p>qrac encode</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>key is color (qubit's index). value is list of bit's index.</p> required <p>Returns:</p> Type Description <code>dict[int, tuple[int, Pauli]]</code> <p>dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n&gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n{0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n</code></pre> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/qrao31.py</code> <pre><code>def color_group_to_qrac_encode(\n    color_group: dict[int, list[int]]\n) -&gt; dict[int, tuple[int, Pauli]]:\n    \"\"\"qrac encode\n\n    Args:\n        color_group (dict[int, list[int]]): key is color (qubit's index). value is list of bit's index.\n\n    Returns:\n        dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.\n\n    Examples:\n        &gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n        &gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n        {0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n\n    \"\"\"\n    qrac31 = {}\n    pauli_ope = [Pauli.Z, Pauli.X, Pauli.Y]\n    for color, group in color_group.items():\n        for ope_idx, bit_index in enumerate(group):\n            qrac31[bit_index] = (color, pauli_ope[ope_idx])\n    return qrac31\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao31/#jijmodeling_transpiler_quantum.quri_parts.qrao.qrao31.create_pauli_term","title":"<code>create_pauli_term(operators: list[Pauli], indices: list[int], n_qubit: int) -&gt; str</code>","text":"<p>Create a Pauli term string given a list of operators and indices.</p> <p>Parameters:</p> Name Type Description Default <code>operators</code> <code>list[Pauli]</code> <p>A list of Pauli operators.</p> required <code>indices</code> <code>list[int]</code> <p>A list of indices corresponding to each operator.</p> required <code>n_qubit</code> <code>int</code> <p>The total number of qubits.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The created Pauli term string.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/qrao31.py</code> <pre><code>def create_pauli_term(\n    operators: list[Pauli], indices: list[int], n_qubit: int\n) -&gt; str:\n    \"\"\"Create a Pauli term string given a list of operators and indices.\n\n    Args:\n        operators (list[Pauli]): A list of Pauli operators.\n        indices (list[int]): A list of indices corresponding to each operator.\n        n_qubit (int): The total number of qubits.\n\n    Returns:\n        str: The created Pauli term string.\n    \"\"\"\n    pauli_str = \"\"\n    for ope, idx in zip(operators, indices):\n        if ope == Pauli.X:\n            pauli_str += f\"X{idx} \"\n        elif ope == Pauli.Y:\n            pauli_str += f\"Y{idx} \"\n        elif ope == Pauli.Z:\n            pauli_str += f\"Z{idx} \"\n    return pauli_str.rstrip()\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao31/#jijmodeling_transpiler_quantum.quri_parts.qrao.qrao31.qrac31_encode_ising","title":"<code>qrac31_encode_ising(ising: IsingModel, color_group: dict[int, list[int]]) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]</code>","text":"<p>Encode an Ising model and a color group into QRAC31.</p> <p>Parameters:</p> Name Type Description Default <code>ising</code> <code>IsingModel</code> <p>The Ising model to be encoded.</p> required <code>color_group</code> <code>dict[int, list[int]]</code> <p>The color group mapping for encoding.</p> required <p>Returns:</p> Type Description <code>Operator</code> <p>tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,</p> <code>float</code> <p>the offset of the Ising model, and the encoded operation as a dictionary.</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/qrao31.py</code> <pre><code>def qrac31_encode_ising(\n    ising: IsingModel, color_group: dict[int, list[int]]\n) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]:\n    \"\"\"Encode an Ising model and a color group into QRAC31.\n\n    Args:\n        ising (IsingModel): The Ising model to be encoded.\n        color_group (dict[int, list[int]]): The color group mapping for encoding.\n\n    Returns:\n        tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,\n        the offset of the Ising model, and the encoded operation as a dictionary.\n    \"\"\"\n    encoded_ope = color_group_to_qrac_encode(color_group)\n\n    pauli_terms: list[Operator] = []\n\n    offset = ising.constant\n    n_qubit = len(color_group)\n\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        color, pauli_kind = encoded_ope[idx]\n        pauli_operator = create_pauli_term([pauli_kind], [color], n_qubit)\n\n        pauli_terms.append(\n            Operator({pauli_label(pauli_operator): np.sqrt(3) * coeff})\n        )\n\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n            continue\n\n        color_i, pauli_kind_i = encoded_ope[i]\n\n        color_j, pauli_kind_j = encoded_ope[j]\n\n        pauli_ope = create_pauli_term(\n            [pauli_kind_i, pauli_kind_j], [color_i, color_j], n_qubit\n        )\n        pauli_terms.append(Operator({pauli_label(pauli_ope): 3 * coeff}))\n\n    if pauli_terms:\n        qubit_op = Operator()\n        for term in pauli_terms:\n            qubit_op += term\n    else:\n        n_qubit = max(1, n_qubit)\n        qubit_op = Operator({PAULI_IDENTITY * n_qubit: 0})\n\n    return qubit_op, offset, encoded_ope\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao32/","title":"Qrao32","text":""},{"location":"reference/quri_parts/qrao/to_qrac/","title":"To qrac","text":""},{"location":"reference/quri_parts/qrao/to_qrac/#jijmodeling_transpiler_quantum.quri_parts.qrao.to_qrac.QRAC21Builder","title":"<code>QRAC21Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>class QRAC21Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[Operator, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[Operator, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 2\n\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac21_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#jijmodeling_transpiler_quantum.quri_parts.qrao.to_qrac.QRAC21Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[Operator, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Operator, float, QRACEncodingCache]</code> <p>tuple[Operator, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[Operator, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[Operator, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 2\n\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac21_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#jijmodeling_transpiler_quantum.quri_parts.qrao.to_qrac.QRAC31Builder","title":"<code>QRAC31Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>class QRAC31Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[Operator, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[Operator, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 3\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac31_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#jijmodeling_transpiler_quantum.quri_parts.qrao.to_qrac.QRAC31Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[Operator, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Operator, float, QRACEncodingCache]</code> <p>tuple[Operator, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[Operator, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[Operator, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 3\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac31_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#jijmodeling_transpiler_quantum.quri_parts.qrao.to_qrac.QRAC32Builder","title":"<code>QRAC32Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>class QRAC32Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[Operator, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[Operator, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 3\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac32_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#jijmodeling_transpiler_quantum.quri_parts.qrao.to_qrac.QRAC32Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[Operator, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Operator, float, QRACEncodingCache]</code> <p>tuple[Operator, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[Operator, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[Operator, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 3\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac32_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#jijmodeling_transpiler_quantum.quri_parts.qrao.to_qrac.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#jijmodeling_transpiler_quantum.quri_parts.qrao.to_qrac.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#jijmodeling_transpiler_quantum.quri_parts.qrao.to_qrac.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>jijmodeling_transpiler_quantum/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"tutorial/alternating_ansatz_graph_coloring_qiskit/","title":"Graph Coloring by Qiskit","text":"In\u00a0[1]: Copied! <pre>from __future__ import annotations\n\nimport jijmodeling as jm\nimport jijmodeling_transpiler.core as jtc\nimport jijmodeling_transpiler_quantum.qiskit as jt_qk\n\nfrom qiskit.primitives import Estimator, Sampler\nfrom qiskit.algorithms.minimum_eigensolvers import QAOA\nfrom qiskit.algorithms.optimizers import COBYLA\nfrom qiskit import QuantumCircuit\nimport networkx as nx\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from __future__ import annotations  import jijmodeling as jm import jijmodeling_transpiler.core as jtc import jijmodeling_transpiler_quantum.qiskit as jt_qk  from qiskit.primitives import Estimator, Sampler from qiskit.algorithms.minimum_eigensolvers import QAOA from qiskit.algorithms.optimizers import COBYLA from qiskit import QuantumCircuit import networkx as nx  import numpy as np import matplotlib.pyplot as plt <pre>/tmp/ipykernel_28299/3484925615.py:8: DeprecationWarning: ``qiskit.algorithms`` has been migrated to an independent package: https://github.com/qiskit-community/qiskit-algorithms. The ``qiskit.algorithms`` import path is deprecated as of qiskit-terra 0.25.0 and will be removed no earlier than 3 months after the release date. Please run ``pip install qiskit_algorithms`` and use ``import qiskit_algorithms`` instead.\n  from qiskit.algorithms.minimum_eigensolvers import QAOA\n</pre> <p>First, we will implement the mathematical model of the graph coloring problem using JijModeling.</p> In\u00a0[2]: Copied! <pre>def graph_coloring_problem() -&gt; jm.Problem:\n    # define variables\n    V = jm.Placeholder(\"V\")\n    E = jm.Placeholder(\"E\", ndim=2)\n    N = jm.Placeholder(\"N\")\n    x = jm.BinaryVar(\"x\", shape=(V, N))\n    n = jm.Element(\"i\", belong_to=(0, N))\n    v = jm.Element(\"v\", belong_to=(0, V))\n    e = jm.Element(\"e\", belong_to=E)\n    # set problem\n    problem = jm.Problem(\"Graph Coloring\")\n    # set one-hot constraint that each vertex has only one color\n\n    problem += jm.Constraint(\"one-color\", x[v, :].sum() == 1, forall=v)\n    # set objective function: minimize edges whose vertices connected by edges are the same color\n    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])\n    return problem\n</pre> def graph_coloring_problem() -&gt; jm.Problem:     # define variables     V = jm.Placeholder(\"V\")     E = jm.Placeholder(\"E\", ndim=2)     N = jm.Placeholder(\"N\")     x = jm.BinaryVar(\"x\", shape=(V, N))     n = jm.Element(\"i\", belong_to=(0, N))     v = jm.Element(\"v\", belong_to=(0, V))     e = jm.Element(\"e\", belong_to=E)     # set problem     problem = jm.Problem(\"Graph Coloring\")     # set one-hot constraint that each vertex has only one color      problem += jm.Constraint(\"one-color\", x[v, :].sum() == 1, forall=v)     # set objective function: minimize edges whose vertices connected by edges are the same color     problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])     return problem In\u00a0[3]: Copied! <pre>problem = graph_coloring_problem()\nproblem\n</pre> problem = graph_coloring_problem() problem Out[3]:  $$\\begin{array}{cccc}\\text{Problem:} &amp; \\text{Graph Coloring} &amp; &amp; \\\\&amp; &amp; \\min \\quad \\displaystyle \\sum_{i = 0}^{N - 1} \\sum_{e \\in E} x_{e_{0}, i} \\cdot x_{e_{1}, i} &amp; \\\\\\text{{s.t.}} &amp; &amp; &amp; \\\\ &amp; \\text{one-color} &amp; \\displaystyle \\sum_{\\ast_{1} = 0}^{N - 1} x_{v, \\ast_{1}} = 1 &amp; \\forall v \\in \\left\\{0,\\ldots,V - 1\\right\\} \\\\\\text{{where}} &amp; &amp; &amp; \\\\&amp; x &amp; 2\\text{-dim binary variable}\\\\\\end{array}$$  <p>Next, we will create an instance of the problem.</p> In\u00a0[4]: Copied! <pre>G = nx.Graph()\nG.add_nodes_from([0, 1, 2, 3, 4])\nG.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])\nnx.draw(G)\n</pre> G = nx.Graph() G.add_nodes_from([0, 1, 2, 3, 4]) G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)]) nx.draw(G) In\u00a0[5]: Copied! <pre>inst_E = [list(edge) for edge in G.edges]\ncolor_num = 3\nnum_nodes = G.number_of_nodes()\ninstance_data = {\"V\": num_nodes, \"N\": color_num, \"E\": inst_E}\nnum_qubits = num_nodes * color_num\n</pre> inst_E = [list(edge) for edge in G.edges] color_num = 3 num_nodes = G.number_of_nodes() instance_data = {\"V\": num_nodes, \"N\": color_num, \"E\": inst_E} num_qubits = num_nodes * color_num <p>First, using JijModeling-Transpiler, we create a CompiledInstance from JijModeling's mathematical model and instance data.</p> In\u00a0[6]: Copied! <pre>compiled_instance = jtc.compile_model(problem, instance_data)\n</pre> compiled_instance = jtc.compile_model(problem, instance_data) <p>Next, we create a QAOABuilder using JTQ's transpile_to_qaoa_ansatz. By setting the weight coefficients for the constraints on this Builder, we can create the Hamiltonian.</p> In\u00a0[7]: Copied! <pre>qaoa_builder = jt_qk.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False,relax_method=jtc.pubo.RelaxationMethod.SquaredPenalty)\nhamiltonian, _ = qaoa_builder.get_hamiltonian(multipliers={\"one-color\": 1})\n</pre> qaoa_builder = jt_qk.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False,relax_method=jtc.pubo.RelaxationMethod.SquaredPenalty) hamiltonian, _ = qaoa_builder.get_hamiltonian(multipliers={\"one-color\": 1}) <p>Now that we have the variational quantum circuit and Hamiltonian ready, let's actually execute QAOA using Qiskit. Here, we will use <code>QAOA</code> from Qiskit's <code>minimum_eigensolvers</code> to carry out the QAOA.</p> In\u00a0[8]: Copied! <pre>sampler = Sampler()\noptimizer = COBYLA()\nqaoa = QAOA(sampler, optimizer, reps=1)\n</pre> sampler = Sampler() optimizer = COBYLA() qaoa = QAOA(sampler, optimizer, reps=1) <p>By using the <code>compute_minimum_eigenvalue method</code>, we can even perform the sampling of the final state.</p> In\u00a0[9]: Copied! <pre>result = qaoa.compute_minimum_eigenvalue(hamiltonian)\n</pre> result = qaoa.compute_minimum_eigenvalue(hamiltonian) <p>The <code>result.eigenstate</code> contains the sampling results of the quantum circuit. To make the results more readable, we use the <code>decode_from_quasi_dist</code> method to convert the results into a <code>jm.SampleSet</code>. This process automatically transforms the solution into the form formulated in the mathematical model and also calculates violations of constraints and the objective function value.</p> In\u00a0[10]: Copied! <pre>sampleset = qaoa_builder.decode_from_quasi_dist(result.eigenstate)\n</pre> sampleset = qaoa_builder.decode_from_quasi_dist(result.eigenstate) <p>Finally, let's plot the results obtained from the sampling.</p> In\u00a0[11]: Copied! <pre>def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):\n    # extract feasible solution\n    feasibles = sampleset.feasible()\n    if feasibles.evaluation.objective.size == 0:\n        print(\"No feasible solution found ...\")\n    else:\n        objectives = np.array(feasibles.evaluation.objective)\n        lowest_index = np.argmin(objectives)\n\n        # get indices of x = 1\n        indices, _, _ = feasibles.record.solution[\"x\"][lowest_index]\n        # get vertices and colors\n        sorted_vertices, sorted_colors = zip(\n            *sorted(zip(*indices), key=lambda x: x[1])\n        )\n        # initialize vertex color list\n        node_colors = [-1] * len(sorted_vertices)\n        # set color list for visualization\n        colorlist = [\"gold\", \"violet\", \"limegreen\", \"darkorange\"]\n        # set vertex color list\n        for i, j in zip(sorted_vertices, sorted_colors):\n            node_colors[i] = colorlist[j]\n        # make figure\n        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)\n        plt.show()\n</pre> def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):     # extract feasible solution     feasibles = sampleset.feasible()     if feasibles.evaluation.objective.size == 0:         print(\"No feasible solution found ...\")     else:         objectives = np.array(feasibles.evaluation.objective)         lowest_index = np.argmin(objectives)          # get indices of x = 1         indices, _, _ = feasibles.record.solution[\"x\"][lowest_index]         # get vertices and colors         sorted_vertices, sorted_colors = zip(             *sorted(zip(*indices), key=lambda x: x[1])         )         # initialize vertex color list         node_colors = [-1] * len(sorted_vertices)         # set color list for visualization         colorlist = [\"gold\", \"violet\", \"limegreen\", \"darkorange\"]         # set vertex color list         for i, j in zip(sorted_vertices, sorted_colors):             node_colors[i] = colorlist[j]         # make figure         nx.draw_networkx(graph, node_color=node_colors, with_labels=True)         plt.show() In\u00a0[12]: Copied! <pre>plot_graph_coloring(G, sampleset)\n</pre> plot_graph_coloring(G, sampleset) <p>First, we prepare a mathematical model excluding the constraints.</p> In\u00a0[13]: Copied! <pre>def graph_coloring_problem_wo_onehot() -&gt; jm.Problem:\n    # define variables\n    V = jm.Placeholder(\"V\")\n    E = jm.Placeholder(\"E\", ndim=2)\n    N = jm.Placeholder(\"N\")\n    x = jm.BinaryVar(\"x\", shape=(V, N))\n    n = jm.Element(\"i\", belong_to=(0, N))\n    v = jm.Element(\"v\", belong_to=(0, V))\n    e = jm.Element(\"e\", belong_to=E)\n    # set problem\n    problem = jm.Problem(\"Graph Coloring without Onehot\")\n    # set one-hot constraint that each vertex has only one color\n    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])\n    return problem\n</pre> def graph_coloring_problem_wo_onehot() -&gt; jm.Problem:     # define variables     V = jm.Placeholder(\"V\")     E = jm.Placeholder(\"E\", ndim=2)     N = jm.Placeholder(\"N\")     x = jm.BinaryVar(\"x\", shape=(V, N))     n = jm.Element(\"i\", belong_to=(0, N))     v = jm.Element(\"v\", belong_to=(0, V))     e = jm.Element(\"e\", belong_to=E)     # set problem     problem = jm.Problem(\"Graph Coloring without Onehot\")     # set one-hot constraint that each vertex has only one color     problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])     return problem In\u00a0[14]: Copied! <pre>problem = graph_coloring_problem_wo_onehot()\nproblem\n</pre> problem = graph_coloring_problem_wo_onehot() problem Out[14]:  $$\\begin{array}{cccc}\\text{Problem:} &amp; \\text{Graph Coloring without Onehot} &amp; &amp; \\\\&amp; &amp; \\min \\quad \\displaystyle \\sum_{i = 0}^{N - 1} \\sum_{e \\in E} x_{e_{0}, i} \\cdot x_{e_{1}, i} &amp; \\\\\\text{{where}} &amp; &amp; &amp; \\\\&amp; x &amp; 2\\text{-dim binary variable}\\\\\\end{array}$$  <p>Similar to before, we compile and create a Hamiltonian.</p> In\u00a0[15]: Copied! <pre>compiled_instance = jtc.compile_model(problem, instance_data)\nqaoa_builder = jt_qk.qaoa.transpile_to_qaoa_ansatz(compiled_instance)\nising_operator, _ = qaoa_builder.get_hamiltonian()\n</pre> compiled_instance = jtc.compile_model(problem, instance_data) qaoa_builder = jt_qk.qaoa.transpile_to_qaoa_ansatz(compiled_instance) ising_operator, _ = qaoa_builder.get_hamiltonian() <p>Next, we will create an $XY$-mixer. The $XY$-mixer can be written as $$ XY_{ij} = \\frac{1}{2}\\left(X_iX_j + Y_iY_j \\right). $$ This is an operator that swaps the bits 1 and 0 in bit $i,j$. Therefore, it can transform a bit string $100$, which satisfies the one-hot constraint, into another bit string $010$, which also satisfies the one-hot constraint.</p> <p>Here, the only part under the one-hot constraint is related to color, so in terms of the mathematical model, we need to transform the bits between $x_{v0}$ and $x_{v1}$. On the other hand, as these variables are usually embedded in qubits, it is necessary to remember which bit corresponds to which variable when constructing the algorithm and handle them appropriately. In JTQ, the correspondence of variables is contained in var_map inside CompiledInstance.</p> <pre>var_map['variable_name'][indices]\n</pre> <p>You can check which qubit corresponds to a variable in the mathematical model in this way. Let's use this to create an $XY$-mixer.</p> <p>What we want here is the transformation between $x_{v,k}$ and $x_{v,k+1}$, so we can obtain the index of the corresponding qubit by accessing compiled_instance.var_map.var_map[\"x\"][(i,k)].\"</p> In\u00a0[16]: Copied! <pre>from qiskit.circuit import Parameter\n\ndef create_xy_mixer(beta:Parameter,num_nodes:int,num_color:int, compiled_instance: jtc.CompiledInstance):\n    n = num_color*num_nodes\n    qc = QuantumCircuit(n)\n    var_map = compiled_instance.var_map.var_map[\"x\"]\n    #even\n    for i in range(num_nodes):\n        for k in range(0,num_color-1,2):\n            qc.rxx(beta,var_map[(i,k)],var_map[(i,k+1)])\n            qc.ryy(beta,var_map[(i,k)],var_map[(i,k+1)])\n            \n    #odd\n    for i in range(num_nodes):\n        for k in range(1,num_color-1,2):\n            qc.rxx(beta,var_map[(i,k)],var_map[(i,k+1)])\n            qc.ryy(beta,var_map[(i,k)],var_map[(i,k+1)])\n            \n    # ini-last\n    if num_color % 2 == 1:\n        for i in range(num_nodes):\n            qc.rxx(beta,var_map[(i,0)],var_map[(i,num_color-1)])\n            qc.ryy(beta,var_map[(i,0)],var_map[(i,num_color-1)])\n    return qc\n</pre> from qiskit.circuit import Parameter  def create_xy_mixer(beta:Parameter,num_nodes:int,num_color:int, compiled_instance: jtc.CompiledInstance):     n = num_color*num_nodes     qc = QuantumCircuit(n)     var_map = compiled_instance.var_map.var_map[\"x\"]     #even     for i in range(num_nodes):         for k in range(0,num_color-1,2):             qc.rxx(beta,var_map[(i,k)],var_map[(i,k+1)])             qc.ryy(beta,var_map[(i,k)],var_map[(i,k+1)])                  #odd     for i in range(num_nodes):         for k in range(1,num_color-1,2):             qc.rxx(beta,var_map[(i,k)],var_map[(i,k+1)])             qc.ryy(beta,var_map[(i,k)],var_map[(i,k+1)])                  # ini-last     if num_color % 2 == 1:         for i in range(num_nodes):             qc.rxx(beta,var_map[(i,0)],var_map[(i,num_color-1)])             qc.ryy(beta,var_map[(i,0)],var_map[(i,num_color-1)])     return qc In\u00a0[17]: Copied! <pre>def create_initial_state(compiled_instance: jtc.CompiledInstance, num_nodes: int,num_color:int):\n    n = num_color*num_nodes\n    qc = QuantumCircuit(n)\n    var_map = compiled_instance.var_map.var_map[\"x\"]\n    for i in range(num_nodes):\n        qc.x(var_map[(i, 0)])\n    return qc\n</pre> def create_initial_state(compiled_instance: jtc.CompiledInstance, num_nodes: int,num_color:int):     n = num_color*num_nodes     qc = QuantumCircuit(n)     var_map = compiled_instance.var_map.var_map[\"x\"]     for i in range(num_nodes):         qc.x(var_map[(i, 0)])     return qc <p>Now that the Ansatz has been created, we would like to run the Quantum Alternating Operator Ansatz.</p> In\u00a0[18]: Copied! <pre>sampler = Sampler()\noptimizer = COBYLA()\ninitial_state = create_initial_state(compiled_instance, num_nodes,num_color=color_num)\nxy_mixer = create_xy_mixer(Parameter(\"beta\"), num_nodes, color_num, compiled_instance)\nqaoa = QAOA(sampler, optimizer, reps=1,initial_state=initial_state,mixer=xy_mixer)\n</pre> sampler = Sampler() optimizer = COBYLA() initial_state = create_initial_state(compiled_instance, num_nodes,num_color=color_num) xy_mixer = create_xy_mixer(Parameter(\"beta\"), num_nodes, color_num, compiled_instance) qaoa = QAOA(sampler, optimizer, reps=1,initial_state=initial_state,mixer=xy_mixer) In\u00a0[19]: Copied! <pre>result = qaoa.compute_minimum_eigenvalue(ising_operator)\n</pre> result = qaoa.compute_minimum_eigenvalue(ising_operator) In\u00a0[20]: Copied! <pre>sampleset = qaoa_builder.decode_from_quasi_dist(result.eigenstate)\n</pre> sampleset = qaoa_builder.decode_from_quasi_dist(result.eigenstate) <p>Let's plot the results obtained.</p> In\u00a0[21]: Copied! <pre>plot_graph_coloring(G, sampleset)\n</pre> plot_graph_coloring(G, sampleset)"},{"location":"tutorial/alternating_ansatz_graph_coloring_qiskit/#quantum-alternating-operator-ansatz-for-graph-coloring-problem-with-qiskit","title":"Quantum Alternating Operator Ansatz for Graph Coloring Problem with Qiskit\u00b6","text":"<p>In this tutorial, we would like to explain the functionality while solving the Graph Coloring Problem using the Quantum Approximate Optimization Algorithm and the Quantum Alternating Operator Ansatz. This time, we are going to conduct simulations using qiskit.</p>"},{"location":"tutorial/alternating_ansatz_graph_coloring_qiskit/#quantum-approximate-optimazation-algorithm-qaoa","title":"Quantum Approximate Optimazation Algorithm (QAOA)\u00b6","text":"<p>The Quantum Approximate Optimization Algorithm (QAOA) is one of the quantum optimization algorithms that use a variational quantum circuit. For a detailed explanation, please refer to paper [1], but here we will only give a rough overview. In QAOA, a variational quantum circuit is constructed by applying the Ising Hamiltonian $H_P = \\sum_{ij}J_{ij}Z_iZ_j$ and the $X$-mixer Hamiltonian $H_M = \\sum_iX_i$ in the following way: If we start with an initial state $\\ket{\\psi_0}$, then $$\\ket{\\psi(\\beta,\\gamma)} = e^{-\\beta_pH_M}e^{-\\gamma_pH_P}\\cdots e^{-\\beta_1H_M}e^{-\\gamma_1H_P}\\ket{\\psi_0}$$ can be written. Here, $\\beta_k,\\gamma_k$ are the parameters to be optimized, and since the operation $e^{-\\beta_kH_M}e^{-\\gamma_kH_P}$ is repeated $p$ times, there are a total of $2p$ parameters. In the standard QAOA, the total number of parameters is independent of the number of qubits and depends only on the number of repetitions.</p> <p>Optimization of $\\beta_k,\\gamma_k$ is performed by repeating the following steps 1 and 2:</p> <ol> <li>Compute the expectation value $\\bra{\\psi(\\beta,\\gamma)}H_P\\ket{\\psi(\\beta,\\gamma)}$ on a quantum device.</li> <li>Update the parameters on a classical computer to minimize the expectation value.</li> </ol> <p>By repeating this calculation of the expectation value on the quantum computer and optimization of parameters on the classical computer, we obtain the minimum energy $\\langle H_P \\rangle$ and the corresponding final state. If we consider QAOA as a mathematical optimization algorithm, this minimum energy corresponds to the minimum objective function value, and the final state becomes the optimal solution.</p>"},{"location":"tutorial/alternating_ansatz_graph_coloring_qiskit/#implementing-qaoa-using-jtq","title":"Implementing QAOA using JTQ\u00b6","text":"<p>Now, let's try solving the Graph Coloring Problem using QAOA. To execute QAOA, it's necessary to convert the mathematical model into an Ising Hamiltonian, and then create a variational quantum circuit and Hamiltonian using a quantum computing library. However, since JTQ supports QAOA, it allows for relatively easy execution.</p>"},{"location":"tutorial/alternating_ansatz_graph_coloring_qiskit/#quantum-alternating-operator-ansatz","title":"Quantum Alternating Operator Ansatz\u00b6","text":"<p>Next, let's try solving the graph coloring problem using the Quantum Alternating Operator Ansatz. The Quantum Alternating Operator Ansatz[2] is a modification of QAOA, where the mixer is changed from an $X$-mixer to a mixer tailored to the problem, ensuring that only solutions satisfying the constraints are searched for. For more detailed information, please refer to the original paper. Here, we will look at how to implement it in JTQ.</p> <p>For the Graph Coloring problem, there is a one-hot constraint: $$ \\sum_k x_{v,k} = 1\\quad \\forall v $$ However, turning this into an $XY$-mixer is the Quantum Alternating Operator Ansatz approach to the Graph Coloring problem.</p>"},{"location":"tutorial/alternating_ansatz_graph_coloring_qiskit/#references","title":"References\u00b6","text":"<p>[1] E. Farhi et al., \"A Quantum Approximate Optimization Algorithm\" arXiv (2014) [2] S. Hadfield et al., \"From the Quantum Approximate Optimization Algorithm to a Quantum Alternating Operator Ansatz\", algorithms (2019)</p>"},{"location":"tutorial/alternating_ansatz_graph_coloring_quri/","title":"Graph Coloring by QURI Parts","text":"In\u00a0[1]: Copied! <pre>from __future__ import annotations\n\nimport jijmodeling as jm\nimport jijmodeling_transpiler.core as jtc\nimport jijmodeling_transpiler_quantum.quri_parts as jt_qu\n\nimport networkx as nx\n\nfrom quri_parts.qulacs.estimator import (\n    create_qulacs_vector_parametric_estimator,\n)\nfrom quri_parts.qulacs.sampler import create_qulacs_vector_sampler\nfrom quri_parts.circuit import (\n    LinearMappedUnboundParametricQuantumCircuit,\n    Parameter,\n)\nfrom quri_parts.core.state import ParametricCircuitQuantumState\nfrom quri_parts.core.operator import Operator, pauli_label\n\nfrom scipy.optimize import minimize, OptimizeResult\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> from __future__ import annotations  import jijmodeling as jm import jijmodeling_transpiler.core as jtc import jijmodeling_transpiler_quantum.quri_parts as jt_qu  import networkx as nx  from quri_parts.qulacs.estimator import (     create_qulacs_vector_parametric_estimator, ) from quri_parts.qulacs.sampler import create_qulacs_vector_sampler from quri_parts.circuit import (     LinearMappedUnboundParametricQuantumCircuit,     Parameter, ) from quri_parts.core.state import ParametricCircuitQuantumState from quri_parts.core.operator import Operator, pauli_label  from scipy.optimize import minimize, OptimizeResult  import numpy as np import matplotlib.pyplot as plt <p>First, we will implement the mathematical model of the graph coloring problem using JijModeling.</p> In\u00a0[2]: Copied! <pre>def graph_coloring_problem() -&gt; jm.Problem:\n    # define variables\n    V = jm.Placeholder(\"V\")\n    E = jm.Placeholder(\"E\", ndim=2)\n    N = jm.Placeholder(\"N\")\n    x = jm.BinaryVar(\"x\", shape=(V, N))\n    n = jm.Element(\"i\", belong_to=(0, N))\n    v = jm.Element(\"v\", belong_to=(0, V))\n    e = jm.Element(\"e\", belong_to=E)\n    # set problem\n    problem = jm.Problem(\"Graph Coloring\")\n    # set one-hot constraint that each vertex has only one color\n\n    problem += jm.Constraint(\"one-color\", x[v, :].sum() == 1, forall=v)\n    # set objective function: minimize edges whose vertices connected by edges are the same color\n    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])\n    return problem\n</pre> def graph_coloring_problem() -&gt; jm.Problem:     # define variables     V = jm.Placeholder(\"V\")     E = jm.Placeholder(\"E\", ndim=2)     N = jm.Placeholder(\"N\")     x = jm.BinaryVar(\"x\", shape=(V, N))     n = jm.Element(\"i\", belong_to=(0, N))     v = jm.Element(\"v\", belong_to=(0, V))     e = jm.Element(\"e\", belong_to=E)     # set problem     problem = jm.Problem(\"Graph Coloring\")     # set one-hot constraint that each vertex has only one color      problem += jm.Constraint(\"one-color\", x[v, :].sum() == 1, forall=v)     # set objective function: minimize edges whose vertices connected by edges are the same color     problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])     return problem In\u00a0[3]: Copied! <pre>problem = graph_coloring_problem()\nproblem\n</pre> problem = graph_coloring_problem() problem Out[3]:  $$\\begin{array}{cccc}\\text{Problem:} &amp; \\text{Graph Coloring} &amp; &amp; \\\\&amp; &amp; \\min \\quad \\displaystyle \\sum_{i = 0}^{N - 1} \\sum_{e \\in E} x_{e_{0}, i} \\cdot x_{e_{1}, i} &amp; \\\\\\text{{s.t.}} &amp; &amp; &amp; \\\\ &amp; \\text{one-color} &amp; \\displaystyle \\sum_{\\ast_{1} = 0}^{N - 1} x_{v, \\ast_{1}} = 1 &amp; \\forall v \\in \\left\\{0,\\ldots,V - 1\\right\\} \\\\\\text{{where}} &amp; &amp; &amp; \\\\&amp; x &amp; 2\\text{-dim binary variable}\\\\\\end{array}$$  <p>Next, we will create an instance of the problem.</p> In\u00a0[4]: Copied! <pre>G = nx.Graph()\nG.add_nodes_from([0, 1, 2, 3, 4])\nG.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])\nnx.draw(G)\n</pre> G = nx.Graph() G.add_nodes_from([0, 1, 2, 3, 4]) G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)]) nx.draw(G) In\u00a0[5]: Copied! <pre>inst_E = [list(edge) for edge in G.edges]\ncolor_num = 3\nnum_nodes = G.number_of_nodes()\ninstance_data = {\"V\": num_nodes, \"N\": color_num, \"E\": inst_E}\nnum_qubits = num_nodes * color_num\n</pre> inst_E = [list(edge) for edge in G.edges] color_num = 3 num_nodes = G.number_of_nodes() instance_data = {\"V\": num_nodes, \"N\": color_num, \"E\": inst_E} num_qubits = num_nodes * color_num <p>First, we use JijModeling-Transpiler to create a CompiledInstance from the mathematical model and instance data of JijModeling.</p> <p>First, using JijModeling-Transpiler, we create a CompiledInstance from JijModeling's mathematical model and instance data.</p> In\u00a0[6]: Copied! <pre>compiled_instance = jtc.compile_model(problem, instance_data)\n</pre> compiled_instance = jtc.compile_model(problem, instance_data) <p>Next, we create a QAOABuilder using JTQ's transpile_to_qaoa_ansatz. By setting the number of repetitions for QAOA layers and the weight coefficients for constraints in this Builder, we can create the variational quantum circuit and Hamiltonian for QAOA.</p> In\u00a0[7]: Copied! <pre>qaoa_builder = jt_qu.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False,relax_method=jtc.pubo.RelaxationMethod.SquaredPenalty)\nqaoa_ansatz, hamiltonian, constant = qaoa_builder.get_qaoa_ansatz(\n    p=1, multipliers={\"one-color\": 1}\n)\n</pre> qaoa_builder = jt_qu.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False,relax_method=jtc.pubo.RelaxationMethod.SquaredPenalty) qaoa_ansatz, hamiltonian, constant = qaoa_builder.get_qaoa_ansatz(     p=1, multipliers={\"one-color\": 1} ) <p>Now that we have the variational quantum circuit and Hamiltonian ready, let's execute QAOA using quri_parts.</p> In\u00a0[8]: Copied! <pre>def run_qaoa(\n    ansatz: LinearMappedUnboundParametricQuantumCircuit,\n    hamiltonian: Operator,\n    method: str | callable,\n) -&gt; OptimizeResult:\n    def _cost_func(parameters, ansatz, hamiltonian, estimator):\n        parametric_state = ParametricCircuitQuantumState(\n            ansatz.qubit_count, ansatz\n        )\n        estimate = estimator(hamiltonian, parametric_state, parameters)\n        return estimate.value.real\n\n    initial_params = np.array([1.0] * ansatz.parameter_count)\n\n    estimator = create_qulacs_vector_parametric_estimator()\n\n    result = minimize(\n        _cost_func,\n        initial_params,\n        args=(ansatz, hamiltonian, estimator),\n        method=method)\n\n    return result\n</pre> def run_qaoa(     ansatz: LinearMappedUnboundParametricQuantumCircuit,     hamiltonian: Operator,     method: str | callable, ) -&gt; OptimizeResult:     def _cost_func(parameters, ansatz, hamiltonian, estimator):         parametric_state = ParametricCircuitQuantumState(             ansatz.qubit_count, ansatz         )         estimate = estimator(hamiltonian, parametric_state, parameters)         return estimate.value.real      initial_params = np.array([1.0] * ansatz.parameter_count)      estimator = create_qulacs_vector_parametric_estimator()      result = minimize(         _cost_func,         initial_params,         args=(ansatz, hamiltonian, estimator),         method=method)      return result In\u00a0[9]: Copied! <pre>result = run_qaoa(qaoa_ansatz, hamiltonian, \"COBYLA\")\n</pre> result = run_qaoa(qaoa_ansatz, hamiltonian, \"COBYLA\") <p>We will try sampling the solution using the obtained variational parameters. Here, we are converting the results into a jm.SampleSet. By doing this, the solution is automatically transformed into the form formulated by the mathematical model, and it also calculates constraint violations and objective function values.</p> In\u00a0[10]: Copied! <pre>def sample_result(\n    result: OptimizeResult,\n    ansatz: LinearMappedUnboundParametricQuantumCircuit,\n    num_qubits: int,\n    num_shots: int = 1000,\n) -&gt; jm.SampleSet:\n    bind_ansatz_opt = ansatz.bind_parameters(result.x)\n    sampler = create_qulacs_vector_sampler()\n    sampling_result = sampler(bind_ansatz_opt, num_shots)\n    result_bits = {\n        bin(key)[2:].zfill(num_qubits)[::-1]: val\n        for key, val in sampling_result.items()\n    }\n    sampleset = qaoa_builder.decode_from_counts(result_bits)\n    return sampleset\n</pre> def sample_result(     result: OptimizeResult,     ansatz: LinearMappedUnboundParametricQuantumCircuit,     num_qubits: int,     num_shots: int = 1000, ) -&gt; jm.SampleSet:     bind_ansatz_opt = ansatz.bind_parameters(result.x)     sampler = create_qulacs_vector_sampler()     sampling_result = sampler(bind_ansatz_opt, num_shots)     result_bits = {         bin(key)[2:].zfill(num_qubits)[::-1]: val         for key, val in sampling_result.items()     }     sampleset = qaoa_builder.decode_from_counts(result_bits)     return sampleset In\u00a0[11]: Copied! <pre>sampleset = sample_result(result, qaoa_ansatz, num_qubits)\n</pre> sampleset = sample_result(result, qaoa_ansatz, num_qubits) In\u00a0[12]: Copied! <pre>sampleset.lowest()\n</pre> sampleset.lowest() Out[12]: <pre>SampleSet(record=Record(solution={'x': [(([2, 3, 0, 1, 4], [0, 1, 2, 2, 2]), [1.0, 1.0, 1.0, 1.0, 1.0], (5, 3)), (([0, 4, 2, 3, 1], [0, 0, 1, 1, 2]), [1.0, 1.0, 1.0, 1.0, 1.0], (5, 3)), (([2, 0, 1, 4, 3], [0, 1, 1, 1, 2]), [1.0, 1.0, 1.0, 1.0, 1.0], (5, 3))]}, num_occurrences=[1, 1, 1]), evaluation=Evaluation(energy=[], objective=[1.0, 1.0, 1.0], constraint_violations={\"one-color\": [0.0, 0.0, 0.0]}, constraint_forall={}, constraint_values=[], penalty={}), measuring_time=MeasuringTime(solve=SolvingTime(preprocess=None, solve=None, postprocess=None), system=SystemTime(post_problem_and_instance_data=None, request_queue=None, fetch_problem_and_instance_data=None, fetch_result=None, deserialize_solution=None), total=None), metadata={})</pre> <p>Finally, let's plot the results obtained from sampling.</p> In\u00a0[13]: Copied! <pre>def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):\n    # extract feasible solution\n    feasibles = sampleset.feasible()\n    if feasibles.evaluation.objective.size == 0:\n        print(\"No feasible solution found ...\")\n    else:\n        objectives = np.array(feasibles.evaluation.objective)\n        lowest_index = np.argmin(objectives)\n\n        # get indices of x = 1\n        indices, _, _ = feasibles.record.solution[\"x\"][lowest_index]\n        # get vertices and colors\n        sorted_vertices, sorted_colors = zip(\n            *sorted(zip(*indices), key=lambda x: x[1])\n        )\n        # initialize vertex color list\n        node_colors = [-1] * len(sorted_vertices)\n        # set color list for visualization\n        colorlist = [\"gold\", \"violet\", \"limegreen\", \"darkorange\"]\n        # set vertex color list\n        for i, j in zip(sorted_vertices, sorted_colors):\n            node_colors[i] = colorlist[j]\n        # make figure\n        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)\n        plt.show()\n</pre> def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):     # extract feasible solution     feasibles = sampleset.feasible()     if feasibles.evaluation.objective.size == 0:         print(\"No feasible solution found ...\")     else:         objectives = np.array(feasibles.evaluation.objective)         lowest_index = np.argmin(objectives)          # get indices of x = 1         indices, _, _ = feasibles.record.solution[\"x\"][lowest_index]         # get vertices and colors         sorted_vertices, sorted_colors = zip(             *sorted(zip(*indices), key=lambda x: x[1])         )         # initialize vertex color list         node_colors = [-1] * len(sorted_vertices)         # set color list for visualization         colorlist = [\"gold\", \"violet\", \"limegreen\", \"darkorange\"]         # set vertex color list         for i, j in zip(sorted_vertices, sorted_colors):             node_colors[i] = colorlist[j]         # make figure         nx.draw_networkx(graph, node_color=node_colors, with_labels=True)         plt.show() In\u00a0[14]: Copied! <pre>plot_graph_coloring(G, sampleset)\n</pre> plot_graph_coloring(G, sampleset) <p>First, we prepare a mathematical model excluding the constraints.</p> In\u00a0[15]: Copied! <pre>def graph_coloring_problem_wo_onehot() -&gt; jm.Problem:\n    # define variables\n    V = jm.Placeholder(\"V\")\n    E = jm.Placeholder(\"E\", ndim=2)\n    N = jm.Placeholder(\"N\")\n    x = jm.BinaryVar(\"x\", shape=(V, N))\n    n = jm.Element(\"i\", belong_to=(0, N))\n    v = jm.Element(\"v\", belong_to=(0, V))\n    e = jm.Element(\"e\", belong_to=E)\n    # set problem\n    problem = jm.Problem(\"Graph Coloring without Onehot\")\n    # set one-hot constraint that each vertex has only one color\n    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])\n    return problem\n</pre> def graph_coloring_problem_wo_onehot() -&gt; jm.Problem:     # define variables     V = jm.Placeholder(\"V\")     E = jm.Placeholder(\"E\", ndim=2)     N = jm.Placeholder(\"N\")     x = jm.BinaryVar(\"x\", shape=(V, N))     n = jm.Element(\"i\", belong_to=(0, N))     v = jm.Element(\"v\", belong_to=(0, V))     e = jm.Element(\"e\", belong_to=E)     # set problem     problem = jm.Problem(\"Graph Coloring without Onehot\")     # set one-hot constraint that each vertex has only one color     problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])     return problem In\u00a0[16]: Copied! <pre>problem = graph_coloring_problem_wo_onehot()\nproblem\n</pre> problem = graph_coloring_problem_wo_onehot() problem Out[16]:  $$\\begin{array}{cccc}\\text{Problem:} &amp; \\text{Graph Coloring without Onehot} &amp; &amp; \\\\&amp; &amp; \\min \\quad \\displaystyle \\sum_{i = 0}^{N - 1} \\sum_{e \\in E} x_{e_{0}, i} \\cdot x_{e_{1}, i} &amp; \\\\\\text{{where}} &amp; &amp; &amp; \\\\&amp; x &amp; 2\\text{-dim binary variable}\\\\\\end{array}$$  <p>Similar to before, we compile and create a QAOABuilder.</p> In\u00a0[17]: Copied! <pre>compiled_instance = jtc.compile_model(problem, instance_data)\nqaoa_builder = jt_qu.qaoa.transpile_to_qaoa_ansatz(compiled_instance)\n</pre> compiled_instance = jtc.compile_model(problem, instance_data) qaoa_builder = jt_qu.qaoa.transpile_to_qaoa_ansatz(compiled_instance) <p>Earlier, we output the Ansatz as well, but here, since only the Ising Hamiltonian part is sufficient, we will just output the Hamiltonian.</p> In\u00a0[18]: Copied! <pre>ising_operator, _ = qaoa_builder.get_hamiltonian()\n</pre> ising_operator, _ = qaoa_builder.get_hamiltonian() <p>Let's write a function to add gates on top of the Pauli operators in the Hamiltonian.</p> In\u00a0[19]: Copied! <pre>def add_exp_operator_to_circuit(\n    ansatz: LinearMappedUnboundParametricQuantumCircuit,\n    parameter: Parameter,\n    hamiltonian: Operator,\n):\n    for key, value in hamiltonian.items():\n        if key != pauli_label({}):\n            indexes, pauli_ids = key.index_and_pauli_id_list\n            ansatz.add_ParametricPauliRotation_gate(\n                indexes, pauli_ids, angle={parameter: value}\n            )\n    return ansatz\n</pre> def add_exp_operator_to_circuit(     ansatz: LinearMappedUnboundParametricQuantumCircuit,     parameter: Parameter,     hamiltonian: Operator, ):     for key, value in hamiltonian.items():         if key != pauli_label({}):             indexes, pauli_ids = key.index_and_pauli_id_list             ansatz.add_ParametricPauliRotation_gate(                 indexes, pauli_ids, angle={parameter: value}             )     return ansatz <p>Next, we will create an $XY$-mixer. The $XY$-mixer can be written as $$ XY_{ij} = \\frac{1}{2}\\left(X_iX_j + Y_iY_j \\right). $$ This is an operator that swaps the bits 1 and 0 in bit $i,j$. Therefore, it can transform a bit string $100$, which satisfies the one-hot constraint, into another bit string $010$, which also satisfies the one-hot constraint.</p> <p>Here, the only part under the one-hot constraint is related to color, so in terms of the mathematical model, we need to transform the bits between $x_{v0}$ and $x_{v1}$. On the other hand, as these variables are usually embedded in qubits, it is necessary to remember which bit corresponds to which variable when constructing the algorithm and handle them appropriately. In JTQ, the correspondence of variables is contained in var_map inside CompiledInstance.</p> <pre>var_map['variable_name'][indices]\n</pre> <p>You can check which qubit corresponds to a variable in the mathematical model in this way. Let's use this to create an $XY$-mixer.</p> <p>What we want here is the transformation between $x_{v,k}$ and $x_{v,k+1}$, so we can obtain the index of the corresponding qubit by accessing compiled_instance.var_map.var_map[\"x\"][(i,k)].\"</p> In\u00a0[20]: Copied! <pre>def xy_mixer_hamiltonian(\n    num_nodes: int, num_colors: int, compiled_instance: jtc.CompiledInstance\n):\n    hamiltonian = Operator()\n    var_map = compiled_instance.var_map.var_map[\"x\"]\n    for i in range(num_nodes):\n        for k in range(0, num_colors - 1, 2):\n            hamiltonian.add_term(\n                pauli_label(f\"X{var_map[(i,k)]} X{var_map[(i,k+1)]}\"), 1 / 2\n            )\n            hamiltonian.add_term(\n                pauli_label(f\"Y{var_map[(i,k)]} Y{var_map[(i,k+1)]}\"), 1 / 2\n            )\n\n    # odd\n    for i in range(num_nodes):\n        for k in range(1, num_colors - 1, 2):\n            hamiltonian.add_term(\n                pauli_label(f\"X{var_map[(i,k)]} X{var_map[(i,k+1)]}\"), 1 / 2\n            )\n            hamiltonian.add_term(\n                pauli_label(f\"Y{var_map[(i,k)]} Y{var_map[(i,k+1)]}\"), 1 / 2\n            )\n\n    # ini-last\n    if num_colors % 2 == 1:\n        for i in range(num_nodes):\n            hamiltonian.add_term(\n                pauli_label(f\"X{var_map[(i,0)]} X{var_map[(i,num_colors-1)]}\"),\n                1 / 2,\n            )\n            hamiltonian.add_term(\n                pauli_label(f\"Y{var_map[(i,0)]} Y{var_map[(i,num_colors-1)]}\"),\n                1 / 2,\n            )\n\n    return hamiltonian\n</pre> def xy_mixer_hamiltonian(     num_nodes: int, num_colors: int, compiled_instance: jtc.CompiledInstance ):     hamiltonian = Operator()     var_map = compiled_instance.var_map.var_map[\"x\"]     for i in range(num_nodes):         for k in range(0, num_colors - 1, 2):             hamiltonian.add_term(                 pauli_label(f\"X{var_map[(i,k)]} X{var_map[(i,k+1)]}\"), 1 / 2             )             hamiltonian.add_term(                 pauli_label(f\"Y{var_map[(i,k)]} Y{var_map[(i,k+1)]}\"), 1 / 2             )      # odd     for i in range(num_nodes):         for k in range(1, num_colors - 1, 2):             hamiltonian.add_term(                 pauli_label(f\"X{var_map[(i,k)]} X{var_map[(i,k+1)]}\"), 1 / 2             )             hamiltonian.add_term(                 pauli_label(f\"Y{var_map[(i,k)]} Y{var_map[(i,k+1)]}\"), 1 / 2             )      # ini-last     if num_colors % 2 == 1:         for i in range(num_nodes):             hamiltonian.add_term(                 pauli_label(f\"X{var_map[(i,0)]} X{var_map[(i,num_colors-1)]}\"),                 1 / 2,             )             hamiltonian.add_term(                 pauli_label(f\"Y{var_map[(i,0)]} Y{var_map[(i,num_colors-1)]}\"),                 1 / 2,             )      return hamiltonian In\u00a0[21]: Copied! <pre>def create_initial_state(\n    ansatz: LinearMappedUnboundParametricQuantumCircuit,\n    compiled_instance: jtc.CompiledInstance,\n    num_nodes: int,\n):\n    var_map = compiled_instance.var_map.var_map[\"x\"]\n    for i in range(num_nodes):\n        idx = var_map[(i, 0)]\n        ansatz.add_X_gate(idx)\n    return ansatz\n</pre> def create_initial_state(     ansatz: LinearMappedUnboundParametricQuantumCircuit,     compiled_instance: jtc.CompiledInstance,     num_nodes: int, ):     var_map = compiled_instance.var_map.var_map[\"x\"]     for i in range(num_nodes):         idx = var_map[(i, 0)]         ansatz.add_X_gate(idx)     return ansatz In\u00a0[22]: Copied! <pre>def create_ansatz(\n    num_layers: int,\n    ising_operator: Operator,\n    num_qubits: int,\n    num_nodes: int,\n    color_num: int,\n    compiled_instance: jtc.CompiledInstance,\n):\n    mixer_hamiltonian = xy_mixer_hamiltonian(\n        num_nodes, color_num, compiled_instance\n    )\n    ansatz = LinearMappedUnboundParametricQuantumCircuit(num_qubits)\n    ansatz = create_initial_state(ansatz, compiled_instance, num_nodes)\n\n    for p in range(num_layers):\n        gamma, beta = ansatz.add_parameters(f\"gamma_{p}\", f\"beta_{p}\")\n        ansatz = add_exp_operator_to_circuit(ansatz, gamma, ising_operator)\n        ansatz = add_exp_operator_to_circuit(ansatz, beta, mixer_hamiltonian)\n    return ansatz\n</pre> def create_ansatz(     num_layers: int,     ising_operator: Operator,     num_qubits: int,     num_nodes: int,     color_num: int,     compiled_instance: jtc.CompiledInstance, ):     mixer_hamiltonian = xy_mixer_hamiltonian(         num_nodes, color_num, compiled_instance     )     ansatz = LinearMappedUnboundParametricQuantumCircuit(num_qubits)     ansatz = create_initial_state(ansatz, compiled_instance, num_nodes)      for p in range(num_layers):         gamma, beta = ansatz.add_parameters(f\"gamma_{p}\", f\"beta_{p}\")         ansatz = add_exp_operator_to_circuit(ansatz, gamma, ising_operator)         ansatz = add_exp_operator_to_circuit(ansatz, beta, mixer_hamiltonian)     return ansatz <p>Now that the Ansatz has been created, we would like to run the Quantum Alternating Operator Ansatz using this Ansatz.</p> In\u00a0[23]: Copied! <pre>ansatz = create_ansatz(\n    1, ising_operator, num_qubits, num_nodes, color_num, compiled_instance\n)\n</pre> ansatz = create_ansatz(     1, ising_operator, num_qubits, num_nodes, color_num, compiled_instance ) In\u00a0[24]: Copied! <pre>result = run_qaoa(ansatz, ising_operator, \"COBYLA\")\n</pre> result = run_qaoa(ansatz, ising_operator, \"COBYLA\") In\u00a0[25]: Copied! <pre>sampleset = sample_result(result, ansatz, num_qubits)\n</pre> sampleset = sample_result(result, ansatz, num_qubits) <p>Let's plot the results obtained.</p> In\u00a0[26]: Copied! <pre>plot_graph_coloring(G, sampleset)\n</pre> plot_graph_coloring(G, sampleset) <p>Finally, let's try solving a slightly larger problem.</p> In\u00a0[27]: Copied! <pre>G = nx.Graph()\nG.add_nodes_from([0, 1, 2, 3, 4, 5])\nG.add_edges_from(\n    [(0, 1), (0, 2), (0, 5), (1, 2), (1, 3), (2, 4), (3, 4), (3, 5), (4, 5)]\n)\nnx.draw(G)\ninst_E = [list(edge) for edge in G.edges]\ncolor_num = 3\nnum_nodes = G.number_of_nodes()\ninstance_data = {\"V\": num_nodes, \"N\": color_num, \"E\": inst_E}\nnum_qubits = num_nodes * color_num\n</pre> G = nx.Graph() G.add_nodes_from([0, 1, 2, 3, 4, 5]) G.add_edges_from(     [(0, 1), (0, 2), (0, 5), (1, 2), (1, 3), (2, 4), (3, 4), (3, 5), (4, 5)] ) nx.draw(G) inst_E = [list(edge) for edge in G.edges] color_num = 3 num_nodes = G.number_of_nodes() instance_data = {\"V\": num_nodes, \"N\": color_num, \"E\": inst_E} num_qubits = num_nodes * color_num In\u00a0[28]: Copied! <pre>compiled_instance = jtc.compile_model(graph_coloring_problem(), instance_data)\nqaoa_builder = jt_qu.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False)\nqaoa_ansatz, hamiltonian, constant = qaoa_builder.get_qaoa_ansatz(\n    p=1, multipliers={\"one-color\": 1}\n)\nqaoa_result = run_qaoa(qaoa_ansatz, hamiltonian, \"COBYLA\")\nqaoa_sampleset = sample_result(qaoa_result, qaoa_ansatz, num_qubits)\nplot_graph_coloring(G, qaoa_sampleset)\n</pre> compiled_instance = jtc.compile_model(graph_coloring_problem(), instance_data) qaoa_builder = jt_qu.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False) qaoa_ansatz, hamiltonian, constant = qaoa_builder.get_qaoa_ansatz(     p=1, multipliers={\"one-color\": 1} ) qaoa_result = run_qaoa(qaoa_ansatz, hamiltonian, \"COBYLA\") qaoa_sampleset = sample_result(qaoa_result, qaoa_ansatz, num_qubits) plot_graph_coloring(G, qaoa_sampleset) In\u00a0[29]: Copied! <pre>compiled_instance = jtc.compile_model(graph_coloring_problem_wo_onehot(), instance_data)\nqaoa_builder = jt_qu.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False)\nising_operator, _ = qaoa_builder.get_hamiltonian()\nansatz = create_ansatz(\n    1, ising_operator, num_qubits, num_nodes, color_num, compiled_instance\n)\nalternating_result = run_qaoa(ansatz, ising_operator, \"COBYLA\")\nalternating_sampleset = sample_result(alternating_result, ansatz, num_qubits)\nplot_graph_coloring(G, alternating_sampleset)\n</pre> compiled_instance = jtc.compile_model(graph_coloring_problem_wo_onehot(), instance_data) qaoa_builder = jt_qu.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False) ising_operator, _ = qaoa_builder.get_hamiltonian() ansatz = create_ansatz(     1, ising_operator, num_qubits, num_nodes, color_num, compiled_instance ) alternating_result = run_qaoa(ansatz, ising_operator, \"COBYLA\") alternating_sampleset = sample_result(alternating_result, ansatz, num_qubits) plot_graph_coloring(G, alternating_sampleset) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorial/alternating_ansatz_graph_coloring_quri/#quantum-alternating-operator-ansatz-for-graph-coloring-problem-with-quri-parts","title":"Quantum Alternating Operator Ansatz for Graph Coloring Problem with Quri-parts\u00b6","text":"<p>In this tutorial, we would like to explain the functionality while solving the Graph Coloring Problem using the Quantum Approximate Optimization Algorithm and the Quantum Alternating Operator Ansatz. This time, we are going to conduct simulations using quri_parts.</p>"},{"location":"tutorial/alternating_ansatz_graph_coloring_quri/#quantum-approximate-optimazation-algorithm-qaoa","title":"Quantum Approximate Optimazation Algorithm (QAOA)\u00b6","text":"<p>The Quantum Approximate Optimization Algorithm (QAOA) is one of the quantum optimization algorithms that use a variational quantum circuit. For a detailed explanation, please refer to paper [1], but here we will only give a rough overview. In QAOA, a variational quantum circuit is constructed by applying the Ising Hamiltonian $H_P = \\sum_{ij}J_{ij}Z_iZ_j$ and the $X$-mixer Hamiltonian $H_M = \\sum_iX_i$ in the following way: If we start with an initial state $\\ket{\\psi_0}$, then $$\\ket{\\psi(\\beta,\\gamma)} = e^{-\\beta_pH_M}e^{-\\gamma_pH_P}\\cdots e^{-\\beta_1H_M}e^{-\\gamma_1H_P}\\ket{\\psi_0}$$ can be written. Here, $\\beta_k,\\gamma_k$ are the parameters to be optimized, and since the operation $e^{-\\beta_kH_M}e^{-\\gamma_kH_P}$ is repeated $p$ times, there are a total of $2p$ parameters. In the standard QAOA, the total number of parameters is independent of the number of qubits and depends only on the number of repetitions.</p> <p>Optimization of $\\beta_k,\\gamma_k$ is performed by repeating the following steps 1 and 2:</p> <ol> <li>Compute the expectation value $\\bra{\\psi(\\beta,\\gamma)}H_P\\ket{\\psi(\\beta,\\gamma)}$ on a quantum device.</li> <li>Update the parameters on a classical computer to minimize the expectation value.</li> </ol> <p>By repeating this calculation of the expectation value on the quantum computer and optimization of parameters on the classical computer, we obtain the minimum energy $\\langle H_P \\rangle$ and the corresponding final state. If we consider QAOA as a mathematical optimization algorithm, this minimum energy corresponds to the minimum objective function value, and the final state becomes the optimal solution.</p>"},{"location":"tutorial/alternating_ansatz_graph_coloring_quri/#implementing-qaoa-using-jtq","title":"Implementing QAOA using JTQ\u00b6","text":"<p>Now, let's try solving the Graph Coloring Problem using QAOA. To execute QAOA, it's necessary to convert the mathematical model into an Ising Hamiltonian, and then create a variational quantum circuit and Hamiltonian using a quantum computing library. However, since JTQ supports QAOA, it allows for relatively easy execution.</p>"},{"location":"tutorial/alternating_ansatz_graph_coloring_quri/#quantum-alternating-operator-ansatz","title":"Quantum Alternating Operator Ansatz\u00b6","text":"<p>Next, let's try solving the graph coloring problem using the Quantum Alternating Operator Ansatz. The Quantum Alternating Operator Ansatz is a modification of QAOA, where the mixer is changed from an $X$-mixer to a mixer tailored to the problem, ensuring that only solutions satisfying the constraints are searched for. For more detailed information, please refer to the original paper. Here, we will look at how to implement it in JTQ.</p> <p>For the Graph Coloring problem, there is a one-hot constraint: $$ \\sum_k x_{v,k} = 1\\quad \\forall v $$ However, turning this into an $XY$-mixer is the Quantum Alternating Operator Ansatz approach to the Graph Coloring problem.</p>"}]}