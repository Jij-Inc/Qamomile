# Graph Coloring Problem with Quantum Alternating Operator Ansatz
In this tutorial, we will solve the Graph Coloring Problem using the Quantum Alternating Operator Ansatz.


```python
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as opt
import networkx as nx
import qiskit.primitives as qk_pr

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt

import qamomile.core as qm
from qamomile.qiskit import QiskitTranspiler
from qamomile.core.circuit.drawer import plot_quantum_circuit
```

First, we will implement the mathematical model of the graph coloring problem using JijModeling.


```python
def graph_coloring_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    N = jm.Placeholder("N")
    x = jm.BinaryVar("x", shape=(V, N))
    n = jm.Element("i", belong_to=(0, N))
    v = jm.Element("v", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)
    # set problem
    problem = jm.Problem("Graph Coloring")
    # set one-hot constraint that each vertex has only one color

    problem += jm.Constraint("one-color", x[v, :].sum() == 1, forall=v)
    # set objective function: minimize edges whose vertices connected by edges are the same color
    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])
    return problem

problem = graph_coloring_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Coloring} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 1} \sum_{e \in E} x_{e_{0}, i} \cdot x_{e_{1}, i} & \\\text{{s.t.}} & & & \\ & \text{one-color} & \displaystyle \sum_{\ast_{1} = 0}^{N - 1} x_{v, \ast_{1}} = 1 & \forall v \in \left\{0,\ldots,V - 1\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will create an instance of the problem.


```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])
nx.draw(G)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_5_0.png)
    



```python
inst_E = [list(edge) for edge in G.edges]
color_num = 3
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "N": color_num, "E": inst_E}
num_qubits = num_nodes * color_num
```

# Quantum Alternating Operator Ansatz
Next, let's try solving the graph coloring problem using the Quantum Alternating Operator Ansatz. The Quantum Alternating Operator Ansatz[2] is a modification of QAOA, where the mixer is changed from an $X$-mixer to a mixer tailored to the problem, ensuring that only solutions satisfying the constraints are searched for. For more detailed information, please refer to the original paper. Here, we will look at how to implement it in JTQ.

For the Graph Coloring problem, there is a one-hot constraint:

$$
\sum_k x_{v,k} = 1\quad \forall v
$$

However, turning this into an $XY$-mixer is the Quantum Alternating Operator Ansatz approach to the Graph Coloring problem.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
```


```python
gamma_1 = qm.circuit.Parameter("gamma_1")
# Delete one-color penalty.
qaoa_converter.ising_encode(multipliers={"one-color": 0.0})
# Get exp(-i gamma H_P) circuit without mixer circuit.  
qaoa_cost_circuit = qaoa_converter.get_cost_ansatz(gamma_1)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```

Next, we will create an $XY$-mixer. The $XY$-mixer can be written as

$$
XY_{ij} = \frac{1}{2}\left(X_iX_j + Y_iY_j \right).
$$

This is an operator that swaps the bits 1 and 0 in bit $i,j$. Therefore, it can transform a bit string $100$, which satisfies the one-hot constraint, into another bit string $010$, which also satisfies the one-hot constraint.

Here, the only part under the one-hot constraint is related to color, so in terms of the mathematical model, we need to transform the bits between $x_{v0}$ and $x_{v1}$.
On the other hand, as these variables are usually embedded in qubits, it is necessary to remember which bit corresponds to which variable when constructing the algorithm and handle them appropriately.
In JTQ, the correspondence of variables is contained in var_map inside CompiledInstance.
```python
var_map['variable_name'][indices]
```
You can check which qubit corresponds to a variable in the mathematical model in this way.
Let's use this to create an $XY$-mixer.

What we want here is the transformation between $x_{v,k}$ and $x_{v,k+1}$, so we can obtain the index of the corresponding qubit by accessing compiled_instance.var_map.var_map["x"][(i,k)]."


```python
def create_xy_mixer(
    beta: qm.circuit.Parameter,
    num_nodes: int,
    num_color: int,
    compiled_instance: jmt.CompiledInstance,
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n, name="XY-mixer")
    var_map = compiled_instance.var_map.var_map["x"]
    # even
    for i in range(num_nodes):
        for k in range(0, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # odd
    for i in range(num_nodes):
        for k in range(1, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # ini-last
    if num_color % 2 == 1:
        for i in range(num_nodes):
            qc.rxx(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
            qc.ryy(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
    return qc
```


```python
def create_initial_state(
    compiled_instance: jmt.CompiledInstance, num_nodes: int, num_color: int
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n)
    var_map = compiled_instance.var_map.var_map["x"]
    for i in range(num_nodes):
        qc.x(var_map[(i, 0)])  # set all nodes to color 0
    return qc
```

Now that the Ansatz has been created, we would like to run the Quantum Alternating Operator Ansatz.


```python
initial_circuit = create_initial_state(compiled_instance, num_nodes, color_num)
initial_circuit.update_qubits_label(qaoa_converter.int2varlabel)
beta_1 = qm.circuit.Parameter("beta_1")
mixer_circuit = create_xy_mixer(beta_1, num_nodes, color_num, compiled_instance)
mixer_circuit.update_qubits_label(qaoa_converter.int2varlabel)
plot_quantum_circuit(mixer_circuit)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_14_0.png)
    



```python
initial_circuit.append(qaoa_cost_circuit)
initial_circuit.append(mixer_circuit)

alternating_ansatz = initial_circuit

plot_quantum_circuit(alternating_ansatz)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_15_0.png)
    


## Run Quantum Alternating Operator Ansatz using Qiskit


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(alternating_ansatz)
qk_cost = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []

def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data["evs"]
    cost_history.append(cost)
    return cost


result = opt.minimize(
    estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 100}
)
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: 2.0625000215201315
           x: [ 7.853e-01  1.102e+00]
        nfev: 34
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_19_0.png)
    



```python
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
plt.show()
job = sampler.run([(qk_circuit, result.x)])
job_result = job.result()
```


```python
sampleset = qaoa_converter.decode(qk_transpiler, job_result[0].data['meas'])
```


```python
import numpy as np
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.experimental.SampleSet):
    # extract feasible solution
    feasibles = sampleset.feasibles()
    if len(feasibles) == 0:
        print("No feasible solution found ...")
    else:
        lowest_sample = sampleset.lowest()[0]

        # get indices of x = 1
        indices = lowest_sample.var_values["x"].values.keys()
        # get vertices and colors
        # initialize vertex color list
        node_colors = [-1] * graph.number_of_nodes()
        # set color list for visualization
        colorlist = ["gold", "violet", "limegreen", "darkorange"]
        # set vertex color list
        for i, j in indices:
            node_colors[i] = colorlist[j]
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)
        plt.show()

plot_graph_coloring(G, sampleset)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_22_0.png)
    


# References
[[1] Farhi, Edward, Jeffrey Goldstone, and Sam Gutmann. "A quantum approximate optimization algorithm." arXiv preprint arXiv:1411.4028 (2014).](https://arxiv.org/abs/1411.4028)

[[2] Hadfield, Stuart, Zhihui Wang, Bryan O’gorman, Eleanor G. Rieffel, Davide Venturelli, and Rupak Biswas. "From the quantum approximate optimization algorithm to a quantum alternating operator ansatz." Algorithms 12, no. 2 (2019): 34.](https://arxiv.org/abs/1709.03489)
# Advanced techniques for Quantum Optimization

## Tutorials

- [Quantum Alternating Operator Ansatz for Graph Coloring](graph_coloring_alternating_ansatz.ipynb): Learn how to run the Quantum Alternating Operator Ansatz for graph coloring problem.
- [Quantum Random Access Optimization (QRAO) for Maxcut problem](qrao_tutorial.ipynb): Learn how to use Quantum Random Access Optimization.
# Quantum Random Access Optimization (QRAO) for Maxcut problem

In this tutorial, we will explain the quantum optimization algorithm called Quantum Random Access Optimization (QRAO)[1].

In the usual QAOA ($(1,1,1)$-QRAO), the optimization problem is encoded in the Ising Hamiltonian. 
In this case, the problem Hamiltonian uses only the Pauli $Z$ operator, but in QRAO, the problem Hamiltonian is constructed using not only Pauli $Z$, but also Pauli $X$ and $Y$.
The Hamiltonian constructed by QRAO is called a relaxed Hamiltonian because the ground state of the relaxed Hamiltonian is not the optimal solution to the original problem.

Several QRAOs have been proposed. The following QRAOs are supported by Qamomile.

| algorithm name | `class name` |
| ---- | ---- |
| $(3,1,p)$-QRAO [1] | [`QRAC31Converter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao31/index.html) |
| $(2,1,p)$-QRAO [1] | [`QRAC21Converter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao21/index.html) |
| $(3,2,p)$-QRAO [2] | [`QRAC32Converter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao32/index.html) |
| Space Compression Ratio Preserving QRAO [2] | [`QRACSpaceEfficientConverter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao_space_efficient/index.html) |

The API documentation explains how each algorithm constructs a relaxed Hamiltonian.


```python
import networkx as nx
import matplotlib.pyplot as plt
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile.core as qm
import qamomile.qiskit as qm_qk
```

# Create problem data and mathematical model
First, we will create the problem data to be solved.

Here, we will solve the maxcut problem for a 3-regular graph, in the same way as [1].


```python
def Maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e,  (1 - si * sj))
    problem += obj
    return problem

problem = Maxcut_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Maxcut} & & \\& & \max \quad \displaystyle 0.5 \cdot \sum_{e \in E} \left(- s_{e[0]} \cdot s_{e[1]} + 1\right) & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



We will create a problem with 12 nodes.


```python
graph = nx.random_regular_graph(3, 12)
nx.draw(graph, with_labels=True)
```


    
![png](qrao_tutorial_files/qrao_tutorial_5_0.png)
    


# Create QRAO Hamiltonian
From here, we will create the relaxed Hamiltonian for QRAO.

First, use `jijmodeling_transpiler` to create a compiled_instance


```python
compiled_instance = jmt.compile_model(problem, {"E": list(graph.edges), "V": len(graph.nodes)})
```

Next, use `QRAC31Converter` to create a relaxed Hamiltonian.


```python
from qamomile.core.converters.qrao.qrao31 import QRAC31Converter

# Initialize with a compiled optimization problem instance
qrao_converter = QRAC31Converter(compiled_instance, normalize_model=False)

# Generate relaxed Hamiltonian
qrao31_hamiltonian = qrao_converter.get_cost_hamiltonian()
qrao31_hamiltonian
```




    Hamiltonian((Z0, Z1): 1.5, (Z0, Z2): 1.5, (Z0, X2): 1.5, (Z1, X2): 1.5, (Z1, Z2): 1.5, (X0, X1): 1.5, (X0, Y1): 1.5, (X0, Z3): 1.5, (Y0, X1): 1.5, (X1, Y2): 1.5, (Y2, Z3): 1.5, (Y2, X3): 1.5, (Z2, Z3): 1.5, (Y1, Z4): 1.5, (Y0, Z4): 1.5, (X3, Z4): 1.5, (Y1, X2): 1.5, (Y0, X3): 1.5)



Since we will use VQE in QRAO, we will create an VQE ansatz.
We can create a simple ansatz using `create_efficient_su2_circuit`.


```python
from qamomile.core.ansatz.efficient_su2 import create_efficient_su2_circuit
from qamomile.core.circuit.drawer import plot_quantum_circuit

ansatz = create_efficient_su2_circuit(qrao31_hamiltonian.num_qubits, rotation_blocks = ["ry", "rz"], reps = 1)
plot_quantum_circuit(ansatz)
```


    
![png](qrao_tutorial_files/qrao_tutorial_11_0.png)
    


Above qamomile Hamiltonian and circuit can be converted into Qiskit Hamiltonian and circuit using `QiskitTranspiler`


```python
qk_transpiler = qm_qk.QiskitTranspiler()
qk_ansatz = qk_transpiler.transpile_circuit(ansatz)
qk_qrao31_hamiltonian = qk_transpiler.transpile_hamiltonian(qrao31_hamiltonian)
```

You can also create QAOA Hamiltonian using `QAOAConverter`.



```python
from qamomile.core.converters.qaoa import QAOAConverter
qaoa_hamiltonian = QAOAConverter(compiled_instance, normalize_model=False).get_cost_hamiltonian()
qk_qaoa_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
```


```python
print("The compression ratio of this problem is ", qaoa_hamiltonian.num_qubits / qrao31_hamiltonian.num_qubits)
```

    The compression ratio of this problem is  2.4


# Obtain grand state of the relaxed Hamiltonian
We have created the relaxed Hamiltonian and VQE ansatz, so let us run VQE using qiskit.



```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_ansatz, qk_qrao31_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

initial_params = np.random.uniform(0, np.pi, len(qk_ansatz.parameters))

# Run QAOA optimization
result = minimize(
    cost_estimator,
    initial_params,
    method="COBYLA",
    options={"maxiter": 10000},
)
print(result)
```

     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -9.4649972737437
           x: [ 3.075e+00  1.912e+00 ... -3.416e-03  4.928e-05]
        nfev: 10000
       maxcv: 0.0


Let's also check the optimal value using diagonalization and plot them.


```python
from scipy.sparse.linalg import eigsh

qrao_eigvals = eigsh(qk_qrao31_hamiltonian.to_matrix(), k=1, which='SA', return_eigenvectors=False)
qaoa_eigvals = eigsh(qk_qaoa_hamiltonian.to_matrix(), k=1, which='SA', return_eigenvectors=False)
```


```python
plt.plot(- (np.array(cost_history) + qrao31_hamiltonian.constant), label = "VQE")
plt.hlines(-(qrao_eigvals + qrao31_hamiltonian.constant), 0, len(cost_history), linestyles="dashed", label="Optimal Quantum Relaxed Value",colors="red")
plt.hlines(-(qaoa_eigvals + qrao31_hamiltonian.constant), 0, len(cost_history), linestyles="dashed", label="Optimal Binary Solution",colors="black")
plt.xlabel("Iteration")
plt.ylabel("Objective Value")
plt.xscale("log")
plt.legend(loc="lower right")
plt.show()
```


    
![png](qrao_tutorial_files/qrao_tutorial_21_0.png)
    


This is quite similar to Fig. 2 in [1].

# Pauli Rounding

As we mentioned, the ground state of the relaxed Hamiltonian is not classical optimal solution.
We need the rounding algorithm to decode the classical solution from the quantum state.

[1] proposed two rounding algorithms, Pauli Rounding and Magic State Rounding.
In this tutorial, we use Puali Rounding to decode the classical solution.

We can get Pauli Operators list using `get_encoded_pauli_list`.
The order of the Pauli operators corresponds to the order of the corresponding encoded variables.


```python
pauli_list = qrao_converter.get_encoded_pauli_list()
print(pauli_list)
```

    [Hamiltonian((Z0,): 1.0), Hamiltonian((Z1,): 1.0), Hamiltonian((Z2,): 1.0), Hamiltonian((X2,): 1.0), Hamiltonian((X0,): 1.0), Hamiltonian((X1,): 1.0), Hamiltonian((Y1,): 1.0), Hamiltonian((Z3,): 1.0), Hamiltonian((Y0,): 1.0), Hamiltonian((Y2,): 1.0), Hamiltonian((X3,): 1.0), Hamiltonian((Z4,): 1.0)]


We can calculate the expecation value of this.


```python
qiskit_pauli_list = [qk_transpiler.transpile_hamiltonian(pauli) for pauli in pauli_list]

estimator = qk_pr.StatevectorEstimator()
job = estimator.run([(qk_ansatz, pauli, result.x) for pauli in qiskit_pauli_list])
rounded_values = [np.sign(_res.data['evs']) for _res in job.result()]
binary_values = [(1 - _val) // 2 for _val in rounded_values]
binary_values
```




    [0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0]



We can map this bianry variable result into `sampleset` using `decode_bits_to_sampleset`.


```python
bitsample = qm.BitsSample(1,binary_values)
sampleset = qrao_converter.decode_bits_to_sampleset(qm.BitsSampleSet([bitsample]))
```

Finally, we have result!
Let us visualize it.


```python
def get_edge_colors(
    graph, cut_solution, in_cut_color="r", not_in_cut_color="b"
):
    cut_set_1 = [node[0] for node, value in cut_solution.items() if value == 1.0]
    cut_set_2 = [node for node in graph.nodes() if node not in cut_set_1]

    edge_colors = []
    for u, v, _ in graph.edges(data=True):
        if (u in cut_set_1 and v in cut_set_2) or (u in cut_set_2 and v in cut_set_1):
            edge_colors.append(in_cut_color)
        else:
            edge_colors.append(not_in_cut_color)
    node_colors = ["#2696EB" if node in cut_set_1 else "#EA9b26" for node in graph.nodes()]
    return edge_colors, node_colors
```


```python
best_values = sampleset[0].var_values["x"].values
edge_colors, node_colors = get_edge_colors(graph, best_values)
edge_labels = nx.get_edge_attributes(graph, "weight")

plt.title("G=(V,E) QAOA")
plt.plot(figsize=(5, 4))
nx.draw_networkx(
    graph,
    node_size=500,
    width=3,
    with_labels=True,
    edge_color=edge_colors,
    node_color=node_colors,
)

```


    
![png](qrao_tutorial_files/qrao_tutorial_32_0.png)
    


# References
[1] Bryce Fuller, Charles Hadfield, Jennifer R. Glick, Takashi Imamichi, Toshinari Itoko, Richard J. Thompson, Yang Jiao, Marna M. Kagele, Adriana W. Blom-Schieber, Rudy Raymond, and Antonio Mezzacapo. Approximate solutions of combinatorial problems via quantum relaxations. IEEE Transactions on Quantum Engineering, 5():1–15, 2024. doi:10.1109/TQE.2024.3421294.

[2] Kosei Teramoto, Rudy Raymond, Eyuri Wakakuwa, and Hiroshi Imai. Quantum-relaxation based optimization algorithms: theoretical extensions. 2023. URL: https://arxiv.org/abs/2302.09481, arXiv:2302.09481.
# Quantum Alternating Operator Ansatz for Graph Coloring Problem with Qiskit and Quri-Parts
In this tutorial, we would like to explain the functionality while solving the Graph Coloring Problem using the Quantum Approximate Optimization Algorithm and the Quantum Alternating Operator Ansatz. This time, we are going to conduct simulations using qiskit and quri-parts.


```python
import networkx as nx
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile.core as qm
```

First, we will implement the mathematical model of the graph coloring problem using JijModeling.


```python
def graph_coloring_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    N = jm.Placeholder("N")
    x = jm.BinaryVar("x", shape=(V, N))
    n = jm.Element("i", belong_to=(0, N))
    v = jm.Element("v", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)
    # set problem
    problem = jm.Problem("Graph Coloring")
    # set one-hot constraint that each vertex has only one color

    problem += jm.Constraint("one-color", x[v, :].sum() == 1, forall=v)
    # set objective function: minimize edges whose vertices connected by edges are the same color
    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])
    return problem

problem = graph_coloring_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Coloring} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 1} \sum_{e \in E} x_{e_{0}, i} \cdot x_{e_{1}, i} & \\\text{{s.t.}} & & & \\ & \text{one-color} & \displaystyle \sum_{\ast_{1} = 0}^{N - 1} x_{v, \ast_{1}} = 1 & \forall v \in \left\{0,\ldots,V - 1\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will create an instance of the problem.


```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])
nx.draw(G)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_5_0.png)
    



```python
inst_E = [list(edge) for edge in G.edges]
color_num = 3
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "N": color_num, "E": inst_E}
num_qubits = num_nodes * color_num
```

# Quantum Approximate Optimazation Algorithm (QAOA)
The Quantum Approximate Optimization Algorithm (QAOA) is one of the quantum optimization algorithms that use a variational quantum circuit. For a detailed explanation, please refer to paper [1], but here we will only give a rough overview.
In QAOA, a variational quantum circuit is constructed by applying the Ising Hamiltonian $H_P = \sum_{ij}J_{ij}Z_iZ_j$ and the $X$-mixer Hamiltonian $H_M = \sum_iX_i$ in the following way:
If we start with an initial state $\ket{\psi_0}$, then

$$
\ket{\psi(\beta,\gamma)} = e^{-i\beta_pH_M}e^{-i\gamma_pH_P}\cdots e^{-i\beta_1H_M}e^{-i\gamma_1H_P}\ket{\psi_0}
$$

can be written. Here, $\beta_k,\gamma_k$ are the parameters to be optimized, and since the operation $e^{-\beta_kH_M}e^{-\gamma_kH_P}$ is repeated $p$ times, there are a total of $2p$ parameters. In the standard QAOA, the total number of parameters is independent of the number of qubits and depends only on the number of repetitions.

Optimization of $\beta_k,\gamma_k$ is performed by repeating the following steps 1 and 2:

1. Compute the expectation value $\bra{\psi(\beta,\gamma)}H_P\ket{\psi(\beta,\gamma)}$ on a quantum device.
2. Update the parameters on a classical computer to minimize the expectation value.

By repeating this calculation of the expectation value on the quantum computer and optimization of parameters on the classical computer, we obtain the minimum energy $\langle H_P \rangle$ and the corresponding final state. If we consider QAOA as a mathematical optimization algorithm, this minimum energy corresponds to the minimum objective function value, and the final state becomes the optimal solution.

## Implementing QAOA using Qamomile
Now, let's try solving the Graph Coloring Problem using QAOA.
To execute QAOA, it's necessary to convert the mathematical model into an Ising Hamiltonian, and then create a variational quantum circuit and Hamiltonian using a quantum computing library. However, since Qamomile supports QAOA, it allows for relatively easy execution.

First, using JijModeling-Transpiler, we create a CompiledInstance from JijModeling's mathematical model and instance data.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

Next, we create a QAOAConverter. By setting the weight for the constraints on this Converter, we can create the Hamiltonian.


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode(multipliers={"one-color": 1})
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=1)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_12_0.png)
    


## Run QAOA using Qiskit

Now that we have the variational quantum circuit and Hamiltonian ready, let's actually execute QAOA using Qiskit.  
Transpile the qamomile's circuit to the qiskit's circuit and run the simulation.


```python
from qamomile.qiskit import QiskitTranspiler
import qiskit.primitives as qk_pr

qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_cost = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
import scipy.optimize as opt

# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []
def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data['evs']
    cost_history.append(cost)
    return cost

result = opt.minimize(estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 100})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -6.646036208250357
           x: [-4.546e-01  3.550e-01]
        nfev: 46
       maxcv: 0.0




```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_16_0.png)
    


# Quantum Alternating Operator Ansatz
Next, let's try solving the graph coloring problem using the Quantum Alternating Operator Ansatz. The Quantum Alternating Operator Ansatz[2] is a modification of QAOA, where the mixer is changed from an $X$-mixer to a mixer tailored to the problem, ensuring that only solutions satisfying the constraints are searched for. For more detailed information, please refer to the original paper. Here, we will look at how to implement it in JTQ.

For the Graph Coloring problem, there is a one-hot constraint:

$$
\sum_k x_{v,k} = 1\quad \forall v
$$

However, turning this into an $XY$-mixer is the Quantum Alternating Operator Ansatz approach to the Graph Coloring problem.


```python
gamma_1 = qm.circuit.Parameter("gamma_1")
# Delete one-color penalty.
qaoa_converter.ising_encode(multipliers={"one-color": 0.0})
# Get exp(-i gamma H_P) circuit without mixer circuit.  
qaoa_cost_circuit = qaoa_converter.get_cost_ansatz(gamma_1)
```

Next, we will create an $XY$-mixer. The $XY$-mixer can be written as

$$
XY_{ij} = \frac{1}{2}\left(X_iX_j + Y_iY_j \right).
$$

This is an operator that swaps the bits 1 and 0 in bit $i,j$. Therefore, it can transform a bit string $100$, which satisfies the one-hot constraint, into another bit string $010$, which also satisfies the one-hot constraint.

Here, the only part under the one-hot constraint is related to color, so in terms of the mathematical model, we need to transform the bits between $x_{v0}$ and $x_{v1}$.
On the other hand, as these variables are usually embedded in qubits, it is necessary to remember which bit corresponds to which variable when constructing the algorithm and handle them appropriately.
In JTQ, the correspondence of variables is contained in var_map inside CompiledInstance.
```python
var_map['variable_name'][indices]
```
You can check which qubit corresponds to a variable in the mathematical model in this way.
Let's use this to create an $XY$-mixer.

What we want here is the transformation between $x_{v,k}$ and $x_{v,k+1}$, so we can obtain the index of the corresponding qubit by accessing compiled_instance.var_map.var_map["x"][(i,k)]."


```python
def create_xy_mixer(
    beta: qm.circuit.Parameter,
    num_nodes: int,
    num_color: int,
    compiled_instance: jmt.CompiledInstance,
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n, name="XY-mixer")
    var_map = compiled_instance.var_map.var_map["x"]
    # even
    for i in range(num_nodes):
        for k in range(0, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # odd
    for i in range(num_nodes):
        for k in range(1, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # ini-last
    if num_color % 2 == 1:
        for i in range(num_nodes):
            qc.rxx(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
            qc.ryy(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
    return qc
```


```python
def create_initial_state(
    compiled_instance: jmt.CompiledInstance, num_nodes: int, num_color: int
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n)
    var_map = compiled_instance.var_map.var_map["x"]
    for i in range(num_nodes):
        qc.x(var_map[(i, 0)])  # set all nodes to color 0
    return qc
```

Now that the Ansatz has been created, we would like to run the Quantum Alternating Operator Ansatz.


```python
initial_circuit = create_initial_state(compiled_instance, num_nodes, color_num)
initial_circuit.update_qubits_label(qaoa_converter.int2varlabel)
beta_1 = qm.circuit.Parameter("beta_1")
mixer_circuit = create_xy_mixer(beta_1, num_nodes, color_num, compiled_instance)
mixer_circuit.update_qubits_label(qaoa_converter.int2varlabel)
plot_quantum_circuit(mixer_circuit)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_23_0.png)
    



```python
initial_circuit.append(qaoa_cost_circuit)
initial_circuit.append(mixer_circuit)

alternating_ansatz = initial_circuit

plot_quantum_circuit(alternating_ansatz)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_24_0.png)
    


## Run Quantum Alternating Operator Ansatz using Qiskit


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(alternating_ansatz)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []

def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data["evs"]
    cost_history.append(cost)
    return cost


result = opt.minimize(
    estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 100}
)
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -7.43749997649938
           x: [ 7.855e-01 -1.425e-01]
        nfev: 31
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_28_0.png)
    



```python
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
plt.show()
job = sampler.run([(qk_circuit, result.x)])
job_result = job.result()
```


```python
sampleset = qaoa_converter.decode(qk_transpiler, job_result[0].data['meas'])
```


```python
import numpy as np
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.experimental.SampleSet):
    # extract feasible solution
    feasibles = sampleset.feasibles()
    if len(feasibles) == 0:
        print("No feasible solution found ...")
    else:
        lowest_sample = sampleset.lowest()[0]

        # get indices of x = 1
        indices = lowest_sample.var_values["x"].values.keys()
        # get vertices and colors
        # initialize vertex color list
        node_colors = [-1] * graph.number_of_nodes()
        # set color list for visualization
        colorlist = ["gold", "violet", "limegreen", "darkorange"]
        # set vertex color list
        for i, j in indices:
            node_colors[i] = colorlist[j]
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)
        plt.show()

plot_graph_coloring(G, sampleset)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_31_0.png)
    


## Alternating Ansatz with Quri-Parts


```python
# !pip install quri-parts-algo
```


```python
from qamomile.quri_parts import QuriPartsTranspiler
```


```python
from quri_parts.circuit.utils.circuit_drawer import draw_circuit

qp_transpiler = QuriPartsTranspiler()
qp_alternating_circuit = qp_transpiler.transpile_circuit(alternating_ansatz)
qp_cost = qp_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
from quri_parts.core.state import quantum_state, apply_circuit

cb_state = quantum_state(alternating_ansatz.num_qubits, bits=0)
parametric_state = apply_circuit(qp_alternating_circuit, cb_state)
```


```python
from typing import Sequence
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator

estimator = create_qulacs_vector_parametric_estimator()


cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(qp_cost, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost


result = opt.minimize(cost_fn, [0, 0], method="COBYLA", options={"maxiter": 100})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -7.437499976499405
           x: [-1.831e-03  7.855e-01]
        nfev: 35
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_38_0.png)
    



```python
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler


sampler = create_qulacs_vector_sampler()
bounded_circuit = qp_alternating_circuit.bind_parameters(result.x)
qp_result = sampler(bounded_circuit, 1000)
```


```python
sampleset = qaoa_converter.decode(qp_transpiler, (qp_result, alternating_ansatz.num_qubits))
```


```python
plot_graph_coloring(G, sampleset)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_41_0.png)
    


# References
[[1] Farhi, Edward, Jeffrey Goldstone, and Sam Gutmann. "A quantum approximate optimization algorithm." arXiv preprint arXiv:1411.4028 (2014).](https://arxiv.org/abs/1411.4028)

[[2] Hadfield, Stuart, Zhihui Wang, Bryan O’gorman, Eleanor G. Rieffel, Davide Venturelli, and Rupak Biswas. "From the quantum approximate optimization algorithm to a quantum alternating operator ansatz." Algorithms 12, no. 2 (2019): 34.](https://arxiv.org/abs/1709.03489)
# QAOA for the Vertex Cover

In this section, we will solve the Vertex Cover Problem using QAOA with the help of the `JijModeling` and `Qamomile` libraries.

First, let's install and import the main libraries we will be using.



```python
# !pip install qamomile[qiskit,quri-parts]
# !pip install pylatexenc
```


```python
import qamomile.core as qm
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
import matplotlib.pyplot as plt
```

## The Vertex Cover Problem

First, let's review the definition of the Vertex Cover Problem. In an undirected graph $G = (V, E)$, a vertex set $S \subseteq V$ is called a vertex cover if for every edge $e = (i, j) \in E$, either $i \in S$ or $j \in S$ holds. The Vertex Cover Problem is the problem of finding a vertex cover $S$ with the smallest possible number of elements.

As an example, consider the minimum vertex cover of the following graph. Let $S = \{0, 1\}$. In this case, every edge of the graph has at least one in either vertex $0$ or vertex $1$, so $S$ is a vertex cover set. Furthermore, in the graph we are considering, there is no vertex cover $S$ with only one element, so $\{0, 1\}$ is indeed the minimum vertex cover.



```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4)])
positions = nx.spring_layout(G)
color = ["#2696EB"] * 5
color[0] = color[1] = "#EA9b26"
nx.draw(G, node_color=color, pos=positions, with_labels=True)
```


    
![png](vertex_cover_files/vertex_cover_4_0.png)
    


## Formulation of the Vertex Cover Problem

Let's consider the formulation of the Vertex Cover Problem.

We define a binary variable $x_i$ such that $x_i = 1$ if vertex $i$ is included in $S$, and $x_i = 0$ otherwise. The objective function, which represents the size of $S$, can be expressed as follows.

$$
\sum_{i \in V} x_i
$$


The constraint is that all edges must be covered, meaning that for each edge, at least one of its endpoints must be included in $S$. This can be formulated as:

$$
x_{e_0} + x_{e_1} \geq 1 \quad \forall e \in E
$$


In summary, the Vertex Cover Problem can be formulated as follows:

$$
\begin{align}
&\min \sum_{i \in V} x_i \\
\text{s.t. } &x_{e_0} + x_{e_1} \geq 1 \quad \forall e \in E
\end{align}
$$

## Creating Problem Model using JijModeling

We describe the above formulation and then using JijModeling to create the problem model. `Placeholder` defines the values to be substituted as data, `BinaryVar` defines the decision variables, and `Element` defines the indices used in the summation. By checking the output, we can confirm that the formulation is correct.



```python
def vertex_cover_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    i = jm.Element("i", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)

    # set problem
    problem = jm.Problem("Vertex Cover Problem")
    # ensure that at least one vertex of each edge is included in the cover
    problem += jm.Constraint("cover", x[e[0]] + x[e[1]] >= 1, forall=e)
    # minimize the number of vertices included in the cover
    problem += jm.sum(i, x[i])

    return problem


problem = vertex_cover_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Vertex Cover Problem} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{V - 1} x_{i} & \\\text{{s.t.}} & & & \\ & \text{cover} & \displaystyle x_{e_{0}} + x_{e_{1}} \geq 1 & \forall e \in E \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



## Preparing Instance Data
Next, we will solve the Vertex Cover Problem for the following graph. The data for the specific problem being solved is referred to as instance data.



```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
G.add_edges_from(
    [
        (0, 6),
        (0, 5),
        (1, 5),
        (2, 5),
        (3, 8),
        (4, 9),
        (4, 7),
        (5, 7),
        (6, 7),
        (7, 8),
        (8, 9),
    ]
)
positions = nx.spring_layout(G)
color = ["#2696EB"] * G.number_of_nodes()
nx.draw(G, node_color=color, pos=positions, with_labels=True)
```


    
![png](vertex_cover_files/vertex_cover_11_0.png)
    



## Creating a Compiled Instance

We perform compilation using the JijModeling-Transpiler by providing the formulation and the instance data prepared earlier. This process yields an intermediate representation of the problem with the instance data substituted.



```python
inst_E = [list(edge) for edge in G.edges]
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "E": inst_E}
num_qubits = num_nodes
compiled_instance = jmt.compile_model(problem, instance_data)
```

## Converting Compiled Instance to QAOA Circuit and Hamiltonian

We generate the QAOA circuit and Hamiltonian from the compiled Instance. The converter used to generate these is `qm.qaoa.QAOAConverter`.

By creating an instance of this class and using `ising_encode`, you can internally generate the Ising Hamiltonian from the compiled Instance. Parameters that arise during the conversion to QUBO can also be set here. If not set, default values are used.

Once the Ising Hamiltonian is generated, you can generate the QAOA quantum circuit and the Hamiltonian respectively. These can be executed using the `get_qaoa_ansatz` and `get_cost_hamiltonian` methods. The number of QAOA layers, $p$, is fixed to be $4$ here.   


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
# Encode to Ising Hamiltonian
qaoa_converter.ising_encode()
# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=3)
# Get the cost Hamiltonian
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
```

## Visualization of QAOA Circuit
Qamomile provides a method to visualize the quantum circuit. You can use the `plot_quantum_circuit` function to visualize the QAOA quantum circuit.


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](vertex_cover_files/vertex_cover_17_0.png)
    


## Converting the Obtained QAOA Circuit and Hamiltonian for Qiskit

Here, we generate the Qiskit's QAOA circuit and Hamiltonian using the `qamomile.qiskit.QiskitTranspiler` converters. By utilizing the two methods,`QiskitTranspiler.transpile_circuit` and `QiskitTranspiler.transpile_hamiltonian`, we can transform the QAOA circuit and Hamiltonian into a format compatible with Qiskit. This allows us to leverage Qiskit's quantum computing framework to execute and analyze.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()
# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
# Transpile the QAOA Hamiltonian to Qiskit
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIIIIIIIZ', 'IIIIIZIIII', 'IIIIZIIIII', 'IIIZIIIIII', 'IIZIIIIIII', 'IZIIIIIIII', 'ZIIIIIIIII', 'IIIZIIIIIZ', 'IIIIZIIIIZ', 'IIIIZIIIZI', 'IIIIZIIZII', 'IZIIIIZIII', 'ZIIIIZIIII', 'IIZIIZIIII', 'IIZIZIIIII', 'IIZZIIIIII', 'IZZIIIIIII', 'ZZIIIIIIII'],
                  coeffs=[0.5+0.j, 0.5+0.j, 1.5+0.j, 0.5+0.j, 1.5+0.j, 1. +0.j, 0.5+0.j, 0.5+0.j,
     0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j,
     0.5+0.j, 0.5+0.j])



## Running QAOA

We run QAOA to optimize the parameters. Here, we use COBYLA as the optimizer.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
estimator = qk_pr.StatevectorEstimator()


# Cost estimator function
def estimate_cost(param_values):
    try:
        job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
        result = job.result()[0]
        cost = result.data["evs"]
        cost_history.append(cost)
        return cost
    except Exception as e:
        print(f"Error during cost estimation: {e}")
        return np.inf


# Initial parameters for QAOA
initial_params = [
    np.pi / 8,
    np.pi / 4,
    3 * np.pi / 8,
    np.pi / 2,
    np.pi / 2,
    3 * np.pi / 8,
]

# Run QAOA optimization with COBYLA
result = minimize(
    estimate_cost,
    initial_params,
    method="COBYLA",
    options={"maxiter": 1500},
)

print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -3.8319489423814184
           x: [ 7.111e-01  8.882e-02  1.106e+00  2.621e+00  2.031e+00
                1.371e+00]
        nfev: 321
       maxcv: 0.0


## Result Visualization

By repeating the optimization, we can observe that the energy decreases and converges.



```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](vertex_cover_files/vertex_cover_23_0.png)
    


Now, let's run the Optimized paremeter on qiskit `StatevectorSampler`.


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results

From the job counts obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.



```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.5)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()
```


    
![png](vertex_cover_files/vertex_cover_27_0.png)
    


## Plotting the Solution

From the obtained results, we select one solution that minimizes the objective function value and plot it. (The orange vertices are the vertices included in the vertex cover.)



```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):
    # extract feasible solution
    lowests = sampleset.lowest()
    if len(lowests) == 0:
        print("No feasible solution found ...")
    else:
        best_sol = lowests[0]

        # initialize vertex color list
        node_colors = ["#2696EB"] * instance_data["V"]
        # set vertex color
        for t in best_sol.var_values["x"].values.keys():
            node_colors[t[0]] = "#EA9b26"
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, pos=positions, with_labels=True)
        plt.show()


plot_graph_coloring(G, sampleset)
```


    
![png](vertex_cover_files/vertex_cover_29_0.png)
    


Indeed, we can see that a vertex cover has been obtained.
# QAOA for Graph Coloring Problem
In this tutorial, we will solve the Graph Coloring Problem using the Quantum Approximate Optimization Algorithm (QAOA).


```python
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as opt
import networkx as nx
import qiskit.primitives as qk_pr

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt

import qamomile.core as qm
from qamomile.qiskit import QiskitTranspiler
from qamomile.core.circuit.drawer import plot_quantum_circuit
```

First, we will implement the mathematical model of the graph coloring problem using JijModeling.


```python
def graph_coloring_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    N = jm.Placeholder("N")
    x = jm.BinaryVar("x", shape=(V, N))
    n = jm.Element("i", belong_to=(0, N))
    v = jm.Element("v", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)
    # set problem
    problem = jm.Problem("Graph Coloring")
    # set one-hot constraint that each vertex has only one color

    problem += jm.Constraint("one-color", x[v, :].sum() == 1, forall=v)
    # set objective function: minimize edges whose vertices connected by edges are the same color
    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])
    return problem

problem = graph_coloring_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Coloring} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 1} \sum_{e \in E} x_{e_{0}, i} \cdot x_{e_{1}, i} & \\\text{{s.t.}} & & & \\ & \text{one-color} & \displaystyle \sum_{\ast_{1} = 0}^{N - 1} x_{v, \ast_{1}} = 1 & \forall v \in \left\{0,\ldots,V - 1\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will create an instance of the problem.


```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])
nx.draw(G)
```


    
![png](graph_coloring_files/graph_coloring_5_0.png)
    



```python
inst_E = [list(edge) for edge in G.edges]
color_num = 3
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "N": color_num, "E": inst_E}
num_qubits = num_nodes * color_num
```

# Quantum Approximate Optimazation Algorithm (QAOA)
The Quantum Approximate Optimization Algorithm (QAOA) is one of the quantum optimization algorithms that use a variational quantum circuit. For a detailed explanation, please refer to paper [1], but here we will only give a rough overview.
In QAOA, a variational quantum circuit is constructed by applying the Ising Hamiltonian $H_P = \sum_{ij}J_{ij}Z_iZ_j$ and the $X$-mixer Hamiltonian $H_M = \sum_iX_i$ in the following way:
If we start with an initial state $\ket{\psi_0}$, then

$$
\ket{\psi(\beta,\gamma)} = e^{-i\beta_pH_M}e^{-i\gamma_pH_P}\cdots e^{-i\beta_1H_M}e^{-i\gamma_1H_P}\ket{\psi_0}
$$

can be written. Here, $\beta_k,\gamma_k$ are the parameters to be optimized, and since the operation $e^{-\beta_kH_M}e^{-\gamma_kH_P}$ is repeated $p$ times, there are a total of $2p$ parameters. In the standard QAOA, the total number of parameters is independent of the number of qubits and depends only on the number of repetitions.

Optimization of $\beta_k,\gamma_k$ is performed by repeating the following steps 1 and 2:

1. Compute the expectation value $\bra{\psi(\beta,\gamma)}H_P\ket{\psi(\beta,\gamma)}$ on a quantum device.
2. Update the parameters on a classical computer to minimize the expectation value.

By repeating this calculation of the expectation value on the quantum computer and optimization of parameters on the classical computer, we obtain the minimum energy $\langle H_P \rangle$ and the corresponding final state. If we consider QAOA as a mathematical optimization algorithm, this minimum energy corresponds to the minimum objective function value, and the final state becomes the optimal solution.

## Implementing QAOA using Qamomile
Now, let's try solving the Graph Coloring Problem using QAOA.
To execute QAOA, it's necessary to convert the mathematical model into an Ising Hamiltonian, and then create a variational quantum circuit and Hamiltonian using a quantum computing library. However, since Qamomile supports QAOA, it allows for relatively easy execution.

First, using JijModeling-Transpiler, we create a CompiledInstance from JijModeling's mathematical model and instance data.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

Next, we create a QAOAConverter. By setting the weight for the constraints on this Converter, we can create the Hamiltonian.


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode(multipliers={"one-color": 5})
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=1)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](graph_coloring_files/graph_coloring_12_0.png)
    


## Run QAOA using Qiskit

Now that we have the variational quantum circuit and Hamiltonian ready, let's actually execute QAOA using Qiskit.  
Transpile the qamomile's circuit to the qiskit's circuit and run the simulation.


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_cost = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []
def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data['evs']
    cost_history.append(cost)
    return cost

result = opt.minimize(estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 1000})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: 2.8539634674558334
           x: [ 4.544e-01 -3.551e-01]
        nfev: 409
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_coloring_files/graph_coloring_16_0.png)
    



```python
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
plt.show()
job = sampler.run([(qk_circuit, result.x)], shots=10000)
job_result = job.result()
```


```python
sampleset = qaoa_converter.decode(qk_transpiler, job_result[0].data['meas'])
```


```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.experimental.SampleSet):
    # extract feasible solution
    feasibles = sampleset.feasibles()
    if len(feasibles) == 0:
        print("No feasible solution found ...")
    else:
        lowest_sample = sampleset.lowest()[0]

        # get indices of x = 1
        indices = lowest_sample.var_values["x"].values.keys()
        # get vertices and colors
        # initialize vertex color list
        node_colors = [-1] * graph.number_of_nodes()
        # set color list for visualization
        colorlist = ["gold", "violet", "limegreen", "darkorange"]
        # set vertex color list
        for i, j in indices:
            node_colors[i] = colorlist[j]
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)
        plt.show()

# Visualize the graph coloring result
plot_graph_coloring(G, sampleset)
```


    
![png](graph_coloring_files/graph_coloring_19_0.png)
    

# Solving Problems with QAOA

## Tutorials

- [Quantum Approximate Optimization Algorithm for Max-Cut](maxcut.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for Max-Cut problem.
- [Quantum Approximate Optimization Algorithm for Graph Partitioning](graph_partition.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for graph partitioning problem.
- [Quantum Approximate Optimization Algorithm for vertex covering](vertex_cover.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for vertex cover problem.
- [Quantum Approximate Optimization Algorithm for Multi-car Paint Shop Problem](multi_car_paint.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for multi-car paint shop problem.
- [Quantum Approximate Optimization Algorithm for Travelling Salesman Problem](Travelling_Salesman_Problem.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for Travelling Salesman Problem.
- [Quantum Approximate Optimization Algorithm for Graph Coloring](graph_coloring.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for graph coloring problem.
# QAOA for Travelling Salesman Problem

In this tutorial, we will demonstrate how to solve a 5-city Travelling Salesman Problem (TSP) using the Quantum Approximate Optimization Algorithm (QAOA). We will utilize Quri-Parts as our simulator to implement and test the algorithm.


```python
import numpy as np
import matplotlib.pyplot as plt
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile.core as qm
```

First, we will formulate the Travelling Salesman Problem (TSP) using JijModeling. We consider a set of cities labeled from ${0, 1, \dots, N-1}$.

To reduce the number of decision variables, we slightly reformulate the problem. We fix the starting city to be city $N-1$ and focus on determining the visiting order of the remaining cities $0, 1, \dots, N-2$.

In this problem setting, our goal is to find the shortest possible route that starts and ends at city $N-1$ while visiting all other cities exactly once.

We define the variables as follows:

- $N$: The total number of cities.
- $d_{u,v}$: The distance from city $u$ to city $v$.
- $x_{u,j}$: A binary variable that equals 1 if city $u$ is visited at the $j$-th position in the tour, and 0 otherwise, where $u = 0, 1, \dots, N-2$ and $j = 0, 1, \dots, N-2$.


```python
def create_tsp_problem():
  N = jm.Placeholder("N")
  D = jm.Placeholder("d", ndim=2)
  x = jm.BinaryVar("x", shape=(N-1, N-1))
  t = jm.Element("t", belong_to=N-2)
  j = jm.Element("j", belong_to=N-1)
  u = jm.Element("u", belong_to=N-1)
  v = jm.Element("v", belong_to=N-1)

  problem = jm.Problem("TSP")

  problem += jm.Constraint("Visit all cities at least once", jm.sum(j ,x[u,j]) == 1, forall=u)
  problem += jm.Constraint("Visit one city at each time", jm.sum(u, x[u,j]) == 1, forall=j)

  problem += jm.sum(u,  D[N-1][u]*(x[u][0] + x[u][N-2])) + jm.sum(t,jm.sum(u, jm.sum(v, D[u][v]*x[u][t]*x[v][t+1])))
  return problem

problem = create_tsp_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{TSP} & & \\& & \min \quad \displaystyle \sum_{u = 0}^{N - 2} d_{N - 1, u} \cdot \left(x_{u, 0} + x_{u, N - 2}\right) + \sum_{t = 0}^{N - 3} \sum_{u = 0}^{N - 2} \sum_{v = 0}^{N - 2} d_{u, v} \cdot x_{u, t} \cdot x_{v, t + 1} & \\\text{{s.t.}} & & & \\ & \text{Visit all cities at least once} & \displaystyle \sum_{j = 0}^{N - 2} x_{u, j} = 1 & \forall u \in \left\{0,\ldots,N - 2\right\} \\ & \text{Visit one city at each time} & \displaystyle \sum_{u = 0}^{N - 2} x_{u, j} = 1 & \forall j \in \left\{0,\ldots,N - 2\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will prepare the instance data for our TSP problem. This involves defining the distances between each pair of cities, which are essential for formulating the cost function and constraints in our model.


```python
N = 5
np.random.seed(3)

num_qubits = (N - 1)**2

x_pos = np.random.rand(N)
y_pos = np.random.rand(N)

plt.scatter(x_pos, y_pos, c='red', s=100, edgecolors='k', zorder=3)
plt.title(f"City", fontsize=15)
plt.xlabel("X Position", fontsize=15)
plt.ylabel("Y Position", fontsize=15)
plt.xlim(0, 1)
plt.ylim(0, 1)
plt.grid(True, linestyle='--', alpha=0.7)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_5_0.png)
    



```python
d = [[0]*N for _ in range(N)]
for i in range(N):
  for j in range(N):
    d[i][j] = np.sqrt((x_pos[i] - x_pos[j])**2 + (y_pos[i] - y_pos[j])**2)

instance_data = {"N": N, "d": d}

num_qubits = (N - 1)**2
```

# Quantum Approximate Optimization Algorithm (QAOA)
We will solve the TSP using the standard Quantum Approximate Optimization Algorithm (QAOA). An overview of QAOA is provided in another tutorial [1], so please refer to that for more details.

First, we will use the JijModeling-Transpiler to generate an model as intermediate representation from our formulated TSP problem and the instance data.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

Next, we will utilize the `QAOAConverter`. We set the weights for the constraint terms and generate the QAOA circuit and Hamiltonian. In this tutorial, we use $p=2$. However, since the performance of QAOA and the Quantum Alternating Operator Ansatz can vary significantly depending on the value of $p$, interested readers are encouraged to try larger values of $p$ (note that computation time will increase).


```python
p = 4
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode(multipliers={"Visit all cities at least once": 42, "Visit one city at each time": 42})
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_11_0.png)
    


# Executing with Quri-Parts
Next, we will convert the circuit and Hamiltonian generated by Qamomile into objects compatible with Quri-Parts. This will enable us to run the quantum algorithm using Quri-Parts as our simulation framework.


```python
from qamomile.quri_parts import QuriPartsTranspiler

qp_transpiler = QuriPartsTranspiler()
qp_circuit = qp_transpiler.transpile_circuit(qaoa_circuit)
qp_cost = qp_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
from quri_parts.core.state import quantum_state, apply_circuit

cb_state = quantum_state(qaoa_circuit.num_qubits, bits=0)
parametric_state = apply_circuit(qp_circuit, cb_state)
```


```python
from typing import Sequence
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator
from scipy import optimize as opt

estimator = create_qulacs_vector_parametric_estimator()

cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(qp_cost, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost

def create_initial_param(p: int) -> list[float]:
    res = []
    # beta
    for i in range(p):
        res.append(np.pi/(2 * (p - i)))
    # gamma
    for i in range(p):
        res.append(np.pi/(2 * (i + 1)))
    return res


param_result = opt.minimize(cost_fn,create_initial_param(p), method="COBYLA", options={"maxiter": 1000})
param_result
```




     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -16.533742755961427
           x: [ 2.202e-01  6.861e-01  4.927e-01  1.213e+00  2.635e+00
                1.836e-01  1.769e-01 -9.130e-02]
        nfev: 1000
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, 120)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_16_0.png)
    



```python
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
bounded_circuit = qp_circuit.bind_parameters(param_result.x)
qp_result = sampler(bounded_circuit, 10000)
```

Finally, we convert the sampled results back into solutions for the original Travelling Salesman Problem.


```python
sampleset = qaoa_converter.decode(qp_transpiler, (qp_result, qaoa_circuit.num_qubits))
```

# Visualizing the Sampled Results
Finally, we display the sampled results using graphs to visualize the solutions obtained from the algorithm. Please note that in some cases, a feasible solution may not be achieved.


```python
from collections import defaultdict
def show_energy_histogram(sampleset):
    # Create a defaultdict to store the frequency of each energy level
    d = defaultdict(int)
    for sample in sampleset.feasibles():
        d[sample.eval.objective] += sample.num_occurrences

    # Extract energy levels and their corresponding frequencies
    energies = list(d.keys())
    num_occurrences = list(d.values())
    
    # Calculate the total number of shots
    shots = 0
    for sample in sampleset.data:
        shots += sample.num_occurrences

    # Sort energies and corresponding occurrences to ensure proper order
    sorted_pairs = sorted(zip(energies, num_occurrences))
    energies, num_occurrences = zip(*sorted_pairs)
    # Plot the histogram with equally spaced bars
    plt.bar(range(len(energies)), num_occurrences, width=0.15, align='center')
    plt.title("Objective Histogram (Number of feasible samples = {0}, shots = {1})".format(sum(num_occurrences), shots), fontsize=15)
    plt.ylabel("Frequency", fontsize=15)
    plt.xlabel("Objective", fontsize=15)
    plt.xticks(range(len(energies)), np.round(energies,3), rotation=45) 
    plt.show()
    
show_energy_histogram(sampleset)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_21_0.png)
    


We got the optimal solution from the sampleset and display the corresponding route.


```python
def plot_tsp(sampleset, x_pos, y_pos, N):
    feasible_samples = sampleset.feasibles()
    
    if len(feasible_samples) == 0:
        print("No feasible solution")
    else:
        # Extract the best feasible sample
        best_sample = feasible_samples.lowest()[0]
        d = best_sample.var_values["x"].values
        
        # Determine the route
        route = [N - 1] * (N + 1)
        for key in d.keys():
            route[key[1] + 1] = key[0]
        
        # Calculate the total distance and plot the route
        total_distance = 0
        plt.figure(figsize=(10, 6))
        
        for i in range(len(route) - 1):
            x_coords = [x_pos[route[i]], x_pos[route[i + 1]]]
            y_coords = [y_pos[route[i]], y_pos[route[i + 1]]]
            plt.plot(x_coords, y_coords, 'b-', linewidth=2)
            total_distance += np.sqrt((x_coords[0] - x_coords[1]) ** 2 + (y_coords[0] - y_coords[1]) ** 2)
        
        # Plot the nodes
        plt.scatter(x_pos, y_pos, c='red', s=100, edgecolors='k', zorder=3)
        
        # Set plot properties
        plt.title(f"Total Distance = {total_distance:.2f}", fontsize=15)
        plt.xlabel("X Position", fontsize=15)
        plt.ylabel("Y Position", fontsize=15)
        plt.xlim(0, 1)
        plt.ylim(0, 1)
        plt.grid(True, linestyle='--', alpha=0.7)
        
        # Show the plot
        plt.show()
        
plot_tsp(sampleset, x_pos, y_pos, N)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_23_0.png)
    



```python

```
## QAOA for the Max-Cut
In this section, we will solve the Maxcut Problem using QAOA with the help of the `JijModeling` and `Qamomile` libraries.

First, let's install and import the main libraries we will be using.


```python
# !pip install qamomile[qiskit, quri_parts]
```


```python
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import matplotlib.pyplot as plt
import numpy as np
from typing import List, Tuple
```

## What is the Max-Cut Problem

The Max-Cut problem is the problem of dividing the nodes of a graph into two groups such that the **number of edges cut (or the total weight of the edges cut, if the edges have weights)** is maximized. Applications include network partitioning and image processing (segmentation), among others.



```python
import networkx as nx
import matplotlib.pyplot as plt

G = nx.Graph()
num_nodes = 5
edges = [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]
G.add_nodes_from(range(num_nodes))
G.add_edges_from(edges)
pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}

cut_solution = {(1,): 1.0, (2,): 1.0, (4,): 1.0}
edge_colors = []


def get_edge_colors(
    graph, cut_solution, in_cut_color="r", not_in_cut_color="b"
) -> Tuple[List[str], List[str]]:
    cut_set_1 = [node[0] for node, value in cut_solution.items() if value == 1.0]
    cut_set_2 = [node for node in graph.nodes() if node not in cut_set_1]

    edge_colors = []
    for u, v, _ in graph.edges(data=True):
        if (u in cut_set_1 and v in cut_set_2) or (u in cut_set_2 and v in cut_set_1):
            edge_colors.append(in_cut_color)
        else:
            edge_colors.append(not_in_cut_color)
    node_colors = ["#2696EB" if node in cut_set_1 else "#EA9b26" for node in G.nodes()]
    return edge_colors, node_colors


edge_colors, node_colors = get_edge_colors(G, cut_solution)
fig, axes = plt.subplots(1, 2, figsize=(10, 4))

axes[0].set_title("Original Graph G=(V,E)")
nx.draw_networkx(G, pos, ax=axes[0], node_size=500, width=3, with_labels=True)
axes[1].set_title("MaxCut Solution Visualization")
nx.draw_networkx(
    G,
    pos,
    ax=axes[1],
    node_size=500,
    width=3,
    with_labels=True,
    edge_color=edge_colors,
    node_color=node_colors,
)

plt.tight_layout()
plt.show()
```


    
![png](maxcut_files/maxcut_4_0.png)
    


## Constructing the Mathematical Model

The Max-Cut problem can be formulated with the following equation:

$$
  \max \quad \frac{1}{2} \sum_{(i,j) \in E} (1 - s_i s_j)  
$$

Note that this equation is expressed using Ising variables $ s \in \{ +1, -1 \} $. In this case, we want to formulate it using the binary variables $ x \in \{ 0, 1 \} $ from JijModeling. Therefore, we perform the conversion between Ising variables and binary variables using the following equations:

$$
    x_i = \frac{1 + s_i}{2} \quad \Rightarrow \quad s_i = 2x_i - 1
$$



```python
def Maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem


problem = Maxcut_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Maxcut} & & \\& & \max \quad \displaystyle 0.5 \cdot \sum_{e \in E} \left(- s_{e[0]} \cdot s_{e[1]} + 1\right) & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



## Preparing Instance Data

Next, we will solve the Max-Cut Problem for the following graph. The data for the specific problem being solved is referred to as instance data.


```python
import networkx as nx
import numpy as np
from IPython.display import display, Latex

G = nx.Graph()
num_nodes = 5
edges = [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]
G.add_nodes_from(range(num_nodes))
G.add_edges_from(edges)

weight_matrix = nx.to_numpy_array(G, nodelist=list(range(num_nodes)))

plt.title("G=(V,E)")
plt.plot(figsize=(5, 4))

nx.draw_networkx(G, pos, node_size=500)
```


    
![png](maxcut_files/maxcut_8_0.png)
    



```python
V = num_nodes
E = edges

data = {"V": V, "E": E}

data
```




    {'V': 5, 'E': [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]}



## Creating a Compiled Instance
We perform compilation using the JijModeling-Transpiler by providing the formulation and the instance data prepared earlier. This process yields an intermediate representation of the problem with the instance data substituted.


```python
compiled_model = jmt.compile_model(problem, data)
```

## Converting Compiled Instance to QAOA Circuit and Hamiltonian
We generate the QAOA circuit and Hamiltonian from the compiled Instance. The converter used to generate these is `qm.qaoa.QAOAConverter`.

By creating an instance of this class and using `ising_encode`, you can internally generate the Ising Hamiltonian from the compiled Instance. Parameters that arise during the conversion to QUBO can also be set here. If not set, default values are used.

Once the Ising Hamiltonian is generated, you can generate the QAOA quantum circuit and the Hamiltonian respectively. These can be executed using the `get_qaoa_ansatz` and `get_cost_hamiltonian` methods. The number of QAOA layers, $p$, is fixed to be $7$ here.  


```python
import qamomile.core as qm

qaoa_converter = qm.qaoa.QAOAConverter(compiled_model)

qaoa_converter.ising_encode()

qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()

p = 5

qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```

## Visualization of QAOA Circuit
Qamomile provides a method to visualize the quantum circuit. You can use the plot_quantum_circuit function to visualize the QAOA quantum circuit.


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](maxcut_files/maxcut_15_0.png)
    


## Converting the Obtained QAOA Circuit and Hamiltonian for Qiskit
Here, we generate the Qiskit’s QAOA circuit and Hamiltonian using the `qamomile.qiskit.QiskitTranspiler` converters. By utilizing the two methods,`QiskitTranspiler.transpile_circuit` and `QiskitTranspiler.transpile_hamiltonian`, we can transform the QAOA circuit and Hamiltonian into a format compatible with Qiskit. This allows us to leverage Qiskit’s quantum computing framework to execute and analyze.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()

# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)

# Transpile the QAOA Hamitltonian to Qiskit
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIZZ', 'IIZIZ', 'IZIZI', 'ZIIZI', 'ZZIII', 'ZIZII'],
                  coeffs=[0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j])



## Running QAOA
We run QAOA to optimize the parameters. Here, we use COBYLA as the optimizer.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
# Cost estimator function
estimator = qk_pr.StatevectorEstimator()


def estimate_cost(param_values):
    try:
        job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
        result = job.result()[0]
        cost = result.data["evs"]
        cost_history.append(cost)
        return cost
    except Exception as e:
        print(f"Error during cost estimation: {e}")
        return np.inf


# Create initial parameters
initial_params = np.random.uniform(low=-np.pi / 4, high=np.pi / 4, size=2 * p)

# Run QAOA optimization
result = minimize(
    estimate_cost,
    initial_params,
    method="COBYLA",
    options={"maxiter": 2000, "tol": 1e-2},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -1.8395124880637668
           x: [-9.771e-02 -1.080e+00 -3.948e-01  1.184e+00 -1.948e-01
               -2.640e-01  5.865e-02  4.768e-01  9.115e-01  1.014e+00]
        nfev: 176
       maxcv: 0.0


## Result Visualization
By repeating the optimization, we can observe that the energy decreases and converges.


```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](maxcut_files/maxcut_21_0.png)
    


Now, let's run the Optimized paremeter on qiskit `StatevectorSampler`.


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=10000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results
From the job counts obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])
plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](maxcut_files/maxcut_25_0.png)
    



```python
target_energy = max(list(plot_data.keys()))
target_samples = [
    sample for sample in sampleset.feasibles() if sample.eval.objective == target_energy
]

for sample in target_samples:
    print(f"Energy: {sample.eval.objective}")
    print(f"Occurrences: {sample.num_occurrences}")
    print(f"Solution: {sample.var_values['x'].values}")

best_sample = target_samples[0]
best_sample.var_values["x"].values
```

    Energy: 5.0
    Occurrences: 2178
    Solution: {(1,): 1.0, (2,): 1.0, (4,): 1.0}
    Energy: 5.0
    Occurrences: 2173
    Solution: {(4,): 1.0, (1,): 1.0}
    Energy: 5.0
    Occurrences: 2107
    Solution: {(0,): 1.0, (3,): 1.0}
    Energy: 5.0
    Occurrences: 2132
    Solution: {(0,): 1.0, (2,): 1.0, (3,): 1.0}





    {(1,): 1.0, (2,): 1.0, (4,): 1.0}



## Plotting the Solution
From the obtained results, we select one solution that minimizes the objective function value and plot it. (The red are the edges been cutted in Max-Cut.)


```python
best_values = best_sample.var_values["x"].values
edge_colors, node_colors = get_edge_colors(G, best_values)

plt.title("G=(V,E) QAOA")
plt.plot(figsize=(5, 4))
nx.draw_networkx(
    G,
    pos,
    node_size=500,
    width=3,
    with_labels=True,
    edge_color=edge_colors,
    node_color=node_colors,
)
```


    
![png](maxcut_files/maxcut_28_0.png)
    

# QAOA for Two-Color Multi Car Paint Shop Problem
The goal of [the multi-car paint shop problem](https://arxiv.org/pdf/2109.07876) is to reduce the number of color switches between cars in a paint shop line during the manufacturing process, which is recognized as an NP-hard problem.

Let's consider two-color scenario in this tutorial. 

## Expressing the problem using a mathematical model

Given a set of cars $ X = \{x_1, x_2, \dots, x_n\} $ that need to be painted in one of two colors, denoted as $ x_i=0 $ and $ x_i=1 $,  for each $ i = 1, \dots n$. The objective is to minimize the number of color switches (i.e., changes from $ 0 $ to $ 1 $ or from $ 1 $ to $ 0 $) between consecutive cars in the sequence.


The cost of the sequence is the number of times the color switches between consecutive cars, which can be formulated as:

$$
\text{min} \quad - \sum_{i=0}^{N-2} s_i s_{i+1}.
$$

The term, $-s_i \cdot s_{i+1}$, represents consecutive cars and indicates whether they are going to be painted the same color, either $-1$ or $1$. This term becomes $-1$ when the cars are painted the same color, and $+1$ when they are painted different colors. Summing over all the cars in $X$, the cost function is minimized. By converting the spin variables to binary variables, the mathematical expression transforms into the following: 

$$
\text{min} \quad -\sum_{i=0}^{N-2} (x_i - 0.5) \cdot (x_{i+1} - 0.5).
$$

In the Two-Color Multi-Car Paint Shop Problem, the goal is to minimize the number of color switches while meeting specific constraints. In this notebook, we consider the constraint that the scheduled number of cars in each of the two colors per model (the total number of models is $M$) must be met.

$$
 V_{i,m} \cdot x_i = W_m \quad ,\forall m \in \{0, \dots, M-1\}
$$

, where $V_{i,m}$ is a one-hot 2-dimensional matrix representing which model each car $i$ belongs to.


```python
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile as qm
import numpy as np
import random as rand
```

## Formulation using JijModeling
Let's first model the problem using JijModeling.


```python
def get_mcps_problem() -> jm.Problem:
  V = jm.Placeholder("V", ndim=2) # sequence of car entry
  W = jm.Placeholder("W", ndim=1) # number of black cars by model
  N = jm.Placeholder("N") # number of cars
  M = jm.Placeholder("M") # number of car models
  x = jm.BinaryVar("x", shape=(N,))
  i = jm.Element("i", belong_to=(0, N-1))
  j = jm.Element("j", belong_to=(0, N))
  m = jm.Element("m", belong_to=(0, M))

  problem = jm.Problem("MCPS") 
  problem += jm.sum([i], -(x[i] - 0.5) * (x[i+1] - 0.5))
  problem += jm.Constraint("n-hot", jm.sum([j], V[j][m] * x[j]) == W[m], forall=m)
  return problem
problem = get_mcps_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{MCPS} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 2} - \left(x_{i} - 0.5\right) \cdot \left(x_{i + 1} - 0.5\right) & \\\text{{s.t.}} & & & \\ & \text{n-hot} & \displaystyle \sum_{j = 0}^{N - 1} V_{j, m} \cdot x_{j} = W_{m} & \forall m \in \left\{0,\ldots,M - 1\right\} \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$




```python
car_map = {
    0: "🚗",  # Red car
    1: "🚕",  # Taxi
    2: "🚙",  # SUV
    3: "🚓"   # Police car
}

number_of_models = 4 
number_of_cars = 8
# number of black cars by model
black_per_models = [1, 1, 1, 1]

# Create 8 cars in 4 different kinds of models
cars = [0, 0, 1, 1, 2, 2, 3, 3] 
rand.shuffle(cars)
print(f"The order of car intake: {[car_map[car] for car in cars]}") 

#Create a 2d array of the sequence of car entry
cars_onehot = np.eye(number_of_models)[cars]
print([car_map[i] for i in range(4)])
print(cars_onehot)
```

    The order of car intake: ['🚕', '🚕', '🚙', '🚓', '🚙', '🚓', '🚗', '🚗']
    ['🚗', '🚕', '🚙', '🚓']
    [[0. 1. 0. 0.]
     [0. 1. 0. 0.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]
     [1. 0. 0. 0.]
     [1. 0. 0. 0.]]


## Creating a Compiled Instance
A compiled instance is an intermediate representation where actual values are substituted into the constants of the mathematical expressions. Before converting to various algorithms, it is necessary to first create this compiled instance.


```python
data = {"V": cars_onehot, "W":  black_per_models, "N":  number_of_cars, "M": number_of_models}
compiled_model = jmt.compile_model(problem, data)
```

## Generation of QAOA Circuit and Hamiltonian Using Qamomile
Qamomile provides a converter that generates circuits and Hamiltonians for QAOA from the compiled instance. Additionally, it allows setting parameters that arise during the conversion to QUBO.

First, we will generate the Ising Hamiltonian. Once this is done, we can also generate the quantum circuit and Hamiltonian for QAOA. 


```python
from qamomile.core.converters.qaoa import QAOAConverter
from qamomile.core.circuit.drawer import plot_quantum_circuit

qaoa_converter = QAOAConverter(compiled_model)
# Encode to Ising Hamiltonian
qaoa_converter.ising_encode(multipliers={"n-hot": 3})
# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=1)
plot_quantum_circuit(qaoa_circuit) #print it out
# Get the cost Hamiltonian
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


    
![png](multi_car_paint_files/multi_car_paint_9_0.png)
    


## Converting the Obtained Circuit and Hamiltonian for Qiskit
let's first convert the circuit and Hamiltonian for Qiskit.


```python
import qamomile.qiskit as qm_qk
qk_transpiler = qm_qk.QiskitTranspiler()

# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```

## Running QAOA
Now that everything is ready, let's run QAOA. Here, we are using Scipy's COBYLA as the optimization algorithm.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

# Run QAOA optimization
result = minimize(
    cost_estimator,
    np.random.rand(2) * np.pi,
    method="COBYLA",
    options={"maxiter": 100},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -1.0355860005356643
           x: [ 2.787e+00  1.013e+00]
        nfev: 80
       maxcv: 0.0


Let's also take a look at the changes in the cost function


```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](multi_car_paint_files/multi_car_paint_15_0.png)
    


Now we have obtained the QAOA parameters. Let's use them for sampling


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results

One can determine the optimal solution for the painting order.


```python
paint_map = {
    1: "⚫",  # Black heart 
    0: ""    # Empty string
}

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])
max_energy = -1e9
best_values = None
for sample in sampleset.feasibles():
    if max_energy < sample.eval.objective:
        max_energy = sample.eval.objective
        best_values = sample.var_values

best_values = sampleset.lowest()[0].var_values

values = [0] * 8
for idx in best_values["x"].values:
  values[idx[0]] = 1

print("The order of car intake: ", [car_map[car] for car in cars])
print("Color separation: ", [paint_map[value] for value in values])
```

    The order of car intake:  ['🚕', '🚕', '🚙', '🚓', '🚙', '🚓', '🚗', '🚗']
    Color separation:  ['', '⚫', '⚫', '⚫', '', '', '', '⚫']



```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.25)
plt.xticks(sorted(np.array(list(frequencies.keys()))))
plt.xlabel('Objective', fontsize=15)
plt.ylabel('Frequency', fontsize=15)
plt.show()
```


    
![png](multi_car_paint_files/multi_car_paint_21_0.png)
    


## Evaluation using classical algorithms
Comparing the best costs by brute force search.


```python
def eval_mcps_state(cars, black_per_models, state, num_cars, num_models):
  cnt = [0] * num_models
  for i in range(num_cars):
    cnt[cars[i]] += state[i]
  for i in range(num_models):
    if black_per_models[i] != cnt[i]:
      return None
  score = 0
  for i in range(num_cars-1):
    if state[i] != state[i+1]:
      score += 1
  return score

def best_cost_mcps(cars, black_per_models, num_cars, num_models):
  best_score = 1e9
  for i in range(2**num_cars):
    state = [0] * num_cars
    for j in range(num_cars):
      if i & (2**j) != 0:
        state[j] = 1
    score = eval_mcps_state(cars, black_per_models, state, num_cars, num_models)
    if not(score is None):
      best_score = min(best_score, score)
  return best_score

exact_score = best_cost_mcps(cars, black_per_models, number_of_cars, number_of_models)
qaoa_score = eval_mcps_state(cars, black_per_models, values, number_of_cars, number_of_models)
print("exact solution: ", exact_score)
print("solution using QAOA: ", qaoa_score)
```

    exact solution:  3
    solution using QAOA:  3



```python

```
# QAOA for the Graph Partitioning with Qiskit and Quri-Parts
## What is the graph partitioning problem?

The graph partitioning problem is the problem of dividing a graph 
𝐺 with 𝑉 vertices into two parts in such a way that the number of edges cut is minimized. For example, consider a graph with 6 vertices like the following.

![init_graph](graph_partition_fig/graph_init.png)

If we divide this into halves with 3 vertices each, it would be divided as follows,

![colored_graph](graph_partition_fig/graph_colored.png)

and one can see that the number of edges cut is minimized (in this case, two). 

It is known that finding this solution is NP-hard.

## Expressing the graph partitioning problem using a mathematical model

Suppose there is graph $G=(V,E)$, where $V$ is the set of vertices and $E$ is the set of edges. We consider dividing this into two sets, $V_1$ and $V_2$. To formulate the problem, a variable $x_u$ is introduced. This variable is equal to 1 if vertex $x_u$ belongs to $V_1$, and 0 if it belongs to in $V_2$.

In this case, the objective function to be minimized can be expressed as follows.

$$
\mathrm{min}\sum_{(uv)\in E} (\{x_u(1-x_v) + x_v(1-x_u)\})
$$

Here, the term $x_u(1-x_v)$ represents an edge connecting $V_1$ and $V_2$. For example, if $x_u$ belongs to $V_1$, it is 1, and if $x_v$ belongs to $V_2$, it is 0. In such a case, the edge specified by $u$ and $v$ connects $V_1$ and $V_2$, and $x_u(1-x_v)$ becomes 1.

The term $x_v(1-x_u)$ is similar. If we sum this over the edges in $G$, $\sum_{(uv)\in E}$, we can represent the number of edges connecting $V_1$ and $V_2$.

Moreover, the constraint that the vertices of $G$ are evenly divided between $V_1$ and $V_2$ can be written as the following equation.

$$
\sum_{u\in V}x_u=V/2
$$

Let’s formulate the problem as described above using JijModeling, convert it into various quantum algorithms using Qamomile, and solve it.

## Importing Packages


```python
import qamomile.core as qm
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
import matplotlib.pyplot as plt
import random
```

## Formulation using JijModeling
Now that everything is ready, let's first model the problem using JijModeling.


```python
#Formulating the problem
problem = jm.Problem('Graph Partitioning')

#Defining Variables
V = jm.Placeholder('V')
E = jm.Placeholder('E', ndim=2)
x = jm.BinaryVar('x', shape=(V,))
u = jm.Element('u', belong_to=V)
e = jm.Element('e', belong_to=E)

#Formulating the constraint
const = jm.sum(u, x[u])
problem += jm.Constraint('constraint', const==V/2)

#Formulating the objective function
A_1 = x[e[0]]*(1-x[e[1]])
A_2 = (1-x[e[0]])*x[e[1]]
problem += jm.sum(e, (A_1 + A_2))
```

This completes the modeling. Let's display the created model.


```python
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Partitioning} & & \\& & \min \quad \displaystyle \sum_{e \in E} \left(x_{e_{0}} \cdot \left(- x_{e_{1}} + 1\right) + \left(- x_{e_{0}} + 1\right) \cdot x_{e_{1}}\right) & \\\text{{s.t.}} & & & \\ & \text{constraint} & \displaystyle \sum_{u = 0}^{V - 1} x_{u} = V \cdot 2^{(-1)} &  \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



## Preparing the problem
We will now prepare the problem to be solved. Here, we will create it using a random graph


```python
#Parameters
#Number of vertices
num_nodes = 8  
#Edge addition probability
edge_probability = 0.5  

#Creating a random graph
def generate_random_graph(num_nodes, edge_probability):
    G = nx.Graph()
    # Add nodes
    for i in range(num_nodes):
        G.add_node(i)

    # Add edges randomly
    for i in range(num_nodes):
        for j in range(i + 1, num_nodes):
            if random.random() < edge_probability:
                G.add_edge(i, j)

    return G

G = generate_random_graph(num_nodes, edge_probability)

#Visualization of the created random graph
def plot_graph(G):
    pos = nx.spring_layout(G, seed=1)
    plt.figure(figsize=(5,5))
    nx.draw(G, pos, with_labels=True, node_color='white', node_size=700,
           edgecolors='black')
    plt.show()

plot_graph(G)
```


    
![png](graph_partition_files/graph_partition_9_0.png)
    


We will prepare the problem data in a format that can be used with the model created in JijModeling


```python
inst_E = [list(edge) for edge in G.edges]
instance_data = {"V": num_nodes,"E": inst_E}
num_qubits = num_nodes
```

## Creating a Compiled Instance

A compiled instance is an intermediate representation where actual values are substituted into the constants of the mathematical expressions. Before converting to various algorithms, it is necessary to first create this compiled instance.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

## Generation of QAOA Circuit and Hamiltonian Using Qamomile
Qamomile provides a converter that generates circuits and Hamiltonians for QAOA from the compiled instance. Additionally, it allows setting parameters that arise during the conversion to QUBO.

First, we will generate the Ising Hamiltonian. Once this is done, we can also generate the quantum circuit and Hamiltonian for QAOA.









```python
from qamomile.core.circuit.drawer import plot_quantum_circuit
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)

# Encode to Ising Hamiltonian
qaoa_converter.ising_encode()

# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=3) #p is the number of layers 
plot_quantum_circuit(qaoa_circuit) #print it out
# Get the cost Hamiltonian
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
```


    
![png](graph_partition_files/graph_partition_15_0.png)
    


## Converting the Obtained Circuit and Hamiltonian for Qiskit
Qamomile has its own representation of quantum circuits and Hamiltonians to support multiple quantum algorithms. These representations need to be converted for use in the desired quantum libraries.

As of the time of writing this document (December 4, 2024), Qamomile supports:
- Qiskit
- Quri-Parts
- Qutip

As an example, let's first convert the circuit and Hamiltonian for Qiskit. To do this, we will first create an instance of __QiskitTranspiler__. Using the methods __transpile_circuit__ and __transpile_hamiltonian__ from this class, we can generate the quantum circuit and Hamiltonian.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()

# Creating the circuit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)

#Creating the Hamiltonian
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIZIIIZ', 'IIZIIIIZ', 'ZIIIIIIZ', 'IZIIIIIZ', 'ZIIZIIII', 'ZIIIIIZI', 'IIIIZIZI', 'IZIIIIZI', 'ZIZIIIII', 'IIIIZZII', 'IZIIIZII'],
                  coeffs=[0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j,
     0.5+0.j, 0.5+0.j, 0.5+0.j])



## Running QAOA
Now that everything is ready, let's run QAOA. Here, we are using Scipy's COBYLA as the optimization algorithm.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

initial_params = [np.pi / 4, np.pi / 2, np.pi / 2, np.pi / 4,np.pi / 4, np.pi / 2]

# Run QAOA optimization
result = minimize(
    cost_estimator,
    initial_params,
    method="COBYLA",
    options={"maxiter": 1000},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -2.8038438541136963
           x: [ 1.027e+00  2.833e+00  1.673e+00  5.214e-01  8.489e-01
                2.062e+00]
        nfev: 766
       maxcv: 0.0


Let's also take a look at the changes in the cost function


```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_partition_files/graph_partition_21_0.png)
    


Now we have obtained the QAOA parameters. Let's use them for sampling


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results
To evaluate the solution, it is convenient to use the sample_set. It calculates the objective function value, constraint violations, and more from the obtained solution.


```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.5)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()
```


    
![png](graph_partition_files/graph_partition_25_0.png)
    


The value of the objective function represents the number of edges connecting $V_1$ and $V_2$, so the pattern with the smallest value can be considered the solution. Let's plot the obtained results on a graph.



```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):
    # extract feasible solution
    lowests = sampleset.lowest()
    
    if len(lowests) == 0:
        print("No feasible solution found ...")
    else:
        best_sol = lowests[0]
        pos = nx.spring_layout(graph,seed=1)

        color_map = []
        for node in graph.nodes:
            if (node,) in best_sol.var_values["x"].values.keys():
                color_value = best_sol.var_values["x"].values[(node,)]
                color_map.append(color_value)
            else:
                color_map.append(0)  # Default color if not in the solution

        # Draw the graph with the color mapping
        nx.draw_networkx(graph, pos, with_labels=True,
                         node_color=color_map, cmap=plt.get_cmap('rainbow'))

plot_graph_coloring(G, sampleset)
```


    
![png](graph_partition_files/graph_partition_27_0.png)
    


## Conversion to Quri-Parts using Qamomile
Next, let's perform the conversion for Quri-Parts. First, we will import the necessary libraries


```python
from qamomile.quri_parts import QuriPartsTranspiler
```

We will perform the conversion in the same way as with Qiskit


```python
quri_transpiler = QuriPartsTranspiler()
quri_circuit = quri_transpiler.transpile_circuit(qaoa_circuit)
quri_hamiltonian = quri_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
```

We will set the parameters and perform optimization


```python
from quri_parts.core.state import quantum_state, apply_circuit

cb_state = quantum_state(quri_circuit.qubit_count, bits=0)
parametric_state = apply_circuit(quri_circuit, cb_state)
```

Quri-Parts with Qulacs is a quantum circuit simulator that operates faster than Qiskit. Taking advantage of this superior speed, let's increase the number of iterations in our experiment. By doing so, we can potentially improve our results even further and explore the capabilities of Quri-Parts more deeply. Let's modify our code to run more iterations and see how this affects our sampling results and the frequency of obtaining the lowest objective value.


```python
from typing import Sequence
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator

estimator = create_qulacs_vector_parametric_estimator()

cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(quri_hamiltonian, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost

result = minimize(cost_fn, initial_params, method="COBYLA", options={"maxiter": 20000})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -3.032268864311802
           x: [ 3.733e-01  1.044e+00  1.061e+00  4.109e-01 -2.714e-01
                2.404e+00]
        nfev: 3984
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.xscale("log")
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_partition_files/graph_partition_36_0.png)
    


If the cost function appears to have sufficiently decreased, we will use the obtained parameters to sample the solution


```python
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
bounded_circuit = quri_circuit.bind_parameters(result.x)
qp_result = sampler(bounded_circuit, 1000)
```

Let's visualize the sampling results


```python
sampleset = qaoa_converter.decode(quri_transpiler, (qp_result, quri_circuit.qubit_count))

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.5)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()
```


    
![png](graph_partition_files/graph_partition_40_0.png)
    


Let's plot the obtained results


```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):
    # extract feasible solution
    lowests = sampleset.lowest()
    if len(lowests) == 0:
        print("No feasible solution found ...")
    else:
        best_sol = lowests[0]
        pos = nx.spring_layout(graph,seed=1)

        color_map = []
        for node in graph.nodes:
            if (node,) in best_sol.var_values["x"].values.keys():
                color_value = best_sol.var_values["x"].values[(node,)]
                color_map.append(color_value)
            else:
                color_map.append(0)  # Default color if not in the solution

        # Draw the graph with the color mapping
        nx.draw_networkx(graph, pos, with_labels=True,
                         node_color=color_map, cmap=plt.get_cmap('rainbow'))

plot_graph_coloring(G, sampleset)
```


    
![png](graph_partition_files/graph_partition_42_0.png)
    



```python

```
# Quantum Chemistry

## Tutorials

- [Variational Quantum EigenSolver (VQE) for the Hydrogen Molecule](vqe_for_hydrogen.ipynb): Learn how to implement VQE to find the ground state energy of hydrogen molecule.# Variational Quantum EigenSolver (VQE) for the Hydrogen Molecule

In this tutorial, we'll explore the implementation of the Variational Quantum Eigensolver (VQE) algorithm to find the ground state energy of a hydrogen molecule (H2). We'll use various quantum computing frameworks including OpenFermion for molecular Hamiltonians, Qamomile for quantum circuit construction, and Qiskit for quantum simulation.

The workflow includes:
1. Converting molecular Hamiltonians to qubit operators
2. Creating a parametrized quantum circuit (ansatz)
3. Implementing VQE optimization
4. Analyzing the energy landscape at different atomic distances

We'll demonstrate how quantum computing can be used to solve quantum chemistry problems, specifically focusing on finding the minimum energy configuration of H2.


```python
# You can install the required packages by running the following command
# !pip install openfermion pyscf openfermionpyscf
```

## Creating the Hamiltonian of the Hydrogen Molecule


```python
import openfermion.chem as of_chem
import openfermion.transforms as of_trans
import openfermionpyscf as of_pyscf
```


```python
basis = "sto-3g"
multiplicity = 1
charge = 0
distance = 0.977
geometry = [["H", [0, 0, 0]], ["H", [0, 0, distance]]]
description = "tmp"
molecule = of_chem.MolecularData(geometry, basis, multiplicity, charge, description)
molecule = of_pyscf.run_pyscf(molecule, run_scf=True, run_fci=True)
n_qubit = molecule.n_qubits
n_electron = molecule.n_electrons
fermionic_hamiltonian = of_trans.get_fermion_operator(molecule.get_molecular_hamiltonian())
jw_hamiltonian = of_trans.jordan_wigner(fermionic_hamiltonian)
```

## Convert to Qamomile Hamiltonian

In this section, we transform the OpenFermion Hamiltonian into a Qamomile Hamiltonian format. After applying the Jordan-Wigner transformation to convert fermionic operators to qubit operators, we use custom conversion functions to create a compatible Hamiltonian representation for Qamomile.


```python
import qamomile.core.operator as qm_o

def operator_to_qamomile(operators: tuple[tuple[int, str], ...]) -> qm_o.Hamiltonian:
    pauli = {"X": qm_o.X, "Y": qm_o.Y, "Z": qm_o.Z}
    H = qm_o.Hamiltonian()
    H.constant = 1.0
    for ope in operators:
        H = H * pauli[ope[1]](ope[0])
    return H

def openfermion_to_qamomile(of_h) -> qm_o.Hamiltonian:
    H = qm_o.Hamiltonian()
    for k, v in of_h.terms.items():
        if len(k) == 0:
            H.constant += v
        else:
            H += operator_to_qamomile(k) * v
    return H

hamiltonian = openfermion_to_qamomile(jw_hamiltonian)
```

## Create VQE ansatz

In this section, we create a simple ansatz for the VQE algorithm. The ansatz is a parametrized quantum circuit that prepares a trial wavefunction. We use the Qamomile framework to construct the ansatz circuit.


```python
from qamomile.core.ansatz.efficient_su2 import create_efficient_su2_circuit
from qamomile.core.circuit.drawer import plot_quantum_circuit

ansatz = create_efficient_su2_circuit(
    hamiltonian.num_qubits, rotation_blocks=["ry", "rz"],
    reps=4, entanglement="linear"
)
plot_quantum_circuit(ansatz)
```


    
![png](vqe_for_hydrogen_files/vqe_for_hydrogen_8_0.png)
    


## Run VQE with Qiskit

In this section, we execute the VQE using the Qiskit Aer simulator after converting the Qamomile Hamiltonian and ansatz to Qiskit format.  
Of course, you can use other quantum computing frameworks.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()
qk_ansatz = qk_transpiler.transpile_circuit(ansatz)
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(hamiltonian)
```


```python
# !pip install qiskit-aer
```


```python
import qiskit.primitives as qk_pr
import qiskit as qk
from qiskit_aer import AerSimulator
from qiskit_aer.primitives import EstimatorV2
import numpy as np
from scipy.optimize import minimize

cost_history = []

aer_sim = AerSimulator()
qk_circuit_transpiled_ansatz = qk.transpile(qk_ansatz, aer_sim)
estimator = EstimatorV2()

def cost_estimator(param_values):
    job = estimator.run([(qk_ansatz, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data["evs"]
    return cost

def cost_callback(param_values):
    cost_history.append(cost_estimator(param_values))

initial_params = np.random.uniform(0, np.pi, len(qk_ansatz.parameters))

# Run QAOA optimization
result = minimize(
    cost_estimator,
    initial_params,
    method="BFGS",
    options={"disp": True, "maxiter": 50, "gtol": 1e-6},
    callback=cost_callback
)
print(result)
```

             Current function value: -1.105868
             Iterations: 50
             Function evaluations: 2091
             Gradient evaluations: 51
      message: Maximum number of iterations has been exceeded.
      success: False
       status: 1
          fun: -1.1058675315265363
            x: [ 3.157e+00  2.124e+00 ...  1.591e+00  4.345e-01]
          nit: 50
          jac: [ 5.545e-05  1.662e-04 ...  5.196e-04 -2.392e-05]
     hess_inv: [[ 6.494e+00 -2.618e+00 ...  1.032e+01 -6.820e-01]
                [-2.618e+00  9.130e+00 ... -5.761e+00  3.409e+00]
                ...
                [ 1.032e+01 -5.761e+00 ...  2.391e+01 -1.763e+00]
                [-6.820e-01  3.409e+00 ... -1.763e+00  2.796e+00]]
         nfev: 2091
         njev: 51


    /Users/yuyamashiro/Library/Caches/pypoetry/virtualenvs/qamomile-s0Pfpxir-py3.10/lib/python3.10/site-packages/scipy/optimize/_minimize.py:726: OptimizeWarning: Maximum number of iterations has been exceeded.
      res = _minimize_bfgs(fun, x0, args, jac, callback, **options)



```python
import matplotlib.pyplot as plt
plt.plot(cost_history)
plt.plot(
    range(len(cost_history)),
    [molecule.fci_energy] * len(cost_history),
    linestyle="dashed",
    color="black",
    label="Exact Solution",
)
plt.legend()
plt.show()
```


    
![png](vqe_for_hydrogen_files/vqe_for_hydrogen_13_0.png)
    


## Change distance between atoms


```python
def hydrogen_molecule(bond_length):
    basis = "sto-3g"
    multiplicity = 1
    charge = 0
    geometry = [["H", [0, 0, 0]], ["H", [0, 0, bond_length]]]
    description = "tmp"
    molecule = of_chem.MolecularData(geometry, basis, multiplicity, charge, description)
    molecule = of_pyscf.run_pyscf(molecule, run_scf=True, run_fci=True)
    n_qubit = molecule.n_qubits
    n_electron = molecule.n_electrons
    fermionic_hamiltonian = of_trans.get_fermion_operator(
        molecule.get_molecular_hamiltonian()
    )
    jw_hamiltonian = of_trans.jordan_wigner(fermionic_hamiltonian)
    return openfermion_to_qamomile(jw_hamiltonian), molecule.fci_energy

bond_lengths = np.linspace(0.2, 1.5, 15)
energies = []
for bond_length in bond_lengths:
    hamiltonian, fci_energy = hydrogen_molecule(bond_length)
    
    ansatz = create_efficient_su2_circuit(
        hamiltonian.num_qubits, rotation_blocks=["ry", "rz"],
        reps=4, entanglement="linear"
    )

    qk_ansatz = qk_transpiler.transpile_circuit(ansatz)
    qk_hamiltonian = qk_transpiler.transpile_hamiltonian(hamiltonian)

    cost_history = []
    initial_params = np.random.uniform(0, np.pi, len(qk_ansatz.parameters))
    result = minimize(
        cost_estimator,
        initial_params,
        method="BFGS",
        options={"maxiter": 50, "gtol": 1e-6},
    )

    energies.append(result.fun)

    print("distance: ", bond_length, "energy: ", result.fun, "fci_energy: ", fci_energy)
```

    distance:  0.2 energy:  0.15754119488608387 fci_energy:  0.15748213479836348
    distance:  0.29285714285714287 energy:  -0.5679350331466697 fci_energy:  -0.5679447209710022
    distance:  0.38571428571428573 energy:  -0.8833020521044717 fci_energy:  -0.8833596636183383
    distance:  0.4785714285714286 energy:  -1.0335991644424345 fci_energy:  -1.0336011797110967
    distance:  0.5714285714285714 energy:  -1.1035710721430323 fci_energy:  -1.1042094222435161
    distance:  0.6642857142857144 energy:  -1.1322058758760072 fci_energy:  -1.132350882707551
    distance:  0.7571428571428571 energy:  -1.136784862771528 fci_energy:  -1.1369026717971324
    distance:  0.8500000000000001 energy:  -1.1281267827080066 fci_energy:  -1.1283618784581124
    distance:  0.9428571428571428 energy:  -1.1125670649192354 fci_energy:  -1.1127252078468768
    distance:  1.0357142857142858 energy:  -1.093269672823594 fci_energy:  -1.0934760882294043
    distance:  1.1285714285714286 energy:  -1.0725622262836512 fci_energy:  -1.0727578805453502
    distance:  1.2214285714285713 energy:  -1.0519588130652564 fci_energy:  -1.0520081621708446
    distance:  1.3142857142857143 energy:  -1.0322273864176297 fci_energy:  -1.032240030624708
    distance:  1.4071428571428573 energy:  -1.0137141437663768 fci_energy:  -1.014147058669549
    distance:  1.5 energy:  -0.9978997023749084 fci_energy:  -0.9981493534714101



```python
plt.plot(bond_lengths, energies, "-o")
plt.xlabel("Distance")
plt.ylabel("Energy")
plt.show()
```


    
![png](vqe_for_hydrogen_files/vqe_for_hydrogen_16_0.png)
    



```python

```
# Using the PennyLaneTranspiler in Qamomile
This tutorial demonstrates the usage of the PennyLaneTranspiler in Qamomile and provides key examples to guide users in applying it effectively.

## Translating a Hamiltonian into PennyLane

We begin by defining a Hamiltonian as a test example and use our transpiler to convert it into a PennyLane-compatible representation. This step shows how seamlessly the Hamiltonian defined in our own library’s format can be translated into operators recognized by PennyLane.


```python
import pennylane as qml
import numpy as np
import qamomile
from qamomile.pennylane.transpiler import PennylaneTranspiler
from qamomile.core.operator import Hamiltonian, Pauli, X, Y, Z
from qamomile.core.circuit import QuantumCircuit as QamomileCircuit
from qamomile.core.circuit import (
    QuantumCircuit,
    SingleQubitGate,
    TwoQubitGate,
    ParametricSingleQubitGate,
    ParametricTwoQubitGate,
    SingleQubitGateType,
    TwoQubitGateType,
    ParametricSingleQubitGateType,
    ParametricTwoQubitGateType,
    Parameter
)

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
```

In this snippet, we start from a custom-defined Hamiltonian using various Pauli operators (X, Y, Z) and then employ `PennylaneTranspiler` to convert it into a format directly suitable for PennyLane devices. By inspecting `ops_first_term` and printing out `pennylane_hamiltonian`, we can verify the correctness of the translation.


```python
hamiltonian = Hamiltonian()
hamiltonian += X(0)*Z(1)
hamiltonian += Y(0)*Y(1)*Z(2)*X(3)*X(4)

transpiler = PennylaneTranspiler()
pennylane_hamiltonian = transpiler.transpile_hamiltonian(hamiltonian)

ops_first_term = pennylane_hamiltonian.terms()[1][0]
print(pennylane_hamiltonian)
```

    1.0 * (X(0) @ Z(1) @ I(2) @ I(3) @ I(4)) + 1.0 * (Y(0) @ Y(1) @ Z(2) @ X(3) @ X(4))


## Constructing a Parameterized Quantum Circuit

Next, we build a parameterized quantum circuit using QamomileCircuit. We include single-qubit rotations (e.g., rx, ry, rz) and controlled variants (crx, crz, cry), as well as two-qubit entangling gates (rxx, ryy, rzz). The parameters (theta, beta, gamma) allow for flexible variational adjustments.


```python
qc = QamomileCircuit(3)
theta = Parameter("theta")
beta = Parameter("beta")
gamma = Parameter("gamma")

qc.rx(theta, 0)
qc.ry(beta, 1)
qc.rz(gamma, 2)
qc.crx(gamma, 0 ,1)
qc.crz(theta, 1 ,2)
qc.cry(beta, 2 ,0)
qc.rxx(gamma, 0 ,1)
qc.ryy(theta, 1 ,2)
qc.rzz(beta, 2 ,0)

transpiler = PennylaneTranspiler()
QNode = transpiler.transpile_circuit(qc)
```

## Formulating the MaxCut Problem and Converting it into a Quantum Form

In the following part, we demonstrate how to take a classical optimization problem—MaxCut—and encode it into an Ising-form Hamiltonian. We then construct a QAOA-style ansatz circuit that, when executed and optimized, attempts to solve the MaxCut instance.


```python
def maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem

def maxcut_instance():
    # Construct a simple graph for a MaxCut instance
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 4])
    G.add_edges_from([(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)])
    E = [list(edge) for edge in G.edges]
    instance_data = {"V": G.number_of_nodes(), "E": E}
    pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
    nx.draw_networkx(G, pos, node_size=500)
    return instance_data

problem = maxcut_problem()
instance_data = maxcut_instance()
compiled_instance = jmt.compile_model(problem, instance_data)

# Convert the compiled problem into a QAOA form.
qaoa_converter = qamomile.core.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode()

p = 5
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_8_0.png)
    



```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_9_0.png)
    


We have now translated the MaxCut problem into a cost Hamiltonian suitable for a QAOA-like algorithm. The parameter `p` determines the number of layers of problem and mixer Hamiltonians. Each layer’s parameters are variational and will be tuned to minimize the expvalue, ideally leading to a good solution to the MaxCut instance.

## Transpiling and Executing the QAOA Circuit in PennyLane

With the QAOA circuit and Hamiltonian defined, we use the transpiler again, this time to convert the QAOA circuit and cost Hamiltonian into PennyLane forms:


```python
from pennylane import numpy as p_np
transpiler = PennylaneTranspiler()
circ_func = transpiler.transpile_circuit(qaoa_circuit)
qml_hamiltonian = transpiler.transpile_hamiltonian(qaoa_hamiltonian)

dev = qml.device("default.qubit", wires=qaoa_circuit.num_qubits)

@qml.qnode(dev)
def circuit(params, return_samples=False):
    circ_func(params)
    if return_samples:
        return qml.sample()
    return qml.expval(qml_hamiltonian)

parameters = p_np.array([np.pi/4, np.pi/4]*p, requires_grad=True)
print("Initial Expectation Value:", circuit(parameters))
cost_history = []
cost_history.append(circuit(parameters))
```

    Initial Expectation Value: 0.6975904406316911


Here, `circ_func` is the PennyLane circuit function generated from the QAOA ansatz. Evaluating `circuit(p)` gives the expectation value of the cost Hamiltonian for the given set of parameters `p`.

## Optimizing the Parameters

Finally, we leverage PennyLane’s optimizers to update the parameters and attempt to find those that yield better results (e.g., lower cost for the MaxCut objective):


```python
max_iterations = 1000
optimizer = qml.GradientDescentOptimizer(stepsize=5e-2)
for i in range(max_iterations):
    parameters, loss= optimizer.step_and_cost(circuit, parameters)
    cost_history.append(loss)
    
print("Optimal Parameters")
print(parameters)
```

    Optimal Parameters
    [ 0.35271931  1.02327598  0.74961704  1.12583207  0.91321306 -0.38421535
      1.08607428  1.27879381  1.12025286  1.42425253]



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, max_iterations)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_16_0.png)
    


Once the optimized parameters are obtained, we use PennyLane's QNode to sample from the parameterized quantum circuit to get the circuit counts.


```python
dev_counts = qml.device("default.qubit", wires=qaoa_circuit.num_qubits, shots=1000)
@qml.qnode(dev_counts)
def circuit_counts(params):
    circ_func(params)
    return qml.counts()
result = circuit_counts(parameters)
```


```python
# Prepare data for plotting
keys = list(result.keys())
values = list(result.values())

# Plotting
plt.figure(figsize=(12, 6))
plt.bar(keys, values, width=0.6)
plt.xlabel("State", fontsize=12)
plt.ylabel("Frequency", fontsize=12)
plt.title("Distribution of State", fontsize=14)
plt.xticks(rotation=90, fontsize=10)
plt.tight_layout()
plt.show()
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_19_0.png)
    


## Evaluating the Results
From the `circuit_counts` obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(transpiler, result) 
plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_21_0.png)
    



```python

```
# Building Quantum Circuits

## Introduction
Welcome to this tutorial on building quantum circuits with Qamomile! While Qamomile is primarily designed for quantum optimization tasks, it also offers powerful capabilities for constructing arbitrary quantum circuits. This tutorial will guide you through the process of creating and manipulating quantum circuits using Qamomile's unique intermediate representation.


## Prerequisites
Before we begin, make sure you have:

- Qamomile Installed in your Python Environment


## Getting Started
First, let's import the necessary modules from Qamomile:


```python
import qamomile.core as qm
```

## Creating a Quantum Circuit
To create a quantum circuit in Qamomile, we start by initializing quantum and classical registers, then use these to create a QuantumCircuit object:


```python
circuit = qm.circuit.QuantumCircuit(2)  # Create a quantum circuit with 2 qubits
```

## Adding Gates to the Circuit
Qamomile supports a wide range of quantum gates. Let's add some common gates to our circuit:


```python
# Apply Hadamard gate to the first qubit
circuit.h(0)

# Apply CNOT gate with first qubit as control and second as target
circuit.cx(0, 1)

# Apply X-gate to the second qubit
circuit.x(1)
```

The quantum gates supported by Qamomile can be found at the following link: 
https://jij-inc.github.io/Qamomile/autoapi/core/circuit/circuit/index.html#core.circuit.circuit.QuantumCircuit

## Measurements
To perform measurements in Qamomile:


```python
circuit.measure_all()
```

## Visualizing the Circuit
Qamomile provides a method to visualize the quantum circuit:


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(circuit)
```


    
![png](building_quantum_circuits_files/building_quantum_circuits_11_0.png)
    


## Circuit Composition

You can combine smaller circuits to create more complex ones:


```python
# Create two separate circuits
circuit1 = qm.circuit.QuantumCircuit(2)
circuit1.h(0)
circuit1.h(1)

circuit2 = qm.circuit.QuantumCircuit(2)
circuit2.cx(0, 1)


circuit1.append(circuit2)

plot_quantum_circuit(circuit1)
```


    
![png](building_quantum_circuits_files/building_quantum_circuits_13_0.png)
    


By specifying the `decompose_level` when plotting, you can display the circuit in more detail.


```python
plot_quantum_circuit(circuit1, decompose_level=1)
```


    
![png](building_quantum_circuits_files/building_quantum_circuits_15_0.png)
    


## Executing the Quantum Circuit

While Qamomile itself doesn't have the functionality to execute quantum circuits, it can translate the circuit to other quantum SDKs for execution.

### Qiskit Backend

Here's how you can execute a Qamomile circuit using Qiskit:

1- First import the necessary modules:


```python
from qamomile.qiskit import QiskitTranspiler
import qiskit.primitives as qk_pr
```

2- Create a QiskitTranspiler object:


```python
qk_transpiler = QiskitTranspiler()
```

3- Trasnpile your Qamomile circuit to a Qiskit circuit:


```python
qk_circuit = qk_transpiler.transpile_circuit(circuit)
```

4- Now you can use Qiskit's functionality to execute the circuit. For example, to run the circuit on a simulator:


```python
simulator = qk_pr.StatevectorSampler()
job = simulator.run([qk_circuit], shots=1000)
result = job.result()
```

5- The results can then be processed and analyzed using Qiskit's tools:


```python
result[0].data['c'].get_counts()
```




    {'10': 494, '01': 506}



### QURI-Parts with Qulacs Backend

Here's how you can execute a Qamomile circuit using QURI-Parts with Qulacs.

Execute the quantum circuit by converting it in the same way as Qiskit.


```python
from qamomile.quri_parts import QuriPartsTranspiler

# Transpile the circuit to QURI-Parts
qp_transpiler = QuriPartsTranspiler()
qp_circuit = qp_transpiler.transpile_circuit(circuit)
```

Now you can use Qulacs to execute the circuit:


```python
from quri_parts.core.state import quantum_state, apply_circuit
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
sampling_result = sampler(qp_circuit, 1000)
```


```python
sampling_result
```




    Counter({1: 501, 2: 499})



### Pennylane Backend

Here's how you can execute a Qamomile circuit using Pennylane.

Execute the quantum circuit by converting it in the same way as Qiskit.


```python
from qamomile.pennylane import PennylaneTranspiler

# Transpile the circuit to Pennylane
qml_transpiler = PennylaneTranspiler()
qml_circuit_func = qml_transpiler.transpile_circuit(circuit)
```


```python
import pennylane as qml

dev = qml.device("default.qubit", wires=circuit.num_qubits, shots=1000)
@qml.qnode(dev)
def qml_circuit(params):
    qml_circuit_func(params)
        
    return qml.counts()
```


```python
qml_circuit(None)
```




    {'01': 483, '10': 517}



## Conclusion

This tutorial has introduced you to building quantum circuits using Qamomile's intermediate representation and executing them using Qiskit and QURI-Parts. While Qamomile's primary focus is on quantum optimization, these circuit-building capabilities provide flexibility for various quantum computing tasks.  
Happy quantum computing with Qamomile!
## Using the QuTiPTranspiler in Qamomile

We will introduce applications in quantum annealing using Qamomile and QuTip. We focus on a Hamiltonian of the following form:

$$
H(s) = s H_0 + (1 - s) H_1
$$

where $ H_0 $ is the Hamiltonian for the Max-Cut problem we want to solve and often formulated in terms of an Ising model, and $ H_1 $ is the Hamiltonian for the transverse magnetic field. For further details on how to construct the Hamiltonian for the max-cut problem, please refer to [QAOA for Max-Cut](https://jij-inc.github.io/Qamomile/tutorial/maxcut.html).
The Hamiltonians are defined as follows: 

$$
H_0 = -\frac{1}{2} \sum_{(i,j) \in E} w_{i,j}(1 - s_i s_j)  , \quad H_1 = - \sum_{i=1}^N \sigma_i^x
$$


As the parameter $s$ gradually shifts from 0 to 1, the system gradually evolves from the ground state of $H_1$ to the ground state of  $H_0$, which corresponds to the solution to the optimization problem. 

First, let’s import the Qamomile library and other libraries used in this example.



```python
import jijmodeling as jm
import numpy as np
import qamomile.core.operator as qm_o
import matplotlib.pyplot as plt
import qamomile.qutip as qm_qt

def Maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    w = jm.Placeholder("w", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)

    problem = jm.Problem("Maxcut")
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = -1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem


problem = Maxcut_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Maxcut} & & \\& & \min \quad \displaystyle (-0.5) \cdot \sum_{e \in E} \left(- s_{e[0]} \cdot s_{e[1]} + 1\right) & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$




```python
import networkx as nx
from IPython.display import display, Latex

G = nx.Graph()
num_nodes = 5
edges = [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]
G.add_nodes_from(range(num_nodes))
G.add_edges_from(edges)

pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
plt.title("G=(V,E)")
plt.plot(figsize=(5, 4))

nx.draw_networkx(G, pos, node_size=500)
```


    
![png](quantum_annealing_files/quantum_annealing_3_0.png)
    



```python
import jijmodeling_transpiler.core as jmt
compiled_model = jmt.compile_model(problem, {"V": num_nodes, "E": edges})
```


```python
import qamomile.core as qm

# Obtain cost hamiltonian
qaoa_converter = qm.qaoa.QAOAConverter(compiled_model)
H0 = qaoa_converter.get_cost_hamiltonian()
```

Now transpile the qamomile’s hamiltonian to the qutip’s hamiltonian


```python
qt_transpiler = qm_qt.QuTiPTranspiler()
qt_H0= qt_transpiler.transpile_hamiltonian(H0)
```

Hamiltonian $H_1$ for the transverse magnetic field is also needed to be constructed


```python
H1 = qm_o.Hamiltonian()
for q1 in range(num_nodes):
    H1 -= qm_o.X(q1)
qt_H1= qt_transpiler.transpile_hamiltonian(H1)
```

We define the annealing time $T$ with $s = t / T$, where $s$ is the parameter in the Hamiltonian $H(s)$ introduced earlier. In Quantum Annealing, if $T$ is taken sufficiently large, the ground state of $H_0$ can theoretically be obtained. We perform quantum annealing for the Max-Cut problem and examine whether the final state $|\psi(T)\rangle$ is an optimal solution to the problem.

The entire Hamiltonian of the quantum annealing is given as a list where each element is a pair consisting of a Hamiltonian and its coefficient. Also, We create the initial state $ \psi(t)$ at $t = 0$, which is the ground state of $H_1$.


```python
from qutip import tensor, Qobj, mesolve

T=100

def coef0(t, args):
    return t/T

def coef1(t, args):
    return 1-t/T

H = [[qt_H0, coef0], [qt_H1, coef1]]
psi0 = tensor([Qobj([[1], [1]])/np.sqrt(2) for _ in range(num_nodes)])
```

To solve the Schrödinger equation, we use `mesolve`with the Hamiltonian, the initial state and a list of times.


```python
tlist = np.linspace(0.0, T, 101)
result = mesolve(H, psi0, tlist, [])
psi_final = result.states[-1]
```

We can visualize the probability distribution of the final state after annealing.


```python
probs = np.abs(psi_final.full())**2
plt.figure(figsize=(10, 6))
basis_labels = [f"{i:0{num_nodes}b}" for i in range(2**num_nodes)]
bars=plt.bar(range(len(probs)), probs.flatten())
plt.xticks(ticks=range(len(probs)), labels=basis_labels, rotation=90)
plt.xlabel("States")
plt.ylabel("Probability")
plt.title("Probability Distribution of Final States")

plt.show()
```


    
![png](quantum_annealing_files/quantum_annealing_16_0.png)
    


The final states and their corresponding probabilities are:


```python
final_states = []
for bar, label in zip(bars, basis_labels):
    if bar.get_height() > 1e-4:
        print(f"Final state: {label}, Probability: {bar.get_height():.4f}")
        array_label = np.array([int(bit) for bit in label])
        final_states.append((array_label, bar.get_height())) 
```

    Final state: 01100, Probability: 0.2500
    Final state: 01110, Probability: 0.2500
    Final state: 10001, Probability: 0.2500
    Final state: 10011, Probability: 0.2500


According to the result, there are four degenerate solutions. Let's visualize all the solutions. Meanswhile, we can refer to the result obtained using [QAOA](https://jij-inc.github.io/Qamomile/tutorial/maxcut.html)


```python
from qamomile.core.bitssample import BitsSample, BitsSampleSet
samples = []
for state,prob in final_states:
    sample = BitsSample(int(prob), state)
    samples.append(sample)

sample_set = BitsSampleSet(bitarrays=samples)

transformed_state = []
for transformed in qaoa_converter.decode_bits_to_sampleset(sample_set).data:
    transformed_state.append(transformed.var_values['x'].values)
print(transformed_state)
```

    [{(1,): 1.0, (4,): 1.0}, {(4,): 1.0, (2,): 1.0, (1,): 1.0}, {(0,): 1.0, (3,): 1.0}, {(2,): 1.0, (3,): 1.0, (0,): 1.0}]



```python
edge_colors = []

def get_edge_colors(graph, cut_solution, in_cut_color="r", not_in_cut_color="b"):
    cut_set_1 = [node[0] for node, value in cut_solution.items() if value == 1.0]
    cut_set_2 = [node for node in graph.nodes() if node not in cut_set_1]

    edge_colors = []
    for u, v, _ in graph.edges(data=True):
        if (u in cut_set_1 and v in cut_set_2) or (u in cut_set_2 and v in cut_set_1):
            edge_colors.append(in_cut_color)
        else:
            edge_colors.append(not_in_cut_color)
            
    node_colors = ["#2696EB" if node in cut_set_1 else "#EA9B26" for node in graph.nodes()]
    return edge_colors, node_colors

fig, axes = plt.subplots(2, 2, figsize=(10, 8)) 
axes = axes.flatten()

for i, cut_solution in enumerate(transformed_state):
    
    edge_colors, node_colors = get_edge_colors(G, cut_solution)
    
    # Create the plot
    ax = axes[i]  # Select subplot
    ax.set_title(f"Solution {i+1}")
    
    nx.draw_networkx(
        G,
        pos,
        node_size=500,
        width=3,
        with_labels=True,
        edge_color=edge_colors,
        node_color=node_colors,
        ax=ax,
    )

plt.tight_layout()
plt.show()
```


    
![png](quantum_annealing_files/quantum_annealing_21_0.png)
    


We can also visualize how the eigenenergy of the Hamiltonian changes as the parameter $s$ varies from 0 to 1 on the energy spectrum calculated by `eigenenergies`. 


```python
slist = np.linspace(0.0, 1.0, 101)
enegry_list = [[] for i in range(2**num_nodes)]

for s in slist:
    qt_H = s*qt_H0 + (1-s)*qt_H1
    enegry = qt_H.eigenenergies()
    for i in range(2**num_nodes):
        enegry_list[i].append(enegry[i])
```


```python
for i in range(2**num_nodes):
    plt.plot(slist, enegry_list[i], label=f"{i+1}th")

plt.xlabel("s")
plt.ylabel("Eigenenergies")
plt.title("Energy Spectrum")
plt.show()
```


    
![png](quantum_annealing_files/quantum_annealing_24_0.png)
    


We can see that there are four degenerate states that share the same lowest energy level, which agrees with the annealing result.

Masaphys. *PythonとQuTiPで量子アニーリングのダイナミクスを追う*. Qiita. Accessed October 30, 2024. [https://qiita.com/masaphys/items/38aeaee5313f81e15414](https://qiita.com/masaphys/items/38aeaee5313f81e15414)



```python

```
# Using the QuriPartsTranspiler in Qamomile
This tutorial demonstrates the usage of the QuriPartsTranspiler in Qamomile and provides key examples to guide users in applying it effectively.

## Translating a Hamiltonian into QuriParts

We begin by defining a Hamiltonian as a test example and use our transpiler to convert it into a QuriParts-compatible representation. 
This step shows how seamlessly the Hamiltonian defined in our own library’s format can be translated into operators recognized by QuriParts.


```python
import numpy as np
import qamomile
from qamomile.quri_parts.transpiler import QuriPartsTranspiler
from qamomile.core.operator import Hamiltonian, Pauli, X, Y, Z
from qamomile.core.circuit import QuantumCircuit as QamomileCircuit
from qamomile.core.circuit import (
    QuantumCircuit,
    SingleQubitGate,
    TwoQubitGate,
    ParametricSingleQubitGate,
    ParametricTwoQubitGate,
    SingleQubitGateType,
    TwoQubitGateType,
    ParametricSingleQubitGateType,
    ParametricTwoQubitGateType,
    Parameter
)

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
```

In this snippet, we start from a custom-defined Hamiltonian using various Pauli operators (X, Y, Z) and then employ `QuriPartsTranspiler` to convert it into a format directly suitable for QuriParts. By printing out `quriParts_hamiltonian`, we can verify the correctness of the translation.


```python
hamiltonian = Hamiltonian()
hamiltonian += X(0)*Z(1)
hamiltonian += Y(0)*Y(1)*Z(2)*X(3)*X(4)

transpiler = QuriPartsTranspiler()
quriParts_hamiltonian = transpiler.transpile_hamiltonian(hamiltonian)

quriParts_hamiltonian
```




    {frozenset({(0, <SinglePauli.X: 1>), (1, <SinglePauli.Z: 3>)}): 1.0,
     frozenset({(0, <SinglePauli.Y: 2>),
                (1, <SinglePauli.Y: 2>),
                (2, <SinglePauli.Z: 3>),
                (3, <SinglePauli.X: 1>),
                (4, <SinglePauli.X: 1>)}): 1.0}



## Constructing a Parameterized Quantum Circuit

Next, we build a parameterized quantum circuit using QamomileCircuit. We include single-qubit rotations (e.g., rx, ry, rz) and controlled variants (crx, crz, cry), as well as two-qubit entangling gates (rxx, ryy, rzz). The parameters (theta, beta, gamma) allow for flexible variational adjustments.


```python
qc = QamomileCircuit(3)
theta = Parameter("theta")
beta = Parameter("beta")
gamma = Parameter("gamma")

qc.rx(theta, 0)
qc.ry(beta, 1)
qc.rz(gamma, 2)
qc.rxx(gamma, 0 ,1)
qc.ryy(theta, 1 ,2)
qc.rzz(beta, 2 ,0)

transpiler = QuriPartsTranspiler()
qp_circuit = transpiler.transpile_circuit(qc)
```

## Formulating the MaxCut Problem and Converting it into a Quantum Form

In the following part, we demonstrate how to take a classical optimization problem—MaxCut—and encode it into an Ising-form Hamiltonian. We then construct a QAOA-style ansatz circuit that, when executed and optimized, attempts to solve the MaxCut instance.


```python
def maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem

def maxcut_instance():
    # Construct a simple graph for a MaxCut instance
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 4])
    G.add_edges_from([(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)])
    E = [list(edge) for edge in G.edges]
    instance_data = {"V": G.number_of_nodes(), "E": E}
    pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
    nx.draw_networkx(G, pos, node_size=500)
    return instance_data

problem = maxcut_problem()
instance_data = maxcut_instance()
compiled_instance = jmt.compile_model(problem, instance_data)

# Convert the compiled problem into a QAOA form.
qaoa_converter = qamomile.core.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode()

p = 5
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_8_0.png)
    



```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_9_0.png)
    


We have now translated the MaxCut problem into a cost Hamiltonian suitable for a QAOA-like algorithm. The parameter `p` determines the number of layers of problem and mixer Hamiltonians. Each layer’s parameters are variational and will be tuned to minimize the expvalue, ideally leading to a good solution to the MaxCut instance.

## Transpiling and Executing the QAOA Circuit in PennyLane

With the QAOA circuit and Hamiltonian defined, we use the transpiler again, this time to convert the QAOA circuit and cost Hamiltonian into QuriParts forms:


```python
transpiler = QuriPartsTranspiler()
# Transpile the QAOA circuit to QuriParts
qp_circuit = transpiler.transpile_circuit(qaoa_circuit)

# Transpile the QAOA Hamitltonian to QuriParts
qp_hamiltonian = transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qp_hamiltonian
```




    {frozenset({(0, <SinglePauli.Z: 3>), (1, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(0, <SinglePauli.Z: 3>), (2, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(1, <SinglePauli.Z: 3>), (3, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(1, <SinglePauli.Z: 3>), (4, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(3, <SinglePauli.Z: 3>), (4, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(2, <SinglePauli.Z: 3>), (4, <SinglePauli.Z: 3>)}): 0.5,
     PauliLabel(): -3.0}



Here, `qk_circuit` is the QuriParts circuit generated from the Qamomile QAOA ansatz and `qk_hamiltonian` is build from Qamomile Hamiltonian based on the mathematical model.

## Optimizing the Parameters

Finally, we optimize the variational parameter and attempt to find those that yield better results (e.g., lower cost for the MaxCut objective):


```python
from typing import Sequence
from scipy.optimize import minimize
from quri_parts.core.state import quantum_state, apply_circuit
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator

cost_history = []
# Cost estimator function


cb_state = quantum_state(qp_circuit.qubit_count, bits=0)
parametric_state = apply_circuit(qp_circuit, cb_state)


estimator = create_qulacs_vector_parametric_estimator()

cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(qp_hamiltonian, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost


# Create initial parameters
initial_params = np.random.uniform(low=-np.pi / 4, high=np.pi / 4, size=2 * p)

# Run QAOA optimization
result = minimize(
    cost_fn,
    initial_params,
    method="COBYLA",
    options={"maxiter": 2000},
)
print(result)
```

     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -4.711600340952039
           x: [ 1.579e+00 -9.337e-01  2.224e+00  1.642e+00  9.104e-01
               -9.487e-01 -7.253e-01 -2.557e-01 -4.168e-01  8.613e-01]
        nfev: 2000
       maxcv: 0.0



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_16_0.png)
    


Once the optimized parameters are obtained, we use QuriParts's `create_qulacs_vector_sampler` to sample from the parameterized quantum circuit to get the circuit counts.


```python
# Run Optimized QAOA circuit
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
bounded_circuit = qp_circuit.bind_parameters(result.x)
qp_result = sampler(bounded_circuit, 1000)
```


```python
bitcounts = {bin(i)[2:].zfill(qp_circuit.qubit_count): count for i, count in qp_result.items()}
```


```python
# Prepare data for plotting
keys = list(bitcounts.keys())
values = list(bitcounts.values())

# Plotting
plt.figure(figsize=(12, 6))
plt.bar(keys, values, width=0.6)
plt.xlabel("State", fontsize=12)
plt.ylabel("Frequency", fontsize=12)
plt.title("Distribution of State", fontsize=14)
plt.xticks(rotation=90, fontsize=10)
plt.tight_layout()
plt.show()
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_20_0.png)
    


## Evaluating the Results
From the `qp_result` and `qubit_count` obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
sampleset = qaoa_converter.decode(transpiler, (qp_result, qp_circuit.qubit_count))

plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_22_0.png)
    



```python

```
# Using the QiskitTranspiler in Qamomile
This tutorial demonstrates the usage of the QiskitTranspiler in Qamomile and provides key examples to guide users in applying it effectively.

## Translating a Hamiltonian into Qiskit

We begin by defining a Hamiltonian as a test example and use our transpiler to convert it into a Qiskit-compatible representation. 
This step shows how seamlessly the Hamiltonian defined in our own library’s format can be translated into operators recognized by Qiskit.


```python
import numpy as np
import qamomile
from qamomile.qiskit.transpiler import QiskitTranspiler
from qamomile.core.operator import Hamiltonian, Pauli, X, Y, Z
from qamomile.core.circuit import QuantumCircuit as QamomileCircuit
from qamomile.core.circuit import (
    QuantumCircuit,
    SingleQubitGate,
    TwoQubitGate,
    ParametricSingleQubitGate,
    ParametricTwoQubitGate,
    SingleQubitGateType,
    TwoQubitGateType,
    ParametricSingleQubitGateType,
    ParametricTwoQubitGateType,
    Parameter
)

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
```

In this snippet, we start from a custom-defined Hamiltonian using various Pauli operators (X, Y, Z) and then employ `QiskitTranspiler` to convert it into a format directly suitable for Qiskit. By printing out `qiskit_hamiltonian`, we can verify the correctness of the translation.


```python
hamiltonian = Hamiltonian()
hamiltonian += X(0)*Z(1)
hamiltonian += Y(0)*Y(1)*Z(2)*X(3)*X(4)

transpiler = QiskitTranspiler()
qiskit_hamiltonian = transpiler.transpile_hamiltonian(hamiltonian)

qiskit_hamiltonian
```




    SparsePauliOp(['IIIZX', 'XXZYY'],
                  coeffs=[1.+0.j, 1.+0.j])



## Constructing a Parameterized Quantum Circuit

Next, we build a parameterized quantum circuit using QamomileCircuit. We include single-qubit rotations (e.g., rx, ry, rz) and controlled variants (crx, crz, cry), as well as two-qubit entangling gates (rxx, ryy, rzz). The parameters (theta, beta, gamma) allow for flexible variational adjustments.


```python
qc = QamomileCircuit(3)
theta = Parameter("theta")
beta = Parameter("beta")
gamma = Parameter("gamma")

qc.rx(theta, 0)
qc.ry(beta, 1)
qc.rz(gamma, 2)
qc.crx(gamma, 0 ,1)
qc.crz(theta, 1 ,2)
qc.cry(beta, 2 ,0)
qc.rxx(gamma, 0 ,1)
qc.ryy(theta, 1 ,2)
qc.rzz(beta, 2 ,0)

transpiler = QiskitTranspiler()
qk_circuit = transpiler.transpile_circuit(qc)
```

## Formulating the MaxCut Problem and Converting it into a Quantum Form

In the following part, we demonstrate how to take a classical optimization problem—MaxCut—and encode it into an Ising-form Hamiltonian. We then construct a QAOA-style ansatz circuit that, when executed and optimized, attempts to solve the MaxCut instance.


```python
def maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem

def maxcut_instance():
    # Construct a simple graph for a MaxCut instance
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 4])
    G.add_edges_from([(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)])
    E = [list(edge) for edge in G.edges]
    instance_data = {"V": G.number_of_nodes(), "E": E}
    pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
    nx.draw_networkx(G, pos, node_size=500)
    return instance_data

problem = maxcut_problem()
instance_data = maxcut_instance()
compiled_instance = jmt.compile_model(problem, instance_data)

# Convert the compiled problem into a QAOA form.
qaoa_converter = qamomile.core.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode()

p = 5
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_8_0.png)
    



```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_9_0.png)
    


We have now translated the MaxCut problem into a cost Hamiltonian suitable for a QAOA-like algorithm. The parameter `p` determines the number of layers of problem and mixer Hamiltonians. Each layer’s parameters are variational and will be tuned to minimize the expvalue, ideally leading to a good solution to the MaxCut instance.

## Transpiling and Executing the QAOA Circuit in Qiskit

With the QAOA circuit and Hamiltonian defined, we use the transpiler again, this time to convert the QAOA circuit and cost Hamiltonian into Qiskit forms:


```python
transpiler = QiskitTranspiler()
# Transpile the QAOA circuit to Qiskit
qk_circuit = transpiler.transpile_circuit(qaoa_circuit)

# Transpile the QAOA Hamitltonian to Qiskit
qk_hamiltonian = transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIZZ', 'IIZIZ', 'IZIZI', 'ZIIZI', 'ZZIII', 'ZIZII', 'IIIII'],
                  coeffs=[ 0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j, -3. +0.j])



Here, `qk_circuit` is the Qiskit circuit generated from the Qamomile QAOA ansatz and `qk_hamiltonian` is build from Qamomile Hamiltonian based on the mathematical model.

## Optimizing the Parameters

Finally, we optimize the variational parameter and attempt to find those that yield better results (e.g., lower cost for the MaxCut objective):


```python
import qiskit.primitives as qk_pr
from scipy.optimize import minimize

cost_history = []
# Cost estimator function
estimator = qk_pr.StatevectorEstimator()


def estimate_cost(param_values):
    try:
        job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
        result = job.result()[0]
        cost = result.data["evs"]
        cost_history.append(cost)
        return cost
    except Exception as e:
        print(f"Error during cost estimation: {e}")
        return np.inf


# Create initial parameters
initial_params = np.random.uniform(low=-np.pi / 4, high=np.pi / 4, size=2 * p)

# Run QAOA optimization
result = minimize(
    estimate_cost,
    initial_params,
    method="COBYLA",
    options={"maxiter": 2000},
)
print(result)
```

     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -4.948032219792361
           x: [-5.640e-01 -4.659e-01 -3.222e-01 -5.174e-01  3.372e-01
                4.496e-01  8.850e-01  1.022e+00  1.040e+00 -8.994e-02]
        nfev: 2000
       maxcv: 0.0



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_16_0.png)
    


Once the optimized parameters are obtained, we use Qiskit's `StatevectorSampler` to sample from the parameterized quantum circuit to get the circuit counts.


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=10000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```


```python
# Prepare data for plotting
keys = list(qaoa_counts.get_counts().keys())
values = list(qaoa_counts.get_counts().values())

# Plotting
plt.figure(figsize=(12, 6))
plt.bar(keys, values, width=0.6)
plt.xlabel("State", fontsize=12)
plt.ylabel("Frequency", fontsize=12)
plt.title("Distribution of State", fontsize=14)
plt.xticks(rotation=90, fontsize=10)
plt.tight_layout()
plt.show()
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_19_0.png)
    


## Evaluating the Results
From the `qaoa_counts` obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
sampleset = qaoa_converter.decode(transpiler, qaoa_counts) 
plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_21_0.png)
    



```python

```
# Basic Usage of the Library

Welcome to the Qamomile tutorial! This guide will help you get started with Qamomile, a powerful SDK designed for quantum optimization algorithms. 
Qamomile specializes in the conversion of mathematical models into quantum circuits, serving as a bridge between classical optimization problems and quantum computing solutions.

## Supported Quantum Optimization Encodings and Algorithms

- **QAOA**: Quantum Approximate Optimization Algorithm
- **QRAO**: Quantum Random Approximation Optimization


## Supported Quantum Circuit SDKs

- **Qiskit**
- **Quri-parts**
- **PennyLane**
- **Qutip**


## Tutorials

- [Building Quantum Circuits](building_quantum_circuits.ipynb): Learn how to build a quantum circuit using Qamomile.
- [Write Hamiltonian Algebraically](algebraic_operator.ipynb): Learn how to create a Qamomile Hamiltonian using an algebraic modeler `jijmodeling`.
- [Using the QiskitTranspiler in Qamomile](Using_the_QiskitTranspiler_in_Qamomile.ipynb): Learn how to transpile from Qamomile to Qiskit.
- [Using the QuriPartsTranspiler in Qamomile](Using_the_QuriPartsTranspiler_in_Qamomile.ipynb): Learn how to transpile from Qamomile to Quri-Parts.
- [Using the PennyLaneTranspiler in Qamomile](Using_the_PennyLaneTranspiler_in_Qamomile.ipynb): Learn how to transpile from Qamomile to PennyLane.
- [Using the QuTiPTranspiler in Qamomile](quantum_annealing.ipynb): Learn how to run the Quantum Annealing with QuTiP's built-in functions.

# Write Hamiltonian Algebraically
This tutorial explains how to create a Qamomile Hamiltonian using an algebraic modeler `jijmodeling`.

Using this functionality will allow you to create Hamiltonians in a more intuitive way.


```python
import jijmodeling as jm
import qamomile.core.modeler as qm_m
```

## Write Algebraic Hamiltonian
Let us write Heisenberg model without the external field with periodic boundary condition by using qamomile modeler in this tutorial.

To define Pauli Operator Expression we need to use `qm_m.PauliExpr`.
In the Heisenberg model, there are $X$, $Y$ and $Z$ Pauli Operator, so let us define them first.


```python
N = jm.Placeholder("N")
Z = qm_m.PauliExpr.z(shape=(N,))
X = qm_m.PauliExpr.x(shape=(N,))
Y = qm_m.PauliExpr.y(shape=(N,))
Y
```




$$\displaystyle \hat{Y}$$



Next, let us define the Hamiltonian which is

$$
\hat{H} = - \sum_{i = 0}^{N-1} J_x X_i X_{i+1} + J_y Y_i Y_{i+1} + J_z Z_i Z_{i+1}
$$

Here we assume periodic boundary condition ( $X_N = X_0$ ).

We can define this by using `jijmodeling`.


```python
i = jm.Element("i", belong_to = (0,N))
J_x = jm.Placeholder("J_x")
J_y = jm.Placeholder("J_y")
J_z = jm.Placeholder("J_z")
expr = -jm.sum(i, J_x * X[i] * X[(i+1) % N] + J_y * Y[i] * Y[(i+1) % N] + J_z * Z[i] * Z[(i+1) % N])
h_expr = qm_m.HamiltonianExpr(expr)
h_expr
```




$$\displaystyle - \sum_{i = 0}^{N - 1} \left(J_x \cdot \hat{X}_{i} \cdot \hat{X}_{\left(i + 1\right) \bmod N} + J_y \cdot \hat{Y}_{i} \cdot \hat{Y}_{\left(i + 1\right) \bmod N} + J_z \cdot \hat{Z}_{i} \cdot \hat{Z}_{\left(i + 1\right) \bmod N}\right)$$



## Build Qamomile Hamiltonian from Algebraic Hamiltonian Expression
We can build qamomile `Hamiltonian` by inserting the value into `HamiltonianExpr`.

Let us create some data to insert first. 
We can provide the data as `dict`.

To make it easier to see whether the output of the results is correct, let's create some unusual data.


```python
instance_data = {"N":10, "J_x":1.0, "J_y":-1.0, "J_z":2.0}
```

We can use `HamiltonianBuilder` to insert the instance data into `HamiltonianExpr`.


```python

builder = qm_m.hamiltonian_expr.HamiltonianBuilder(h_expr,instance_data)
h = builder.build()
h
```




    Hamiltonian((X0, X1): -1.0, (Y0, Y1): 1.0, (Z0, Z1): -2.0, (X1, X2): -1.0, (Y1, Y2): 1.0, (Z1, Z2): -2.0, (X2, X3): -1.0, (Y2, Y3): 1.0, (Z2, Z3): -2.0, (X3, X4): -1.0, (Y3, Y4): 1.0, (Z3, Z4): -2.0, (X4, X5): -1.0, (Y4, Y5): 1.0, (Z4, Z5): -2.0, (X5, X6): -1.0, (Y5, Y6): 1.0, (Z5, Z6): -2.0, (X6, X7): -1.0, (Y6, Y7): 1.0, (Z6, Z7): -2.0, (X7, X8): -1.0, (Y7, Y8): 1.0, (Z7, Z8): -2.0, (X8, X9): -1.0, (Y8, Y9): 1.0, (Z8, Z9): -2.0, (X0, X9): -1.0, (Y0, Y9): 1.0, (Z0, Z9): -2.0)



If you also want to check the `Hamiltonian` in LaTex, you can do it as follows.


```python
import IPython.display as ipd

ipd.display(ipd.Latex("$" + h.to_latex() + "$"))
```


$-X_{0}X_{1}+Y_{0}Y_{1}-2.0Z_{0}Z_{1}-X_{1}X_{2}+Y_{1}Y_{2}-2.0Z_{1}Z_{2}-X_{2}X_{3}+Y_{2}Y_{3}-2.0Z_{2}Z_{3}-X_{3}X_{4}+Y_{3}Y_{4}-2.0Z_{3}Z_{4}-X_{4}X_{5}+Y_{4}Y_{5}-2.0Z_{4}Z_{5}-X_{5}X_{6}+Y_{5}Y_{6}-2.0Z_{5}Z_{6}-X_{6}X_{7}+Y_{6}Y_{7}-2.0Z_{6}Z_{7}-X_{7}X_{8}+Y_{7}Y_{8}-2.0Z_{7}Z_{8}-X_{8}X_{9}+Y_{8}Y_{9}-2.0Z_{8}Z_{9}-X_{0}X_{9}+Y_{0}Y_{9}-2.0Z_{0}Z_{9}$

# Qamomile Tutorial

Welcome to the Qamomile tutorial! This guide will help you get started with Qamomile, a powerful SDK designed for quantum optimization algorithms. Qamomile specializes in the conversion of mathematical models into quantum circuits, serving as a bridge between classical optimization problems and quantum computing solutions.

## Supported Quantum Optimization Encodings and Algorithms

- **QAOA**: Quantum Approximate Optimization Algorithm
- **QRAO**: Quantum Random Approximation Optimization


## Supported Quantum Circuit SDKs

- **Qiskit**
- **Quri-parts**
- **Qutip**


## Tutorials

- [Building Quantum Circuits](building_quantum_circuits.ipynb): Learn how to build a quantum circuit using Qamomile.
- [Write Hamiltonian Algebraically](algebraic_operator.ipynb): Learn how to create a Qamomile Hamiltonian using an algebraic modeler `jijmodeling`.
- [Quantum Alternating Ansatz for Graph Coloring](alternating_ansatz_graph_coloring.ipynb): Learn how to run the Quantum Alternating Ansatz for graph coloring problem.
- [Quantum Approximate Optimization Algorithm for Graph Partitioning](graph_partition.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for graph partitioning problem.
- [Quantum Approximate Optimization Algorithm for vertex covering](vertex_cover.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for vertex cover problem.
- [Quantum Approximate Optimization Algorithm for Max-Cut](maxcut.ipynb): Learn how to run the Quantum Quantum Approximate Optimization Algorithm for Max-Cut problem.
- [Quantum Approximate Optimization Algorithm for Multi-car Paint Shop Problem](multi_car_paint.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for multi-car paint shop problem.
- [Quantum Random Access Optimization (QRAO) for Maxcut problem](qrao_tutorial.ipynb): Learn how to use Quantum Random Access Optimization.
- [Quantum Approximate Optimization Algorithm for Travelling Salesman Problem](qaoa/Travelling_Salesman_Problem.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for Travelling Salesman Problem.
- [Quantum Annealing using QuTiP](quantum_annealing.ipynb): Learn how to run the Quantum Annealing with QuTiP's built-in functions.
- [Using the PennyLaneTranspiler in Qamomile](Using_the_PennyLaneTranspiler_in_Qamomile.ipynb): Learn how to transpile from Qamomile to PennyLane.

# Qamomile Quickstart Guide

This guide will help you get started with Qamomile quickly, covering installation and basic usage.

## Installation

### Prerequisites
Before installing Qamomile, ensure you have the following:

- Python 3.10 or higher
- pip (Python package installer)

### Installing Qamomile

Install Qamomile using pip:

```bash
pip install qamomile
```

### Optional Dependencies

Depending on your needs, you might want to install additional packages:

- For Qiskit integration: `pip install "qamomile[qiskit]"`
- For Quri Parts integration: `pip install "qamomile[quri-parts]"`
- For Qutip integration: `pip install "qamomile[qutip]"`

## Basic Usages

Let's walk through a simple example to demonstrate how to use Qamomile.

### 1. Import Qamomile and JijModeling


```python
import qamomile.core as qm
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
```

### 2. Create a Mathematical Model with JijModeling


```python
# Simple QUBO

Q = jm.Placeholder("Q", ndim=2)
n = Q.len_at(0, latex="n")
x = jm.BinaryVar("x", shape=(n,))

problem = jm.Problem("qubo")
i, j = jm.Element("i", n), jm.Element("j", n)
problem += jm.sum([i, j], Q[i, j] * x[i] * x[j])

problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{qubo} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{n - 1} \sum_{j = 0}^{n - 1} Q_{i, j} \cdot x_{i} \cdot x_{j} & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$




```python
# Prepare data
instance_data = {
    "Q": [[0.1, 0.2, -0.1],
          [0.2, 0.3, 0.4],
          [-0.1, 0.4, 0.0]]
}

# Compile the problem:
# Substitute the data into the problem.
compiled_instance = jmt.compile_model(problem, instance_data)
```

### 3. Create a Quantum Circuit and a Hamiltonian with Qamomile


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)

# Encode to Ising Hamiltonian
qaoa_converter.ising_encode()

# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=2)
# Get the cost Hamiltonian
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
```

### 4. Transpile to a Quantum Computing SDK (Qiskit or Quri Parts)
In this example, we will use Qiskit.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()

# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_circuit.draw(output="mpl")
```




    
![png](quickstart_files/quickstart_9_0.png)
    




```python
# Transpile the QAOA Hamiltonian to Qiskit
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIZ', 'IZI', 'ZII', 'IZZ', 'ZIZ', 'ZZI'],
                  coeffs=[-0.1 +0.j, -0.45+0.j, -0.15+0.j,  0.1 +0.j, -0.05+0.j,  0.2 +0.j])



### 5. Run the Quantum Circuit

Run the quantum circuit on a quantum simulator or a real quantum computer.  
In this example, we will use the Qiskit.  

In Qamomile, the execution of quantum circuits is delegated to the respective SDKs, allowing users to implement this part themselves if they choose to do so. Given that the primary applications of current quantum computers are research and education, we believe that the majority of cases where quantum optimization algorithms are executed will fall under these categories. To avoid turning Qamomile into a black box, the execution of quantum circuits is left to the users, making it easier to customize algorithms.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

# Run QAOA optimization
result = minimize(
    cost_estimator,
    [np.pi / 4, np.pi / 2, np.pi / 2, np.pi / 4],
    method="COBYLA",
    options={"maxiter": 1000},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -0.428242617622815
           x: [ 8.005e-01  1.940e+00  1.020e+00  1.509e+00]
        nfev: 281
       maxcv: 0.0



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](quickstart_files/quickstart_13_0.png)
    



```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
qaoa_counts.get_counts()
```




    {'000': 622, '100': 107, '010': 8, '001': 226, '101': 35, '011': 1, '111': 1}



### 6. Decode the Result

After running the quantum circuit, decode the result to obtain the solution.


```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.05)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()

```


    
![png](quickstart_files/quickstart_16_0.png)
    



```python

```
# Contributing to qamomile Documentation

We welcome contributions to the qamomile documentation! This guide will help you get started with contributing to our docs using Jupyter Book.

## Prerequisites

Before you begin, ensure you have the following installed:

1. Python 3.x
2. Git
3. Jupyter Book (`pip install jupyter-book`)

## Setting Up

1. Fork the qamomile repository on GitHub.
2. Clone your fork locally:
   ```
   gh repo clone username/Qamomile
   cd Qamomile
   ```
3. Create a virtual environment and activate it:
   ```
   poetry install
   poetry shell
   ```

## Making Changes to the Documentation

1. Navigate to the `docs/` directory in your local repository.
2. Find the appropriate Markdown (`.md`) or Jupyter Notebook (`.ipynb`) file you want to edit, or create a new one.
3. Make your changes using your preferred text editor.
4. If you're adding new pages, update the `_toc.yml` file to include your new page in the table of contents.

## Building the Documentation Locally

To preview your changes:

1. From the `docs/` directory, run:
   ```
   jupyter-book build .
   ```
2. Open `_build/html/index.html` in your web browser to view the built documentation.

## Submitting Your Changes

1. Commit your changes:
   ```
   git add .
   git commit -m "Brief description of your changes"
   ```
2. Push to your fork:
   ```
   git push origin main
   ```
3. Create a pull request from your fork to the main qamomile repository on GitHub.

## Style Guidelines

- Use clear, concise language.
- Follow the existing documentation structure and formatting.
- Include code examples where appropriate, especially when explaining qamomile's features or API.
- Use proper Markdown syntax for headings, lists, code blocks, etc.
- When documenting code, follow the docstring style used in the qamomile project.

## Documentation Structure

Our documentation is organized as follows:

- `index.md`: The main landing page
- `quickstart.md`: Guide for new users
- `api/`: API reference documentation for qamomile.
- `tutorial/`: Usage examples and tutorials
- `contribute.md`: This guide

Feel free to suggest improvements to this structure if you think it can be made more intuitive.

## Questions or Need Help?

If you have any questions or need assistance while contributing, please don't hesitate to:

- Open an issue on GitHub
- Reach out to the maintainers via [contact method]

Thank you for your interest in improving qamomile's documentation!# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh
# Welcome to Qamomile

Qamomile is a powerful SDK designed for quantum optimization algorithms, specializing in the conversion of mathematical models into quantum circuits. It serves as a bridge between classical optimization problems and quantum computing solutions.

## Key Features

- **Versatile Compatibility**: Supports leading quantum circuit SDKs including Qiskit and Quri-parts.
- **Advanced Algorithm Support**: Goes beyond QAOA to include sophisticated encoding and algorithms like QRAO.
- **Flexible Model Conversion**: Utilizes JijModeling for describing mathematical models and converting them to various quantum circuit SDKs.
- **Intermediate Representation**: Capable of representing both Hamiltonians and quantum circuits as intermediate forms.
- **Standalone Functionality**: Can implement quantum circuits independently, similar to other quantum circuit SDKs.

## Quick Start

To get started with Qamomile, please see the [Quick Start Guide](quickstart.ipynb) for installation instructions and a simple example.

## Learn More

Explore our documentation to dive deeper into Qamomile's capabilities:

- [Quick Start Guide](quickstart.ipynb): Installation instructions and a simple example to get you started.
- [API Reference](api/index.md): Complete documentation of Qamomile's API.
- [Tutorials](tutorial/index.md): Step-by-step guides and examples to get you started.

## Contributing

We welcome contributions from the community! If you're interested in improving Qamomile, please check out our [Contribution Guidelines](contribute.md).

## Support

If you encounter any issues or have questions, please file an issue on our [GitHub repository](https://github.com/Jij-Inc/Qamomile) or join our community discussion forum.

Welcome aboard, and happy quantum optimizing with Qamomile!# Graph Coloring Problem with Quantum Alternating Operator Ansatz
In this tutorial, we will solve the Graph Coloring Problem using the Quantum Alternating Operator Ansatz.


```python
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as opt
import networkx as nx
import qiskit.primitives as qk_pr

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt

import qamomile.core as qm
from qamomile.qiskit import QiskitTranspiler
from qamomile.core.circuit.drawer import plot_quantum_circuit
```

First, we will implement the mathematical model of the graph coloring problem using JijModeling.


```python
def graph_coloring_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    N = jm.Placeholder("N")
    x = jm.BinaryVar("x", shape=(V, N))
    n = jm.Element("i", belong_to=(0, N))
    v = jm.Element("v", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)
    # set problem
    problem = jm.Problem("Graph Coloring")
    # set one-hot constraint that each vertex has only one color

    problem += jm.Constraint("one-color", x[v, :].sum() == 1, forall=v)
    # set objective function: minimize edges whose vertices connected by edges are the same color
    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])
    return problem

problem = graph_coloring_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Coloring} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 1} \sum_{e \in E} x_{e_{0}, i} \cdot x_{e_{1}, i} & \\\text{{s.t.}} & & & \\ & \text{one-color} & \displaystyle \sum_{\ast_{1} = 0}^{N - 1} x_{v, \ast_{1}} = 1 & \forall v \in \left\{0,\ldots,V - 1\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will create an instance of the problem.


```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])
nx.draw(G)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_5_0.png)
    



```python
inst_E = [list(edge) for edge in G.edges]
color_num = 3
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "N": color_num, "E": inst_E}
num_qubits = num_nodes * color_num
```

# Quantum Alternating Operator Ansatz
Next, let's try solving the graph coloring problem using the Quantum Alternating Operator Ansatz. The Quantum Alternating Operator Ansatz[2] is a modification of QAOA, where the mixer is changed from an $X$-mixer to a mixer tailored to the problem, ensuring that only solutions satisfying the constraints are searched for. For more detailed information, please refer to the original paper. Here, we will look at how to implement it in JTQ.

For the Graph Coloring problem, there is a one-hot constraint:

$$
\sum_k x_{v,k} = 1\quad \forall v
$$

However, turning this into an $XY$-mixer is the Quantum Alternating Operator Ansatz approach to the Graph Coloring problem.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
```


```python
gamma_1 = qm.circuit.Parameter("gamma_1")
# Delete one-color penalty.
qaoa_converter.ising_encode(multipliers={"one-color": 0.0})
# Get exp(-i gamma H_P) circuit without mixer circuit.  
qaoa_cost_circuit = qaoa_converter.get_cost_ansatz(gamma_1)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```

Next, we will create an $XY$-mixer. The $XY$-mixer can be written as

$$
XY_{ij} = \frac{1}{2}\left(X_iX_j + Y_iY_j \right).
$$

This is an operator that swaps the bits 1 and 0 in bit $i,j$. Therefore, it can transform a bit string $100$, which satisfies the one-hot constraint, into another bit string $010$, which also satisfies the one-hot constraint.

Here, the only part under the one-hot constraint is related to color, so in terms of the mathematical model, we need to transform the bits between $x_{v0}$ and $x_{v1}$.
On the other hand, as these variables are usually embedded in qubits, it is necessary to remember which bit corresponds to which variable when constructing the algorithm and handle them appropriately.
In JTQ, the correspondence of variables is contained in var_map inside CompiledInstance.
```python
var_map['variable_name'][indices]
```
You can check which qubit corresponds to a variable in the mathematical model in this way.
Let's use this to create an $XY$-mixer.

What we want here is the transformation between $x_{v,k}$ and $x_{v,k+1}$, so we can obtain the index of the corresponding qubit by accessing compiled_instance.var_map.var_map["x"][(i,k)]."


```python
def create_xy_mixer(
    beta: qm.circuit.Parameter,
    num_nodes: int,
    num_color: int,
    compiled_instance: jmt.CompiledInstance,
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n, name="XY-mixer")
    var_map = compiled_instance.var_map.var_map["x"]
    # even
    for i in range(num_nodes):
        for k in range(0, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # odd
    for i in range(num_nodes):
        for k in range(1, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # ini-last
    if num_color % 2 == 1:
        for i in range(num_nodes):
            qc.rxx(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
            qc.ryy(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
    return qc
```


```python
def create_initial_state(
    compiled_instance: jmt.CompiledInstance, num_nodes: int, num_color: int
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n)
    var_map = compiled_instance.var_map.var_map["x"]
    for i in range(num_nodes):
        qc.x(var_map[(i, 0)])  # set all nodes to color 0
    return qc
```

Now that the Ansatz has been created, we would like to run the Quantum Alternating Operator Ansatz.


```python
initial_circuit = create_initial_state(compiled_instance, num_nodes, color_num)
initial_circuit.update_qubits_label(qaoa_converter.int2varlabel)
beta_1 = qm.circuit.Parameter("beta_1")
mixer_circuit = create_xy_mixer(beta_1, num_nodes, color_num, compiled_instance)
mixer_circuit.update_qubits_label(qaoa_converter.int2varlabel)
plot_quantum_circuit(mixer_circuit)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_14_0.png)
    



```python
initial_circuit.append(qaoa_cost_circuit)
initial_circuit.append(mixer_circuit)

alternating_ansatz = initial_circuit

plot_quantum_circuit(alternating_ansatz)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_15_0.png)
    


## Run Quantum Alternating Operator Ansatz using Qiskit


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(alternating_ansatz)
qk_cost = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []

def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data["evs"]
    cost_history.append(cost)
    return cost


result = opt.minimize(
    estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 100}
)
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: 2.0625000215201315
           x: [ 7.853e-01  1.102e+00]
        nfev: 34
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_19_0.png)
    



```python
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
plt.show()
job = sampler.run([(qk_circuit, result.x)])
job_result = job.result()
```


```python
sampleset = qaoa_converter.decode(qk_transpiler, job_result[0].data['meas'])
```


```python
import numpy as np
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.experimental.SampleSet):
    # extract feasible solution
    feasibles = sampleset.feasibles()
    if len(feasibles) == 0:
        print("No feasible solution found ...")
    else:
        lowest_sample = sampleset.lowest()[0]

        # get indices of x = 1
        indices = lowest_sample.var_values["x"].values.keys()
        # get vertices and colors
        # initialize vertex color list
        node_colors = [-1] * graph.number_of_nodes()
        # set color list for visualization
        colorlist = ["gold", "violet", "limegreen", "darkorange"]
        # set vertex color list
        for i, j in indices:
            node_colors[i] = colorlist[j]
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)
        plt.show()

plot_graph_coloring(G, sampleset)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_22_0.png)
    


# References
[[1] Farhi, Edward, Jeffrey Goldstone, and Sam Gutmann. "A quantum approximate optimization algorithm." arXiv preprint arXiv:1411.4028 (2014).](https://arxiv.org/abs/1411.4028)

[[2] Hadfield, Stuart, Zhihui Wang, Bryan O’gorman, Eleanor G. Rieffel, Davide Venturelli, and Rupak Biswas. "From the quantum approximate optimization algorithm to a quantum alternating operator ansatz." Algorithms 12, no. 2 (2019): 34.](https://arxiv.org/abs/1709.03489)
# Advanced techniques for Quantum Optimization

## Tutorials

- [Quantum Alternating Operator Ansatz for Graph Coloring](graph_coloring_alternating_ansatz.ipynb): Learn how to run the Quantum Alternating Operator Ansatz for graph coloring problem.
- [Quantum Random Access Optimization (QRAO) for Maxcut problem](qrao_tutorial.ipynb): Learn how to use Quantum Random Access Optimization.
# Quantum Random Access Optimization (QRAO) for Maxcut problem

In this tutorial, we will explain the quantum optimization algorithm called Quantum Random Access Optimization (QRAO)[1].

In the usual QAOA ($(1,1,1)$-QRAO), the optimization problem is encoded in the Ising Hamiltonian. 
In this case, the problem Hamiltonian uses only the Pauli $Z$ operator, but in QRAO, the problem Hamiltonian is constructed using not only Pauli $Z$, but also Pauli $X$ and $Y$.
The Hamiltonian constructed by QRAO is called a relaxed Hamiltonian because the ground state of the relaxed Hamiltonian is not the optimal solution to the original problem.

Several QRAOs have been proposed. The following QRAOs are supported by Qamomile.

| algorithm name | `class name` |
| ---- | ---- |
| $(3,1,p)$-QRAO [1] | [`QRAC31Converter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao31/index.html) |
| $(2,1,p)$-QRAO [1] | [`QRAC21Converter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao21/index.html) |
| $(3,2,p)$-QRAO [2] | [`QRAC32Converter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao32/index.html) |
| Space Compression Ratio Preserving QRAO [2] | [`QRACSpaceEfficientConverter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao_space_efficient/index.html) |

The API documentation explains how each algorithm constructs a relaxed Hamiltonian.


```python
import networkx as nx
import matplotlib.pyplot as plt
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile.core as qm
import qamomile.qiskit as qm_qk
```

# Create problem data and mathematical model
First, we will create the problem data to be solved.

Here, we will solve the maxcut problem for a 3-regular graph, in the same way as [1].


```python
def Maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e,  (1 - si * sj))
    problem += obj
    return problem

problem = Maxcut_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Maxcut} & & \\& & \max \quad \displaystyle 0.5 \cdot \sum_{e \in E} \left(- s_{e[0]} \cdot s_{e[1]} + 1\right) & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



We will create a problem with 12 nodes.


```python
graph = nx.random_regular_graph(3, 12)
nx.draw(graph, with_labels=True)
```


    
![png](qrao_tutorial_files/qrao_tutorial_5_0.png)
    


# Create QRAO Hamiltonian
From here, we will create the relaxed Hamiltonian for QRAO.

First, use `jijmodeling_transpiler` to create a compiled_instance


```python
compiled_instance = jmt.compile_model(problem, {"E": list(graph.edges), "V": len(graph.nodes)})
```

Next, use `QRAC31Converter` to create a relaxed Hamiltonian.


```python
from qamomile.core.converters.qrao.qrao31 import QRAC31Converter

# Initialize with a compiled optimization problem instance
qrao_converter = QRAC31Converter(compiled_instance, normalize_model=False)

# Generate relaxed Hamiltonian
qrao31_hamiltonian = qrao_converter.get_cost_hamiltonian()
qrao31_hamiltonian
```




    Hamiltonian((Z0, Z1): 1.5, (Z0, Z2): 1.5, (Z0, X2): 1.5, (Z1, X2): 1.5, (Z1, Z2): 1.5, (X0, X1): 1.5, (X0, Y1): 1.5, (X0, Z3): 1.5, (Y0, X1): 1.5, (X1, Y2): 1.5, (Y2, Z3): 1.5, (Y2, X3): 1.5, (Z2, Z3): 1.5, (Y1, Z4): 1.5, (Y0, Z4): 1.5, (X3, Z4): 1.5, (Y1, X2): 1.5, (Y0, X3): 1.5)



Since we will use VQE in QRAO, we will create an VQE ansatz.
We can create a simple ansatz using `create_efficient_su2_circuit`.


```python
from qamomile.core.ansatz.efficient_su2 import create_efficient_su2_circuit
from qamomile.core.circuit.drawer import plot_quantum_circuit

ansatz = create_efficient_su2_circuit(qrao31_hamiltonian.num_qubits, rotation_blocks = ["ry", "rz"], reps = 1)
plot_quantum_circuit(ansatz)
```


    
![png](qrao_tutorial_files/qrao_tutorial_11_0.png)
    


Above qamomile Hamiltonian and circuit can be converted into Qiskit Hamiltonian and circuit using `QiskitTranspiler`


```python
qk_transpiler = qm_qk.QiskitTranspiler()
qk_ansatz = qk_transpiler.transpile_circuit(ansatz)
qk_qrao31_hamiltonian = qk_transpiler.transpile_hamiltonian(qrao31_hamiltonian)
```

You can also create QAOA Hamiltonian using `QAOAConverter`.



```python
from qamomile.core.converters.qaoa import QAOAConverter
qaoa_hamiltonian = QAOAConverter(compiled_instance, normalize_model=False).get_cost_hamiltonian()
qk_qaoa_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
```


```python
print("The compression ratio of this problem is ", qaoa_hamiltonian.num_qubits / qrao31_hamiltonian.num_qubits)
```

    The compression ratio of this problem is  2.4


# Obtain grand state of the relaxed Hamiltonian
We have created the relaxed Hamiltonian and VQE ansatz, so let us run VQE using qiskit.



```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_ansatz, qk_qrao31_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

initial_params = np.random.uniform(0, np.pi, len(qk_ansatz.parameters))

# Run QAOA optimization
result = minimize(
    cost_estimator,
    initial_params,
    method="COBYLA",
    options={"maxiter": 10000},
)
print(result)
```

     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -9.4649972737437
           x: [ 3.075e+00  1.912e+00 ... -3.416e-03  4.928e-05]
        nfev: 10000
       maxcv: 0.0


Let's also check the optimal value using diagonalization and plot them.


```python
from scipy.sparse.linalg import eigsh

qrao_eigvals = eigsh(qk_qrao31_hamiltonian.to_matrix(), k=1, which='SA', return_eigenvectors=False)
qaoa_eigvals = eigsh(qk_qaoa_hamiltonian.to_matrix(), k=1, which='SA', return_eigenvectors=False)
```


```python
plt.plot(- (np.array(cost_history) + qrao31_hamiltonian.constant), label = "VQE")
plt.hlines(-(qrao_eigvals + qrao31_hamiltonian.constant), 0, len(cost_history), linestyles="dashed", label="Optimal Quantum Relaxed Value",colors="red")
plt.hlines(-(qaoa_eigvals + qrao31_hamiltonian.constant), 0, len(cost_history), linestyles="dashed", label="Optimal Binary Solution",colors="black")
plt.xlabel("Iteration")
plt.ylabel("Objective Value")
plt.xscale("log")
plt.legend(loc="lower right")
plt.show()
```


    
![png](qrao_tutorial_files/qrao_tutorial_21_0.png)
    


This is quite similar to Fig. 2 in [1].

# Pauli Rounding

As we mentioned, the ground state of the relaxed Hamiltonian is not classical optimal solution.
We need the rounding algorithm to decode the classical solution from the quantum state.

[1] proposed two rounding algorithms, Pauli Rounding and Magic State Rounding.
In this tutorial, we use Puali Rounding to decode the classical solution.

We can get Pauli Operators list using `get_encoded_pauli_list`.
The order of the Pauli operators corresponds to the order of the corresponding encoded variables.


```python
pauli_list = qrao_converter.get_encoded_pauli_list()
print(pauli_list)
```

    [Hamiltonian((Z0,): 1.0), Hamiltonian((Z1,): 1.0), Hamiltonian((Z2,): 1.0), Hamiltonian((X2,): 1.0), Hamiltonian((X0,): 1.0), Hamiltonian((X1,): 1.0), Hamiltonian((Y1,): 1.0), Hamiltonian((Z3,): 1.0), Hamiltonian((Y0,): 1.0), Hamiltonian((Y2,): 1.0), Hamiltonian((X3,): 1.0), Hamiltonian((Z4,): 1.0)]


We can calculate the expecation value of this.


```python
qiskit_pauli_list = [qk_transpiler.transpile_hamiltonian(pauli) for pauli in pauli_list]

estimator = qk_pr.StatevectorEstimator()
job = estimator.run([(qk_ansatz, pauli, result.x) for pauli in qiskit_pauli_list])
rounded_values = [np.sign(_res.data['evs']) for _res in job.result()]
binary_values = [(1 - _val) // 2 for _val in rounded_values]
binary_values
```




    [0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0]



We can map this bianry variable result into `sampleset` using `decode_bits_to_sampleset`.


```python
bitsample = qm.BitsSample(1,binary_values)
sampleset = qrao_converter.decode_bits_to_sampleset(qm.BitsSampleSet([bitsample]))
```

Finally, we have result!
Let us visualize it.


```python
def get_edge_colors(
    graph, cut_solution, in_cut_color="r", not_in_cut_color="b"
):
    cut_set_1 = [node[0] for node, value in cut_solution.items() if value == 1.0]
    cut_set_2 = [node for node in graph.nodes() if node not in cut_set_1]

    edge_colors = []
    for u, v, _ in graph.edges(data=True):
        if (u in cut_set_1 and v in cut_set_2) or (u in cut_set_2 and v in cut_set_1):
            edge_colors.append(in_cut_color)
        else:
            edge_colors.append(not_in_cut_color)
    node_colors = ["#2696EB" if node in cut_set_1 else "#EA9b26" for node in graph.nodes()]
    return edge_colors, node_colors
```


```python
best_values = sampleset[0].var_values["x"].values
edge_colors, node_colors = get_edge_colors(graph, best_values)
edge_labels = nx.get_edge_attributes(graph, "weight")

plt.title("G=(V,E) QAOA")
plt.plot(figsize=(5, 4))
nx.draw_networkx(
    graph,
    node_size=500,
    width=3,
    with_labels=True,
    edge_color=edge_colors,
    node_color=node_colors,
)

```


    
![png](qrao_tutorial_files/qrao_tutorial_32_0.png)
    


# References
[1] Bryce Fuller, Charles Hadfield, Jennifer R. Glick, Takashi Imamichi, Toshinari Itoko, Richard J. Thompson, Yang Jiao, Marna M. Kagele, Adriana W. Blom-Schieber, Rudy Raymond, and Antonio Mezzacapo. Approximate solutions of combinatorial problems via quantum relaxations. IEEE Transactions on Quantum Engineering, 5():1–15, 2024. doi:10.1109/TQE.2024.3421294.

[2] Kosei Teramoto, Rudy Raymond, Eyuri Wakakuwa, and Hiroshi Imai. Quantum-relaxation based optimization algorithms: theoretical extensions. 2023. URL: https://arxiv.org/abs/2302.09481, arXiv:2302.09481.
# Quantum Alternating Operator Ansatz for Graph Coloring Problem with Qiskit and Quri-Parts
In this tutorial, we would like to explain the functionality while solving the Graph Coloring Problem using the Quantum Approximate Optimization Algorithm and the Quantum Alternating Operator Ansatz. This time, we are going to conduct simulations using qiskit and quri-parts.


```python
import networkx as nx
import scipy.optimize as opt
import numpy as np
import qiskit.primitives as qk_pr

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt

import qamomile.core as qm
from qamomile.qiskit import QiskitTranspiler
from qamomile.core.circuit.drawer import plot_quantum_circuit
```

First, we will implement the mathematical model of the graph coloring problem using JijModeling.


```python
def graph_coloring_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    N = jm.Placeholder("N")
    x = jm.BinaryVar("x", shape=(V, N))
    n = jm.Element("i", belong_to=(0, N))
    v = jm.Element("v", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)
    # set problem
    problem = jm.Problem("Graph Coloring")
    # set one-hot constraint that each vertex has only one color

    problem += jm.Constraint("one-color", x[v, :].sum() == 1, forall=v)
    # set objective function: minimize edges whose vertices connected by edges are the same color
    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])
    return problem

problem = graph_coloring_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Coloring} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 1} \sum_{e \in E} x_{e_{0}, i} \cdot x_{e_{1}, i} & \\\text{{s.t.}} & & & \\ & \text{one-color} & \displaystyle \sum_{\ast_{1} = 0}^{N - 1} x_{v, \ast_{1}} = 1 & \forall v \in \left\{0,\ldots,V - 1\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will create an instance of the problem.


```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])
nx.draw(G)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_5_0.png)
    



```python
inst_E = [list(edge) for edge in G.edges]
color_num = 3
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "N": color_num, "E": inst_E}
num_qubits = num_nodes * color_num
```

# Quantum Approximate Optimazation Algorithm (QAOA)
The Quantum Approximate Optimization Algorithm (QAOA) is one of the quantum optimization algorithms that use a variational quantum circuit. For a detailed explanation, please refer to paper [1], but here we will only give a rough overview.
In QAOA, a variational quantum circuit is constructed by applying the Ising Hamiltonian $H_P = \sum_{ij}J_{ij}Z_iZ_j$ and the $X$-mixer Hamiltonian $H_M = \sum_iX_i$ in the following way:
If we start with an initial state $\ket{\psi_0}$, then

$$
\ket{\psi(\beta,\gamma)} = e^{-i\beta_pH_M}e^{-i\gamma_pH_P}\cdots e^{-i\beta_1H_M}e^{-i\gamma_1H_P}\ket{\psi_0}
$$

can be written. Here, $\beta_k,\gamma_k$ are the parameters to be optimized, and since the operation $e^{-\beta_kH_M}e^{-\gamma_kH_P}$ is repeated $p$ times, there are a total of $2p$ parameters. In the standard QAOA, the total number of parameters is independent of the number of qubits and depends only on the number of repetitions.

Optimization of $\beta_k,\gamma_k$ is performed by repeating the following steps 1 and 2:

1. Compute the expectation value $\bra{\psi(\beta,\gamma)}H_P\ket{\psi(\beta,\gamma)}$ on a quantum device.
2. Update the parameters on a classical computer to minimize the expectation value.

By repeating this calculation of the expectation value on the quantum computer and optimization of parameters on the classical computer, we obtain the minimum energy $\langle H_P \rangle$ and the corresponding final state. If we consider QAOA as a mathematical optimization algorithm, this minimum energy corresponds to the minimum objective function value, and the final state becomes the optimal solution.

## Implementing QAOA using Qamomile
Now, let's try solving the Graph Coloring Problem using QAOA.
To execute QAOA, it's necessary to convert the mathematical model into an Ising Hamiltonian, and then create a variational quantum circuit and Hamiltonian using a quantum computing library. However, since Qamomile supports QAOA, it allows for relatively easy execution.

First, using JijModeling-Transpiler, we create a CompiledInstance from JijModeling's mathematical model and instance data.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

Next, we create a QAOAConverter. By setting the weight for the constraints on this Converter, we can create the Hamiltonian.


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode(multipliers={"one-color": 1})
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=1)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


```python
plot_quantum_circuit(qaoa_circuit)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_12_0.png)
    


## Run QAOA using Qiskit

Now that we have the variational quantum circuit and Hamiltonian ready, let's actually execute QAOA using Qiskit.  
Transpile the qamomile's circuit to the qiskit's circuit and run the simulation.


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_cost = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []
def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data['evs']
    cost_history.append(cost)
    return cost

result = opt.minimize(estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 100})
result
```




     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: 5.889501085009066
           x: [ 9.116e-01 -6.631e-01]
        nfev: 100
       maxcv: 0.0




```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_16_0.png)
    


# Quantum Alternating Operator Ansatz
Next, let's try solving the graph coloring problem using the Quantum Alternating Operator Ansatz. The Quantum Alternating Operator Ansatz[2] is a modification of QAOA, where the mixer is changed from an $X$-mixer to a mixer tailored to the problem, ensuring that only solutions satisfying the constraints are searched for. For more detailed information, please refer to the original paper. Here, we will look at how to implement it in JTQ.

For the Graph Coloring problem, there is a one-hot constraint:

$$
\sum_k x_{v,k} = 1\quad \forall v
$$

However, turning this into an $XY$-mixer is the Quantum Alternating Operator Ansatz approach to the Graph Coloring problem.


```python
gamma_1 = qm.circuit.Parameter("gamma_1")
# Delete one-color penalty.
qaoa_converter.ising_encode(multipliers={"one-color": 0.0})
# Get exp(-i gamma H_P) circuit without mixer circuit.  
qaoa_cost_circuit = qaoa_converter.get_cost_ansatz(gamma_1)
```

Next, we will create an $XY$-mixer. The $XY$-mixer can be written as

$$
XY_{ij} = \frac{1}{2}\left(X_iX_j + Y_iY_j \right).
$$

This is an operator that swaps the bits 1 and 0 in bit $i,j$. Therefore, it can transform a bit string $100$, which satisfies the one-hot constraint, into another bit string $010$, which also satisfies the one-hot constraint.

Here, the only part under the one-hot constraint is related to color, so in terms of the mathematical model, we need to transform the bits between $x_{v0}$ and $x_{v1}$.
On the other hand, as these variables are usually embedded in qubits, it is necessary to remember which bit corresponds to which variable when constructing the algorithm and handle them appropriately.
In JTQ, the correspondence of variables is contained in var_map inside CompiledInstance.
```python
var_map['variable_name'][indices]
```
You can check which qubit corresponds to a variable in the mathematical model in this way.
Let's use this to create an $XY$-mixer.

What we want here is the transformation between $x_{v,k}$ and $x_{v,k+1}$, so we can obtain the index of the corresponding qubit by accessing compiled_instance.var_map.var_map["x"][(i,k)]."


```python
def create_xy_mixer(
    beta: qm.circuit.Parameter,
    num_nodes: int,
    num_color: int,
    compiled_instance: jmt.CompiledInstance,
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n, name="XY-mixer")
    var_map = compiled_instance.var_map.var_map["x"]
    # even
    for i in range(num_nodes):
        for k in range(0, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # odd
    for i in range(num_nodes):
        for k in range(1, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # ini-last
    if num_color % 2 == 1:
        for i in range(num_nodes):
            qc.rxx(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
            qc.ryy(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
    return qc
```


```python
def create_initial_state(
    compiled_instance: jmt.CompiledInstance, num_nodes: int, num_color: int
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n)
    var_map = compiled_instance.var_map.var_map["x"]
    for i in range(num_nodes):
        qc.x(var_map[(i, 0)])  # set all nodes to color 0
    return qc
```

Now that the Ansatz has been created, we would like to run the Quantum Alternating Operator Ansatz.


```python
initial_circuit = create_initial_state(compiled_instance, num_nodes, color_num)
initial_circuit.update_qubits_label(qaoa_converter.int2varlabel)
beta_1 = qm.circuit.Parameter("beta_1")
mixer_circuit = create_xy_mixer(beta_1, num_nodes, color_num, compiled_instance)
mixer_circuit.update_qubits_label(qaoa_converter.int2varlabel)
plot_quantum_circuit(mixer_circuit)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_23_0.png)
    



```python
initial_circuit.append(qaoa_cost_circuit)
initial_circuit.append(mixer_circuit)

alternating_ansatz = initial_circuit

plot_quantum_circuit(alternating_ansatz)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_24_0.png)
    


## Run Quantum Alternating Operator Ansatz using Qiskit


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(alternating_ansatz)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []

def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data["evs"]
    cost_history.append(cost)
    return cost


result = opt.minimize(
    estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 100}
)
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -7.43749997649938
           x: [ 7.855e-01 -1.425e-01]
        nfev: 31
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_28_0.png)
    



```python
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
plt.show()
job = sampler.run([(qk_circuit, result.x)])
job_result = job.result()
```


```python
sampleset = qaoa_converter.decode(qk_transpiler, job_result[0].data['meas'])
```


```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.experimental.SampleSet):
    # extract feasible solution
    feasibles = sampleset.feasibles()
    if len(feasibles) == 0:
        print("No feasible solution found ...")
    else:
        lowest_sample = sampleset.lowest()[0]

        # get indices of x = 1
        indices = lowest_sample.var_values["x"].values.keys()
        # get vertices and colors
        # initialize vertex color list
        node_colors = [-1] * graph.number_of_nodes()
        # set color list for visualization
        colorlist = ["gold", "violet", "limegreen", "darkorange"]
        # set vertex color list
        for i, j in indices:
            node_colors[i] = colorlist[j]
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)
        plt.show()

plot_graph_coloring(G, sampleset)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_31_0.png)
    


## Alternating Ansatz with Quri-Parts


```python
# !pip install quri-parts-algo
```


```python
from qamomile.quri_parts import QuriPartsTranspiler
```


```python
from quri_parts.circuit.utils.circuit_drawer import draw_circuit

qp_transpiler = QuriPartsTranspiler()
qp_alternating_circuit = qp_transpiler.transpile_circuit(alternating_ansatz)
qp_cost = qp_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
from quri_parts.core.state import quantum_state, apply_circuit

cb_state = quantum_state(alternating_ansatz.num_qubits, bits=0)
parametric_state = apply_circuit(qp_alternating_circuit, cb_state)
```


```python
from typing import Sequence
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator

estimator = create_qulacs_vector_parametric_estimator()


cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(qp_cost, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost


result = opt.minimize(cost_fn, [0, 0], method="COBYLA", options={"maxiter": 100})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -7.437499976499405
           x: [-1.831e-03  7.855e-01]
        nfev: 35
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_38_0.png)
    



```python
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler


sampler = create_qulacs_vector_sampler()
bounded_circuit = qp_alternating_circuit.bind_parameters(result.x)
qp_result = sampler(bounded_circuit, 1000)
```


```python
sampleset = qaoa_converter.decode(qp_transpiler, (qp_result, alternating_ansatz.num_qubits))
```


```python
plot_graph_coloring(G, sampleset)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_41_0.png)
    


# References
[[1] Farhi, Edward, Jeffrey Goldstone, and Sam Gutmann. "A quantum approximate optimization algorithm." arXiv preprint arXiv:1411.4028 (2014).](https://arxiv.org/abs/1411.4028)

[[2] Hadfield, Stuart, Zhihui Wang, Bryan O’gorman, Eleanor G. Rieffel, Davide Venturelli, and Rupak Biswas. "From the quantum approximate optimization algorithm to a quantum alternating operator ansatz." Algorithms 12, no. 2 (2019): 34.](https://arxiv.org/abs/1709.03489)
# QAOA for the Vertex Cover

In this section, we will solve the Vertex Cover Problem using QAOA with the help of the `JijModeling` and `Qamomile` libraries.

First, let's install and import the main libraries we will be using.



```python
# !pip install qamomile[qiskit,quri-parts]
# !pip install pylatexenc
```


```python
import qamomile.core as qm
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
import matplotlib.pyplot as plt
```

## The Vertex Cover Problem

First, let's review the definition of the Vertex Cover Problem. In an undirected graph $G = (V, E)$, a vertex set $S \subseteq V$ is called a vertex cover if for every edge $e = (i, j) \in E$, either $i \in S$ or $j \in S$ holds. The Vertex Cover Problem is the problem of finding a vertex cover $S$ with the smallest possible number of elements.

As an example, consider the minimum vertex cover of the following graph. Let $S = \{0, 1\}$. In this case, every edge of the graph has at least one in either vertex $0$ or vertex $1$, so $S$ is a vertex cover set. Furthermore, in the graph we are considering, there is no vertex cover $S$ with only one element, so $\{0, 1\}$ is indeed the minimum vertex cover.



```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4)])
positions = nx.spring_layout(G)
color = ["#2696EB"] * 5
color[0] = color[1] = "#EA9b26"
nx.draw(G, node_color=color, pos=positions, with_labels=True)
```


    
![png](vertex_cover_files/vertex_cover_4_0.png)
    


## Formulation of the Vertex Cover Problem

Let's consider the formulation of the Vertex Cover Problem.

We define a binary variable $x_i$ such that $x_i = 1$ if vertex $i$ is included in $S$, and $x_i = 0$ otherwise. The objective function, which represents the size of $S$, can be expressed as follows.

$$
\sum_{i \in V} x_i
$$


The constraint is that all edges must be covered, meaning that for each edge, at least one of its endpoints must be included in $S$. This can be formulated as:

$$
x_{e_0} + x_{e_1} \geq 1 \quad \forall e \in E
$$


In summary, the Vertex Cover Problem can be formulated as follows:

$$
\begin{align}
&\min \sum_{i \in V} x_i \\
\text{s.t. } &x_{e_0} + x_{e_1} \geq 1 \quad \forall e \in E
\end{align}
$$

## Creating Problem Model using JijModeling

We describe the above formulation and then using JijModeling to create the problem model. `Placeholder` defines the values to be substituted as data, `BinaryVar` defines the decision variables, and `Element` defines the indices used in the summation. By checking the output, we can confirm that the formulation is correct.



```python
def vertex_cover_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    i = jm.Element("i", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)

    # set problem
    problem = jm.Problem("Vertex Cover Problem")
    # ensure that at least one vertex of each edge is included in the cover
    problem += jm.Constraint("cover", x[e[0]] + x[e[1]] >= 1, forall=e)
    # minimize the number of vertices included in the cover
    problem += jm.sum(i, x[i])

    return problem


problem = vertex_cover_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Vertex Cover Problem} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{V - 1} x_{i} & \\\text{{s.t.}} & & & \\ & \text{cover} & \displaystyle x_{e_{0}} + x_{e_{1}} \geq 1 & \forall e \in E \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



## Preparing Instance Data
Next, we will solve the Vertex Cover Problem for the following graph. The data for the specific problem being solved is referred to as instance data.



```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
G.add_edges_from(
    [
        (0, 6),
        (0, 5),
        (1, 5),
        (2, 5),
        (3, 8),
        (4, 9),
        (4, 7),
        (5, 7),
        (6, 7),
        (7, 8),
        (8, 9),
    ]
)
positions = nx.spring_layout(G)
color = ["#2696EB"] * G.number_of_nodes()
nx.draw(G, node_color=color, pos=positions, with_labels=True)
```


    
![png](vertex_cover_files/vertex_cover_11_0.png)
    



## Creating a Compiled Instance

We perform compilation using the JijModeling-Transpiler by providing the formulation and the instance data prepared earlier. This process yields an intermediate representation of the problem with the instance data substituted.



```python
inst_E = [list(edge) for edge in G.edges]
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "E": inst_E}
num_qubits = num_nodes
compiled_instance = jmt.compile_model(problem, instance_data)
```

## Converting Compiled Instance to QAOA Circuit and Hamiltonian

We generate the QAOA circuit and Hamiltonian from the compiled Instance. The converter used to generate these is `qm.qaoa.QAOAConverter`.

By creating an instance of this class and using `ising_encode`, you can internally generate the Ising Hamiltonian from the compiled Instance. Parameters that arise during the conversion to QUBO can also be set here. If not set, default values are used.

Once the Ising Hamiltonian is generated, you can generate the QAOA quantum circuit and the Hamiltonian respectively. These can be executed using the `get_qaoa_ansatz` and `get_cost_hamiltonian` methods. The number of QAOA layers, $p$, is fixed to be $4$ here.   


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
# Encode to Ising Hamiltonian
qaoa_converter.ising_encode()
# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=3)
# Get the cost Hamiltonian
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
```

## Visualization of QAOA Circuit
Qamomile provides a method to visualize the quantum circuit. You can use the `plot_quantum_circuit` function to visualize the QAOA quantum circuit.


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](vertex_cover_files/vertex_cover_17_0.png)
    


## Converting the Obtained QAOA Circuit and Hamiltonian for Qiskit

Here, we generate the Qiskit's QAOA circuit and Hamiltonian using the `qamomile.qiskit.QiskitTranspiler` converters. By utilizing the two methods,`QiskitTranspiler.transpile_circuit` and `QiskitTranspiler.transpile_hamiltonian`, we can transform the QAOA circuit and Hamiltonian into a format compatible with Qiskit. This allows us to leverage Qiskit's quantum computing framework to execute and analyze.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()
# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
# Transpile the QAOA Hamiltonian to Qiskit
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIIIIIIIZ', 'IIIIIZIIII', 'IIIIZIIIII', 'IIIZIIIIII', 'IIZIIIIIII', 'IZIIIIIIII', 'ZIIIIIIIII', 'IIIZIIIIIZ', 'IIIIZIIIIZ', 'IIIIZIIIZI', 'IIIIZIIZII', 'IZIIIIZIII', 'ZIIIIZIIII', 'IIZIIZIIII', 'IIZIZIIIII', 'IIZZIIIIII', 'IZZIIIIIII', 'ZZIIIIIIII'],
                  coeffs=[0.5+0.j, 0.5+0.j, 1.5+0.j, 0.5+0.j, 1.5+0.j, 1. +0.j, 0.5+0.j, 0.5+0.j,
     0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j,
     0.5+0.j, 0.5+0.j])



## Running QAOA

We run QAOA to optimize the parameters. Here, we use COBYLA as the optimizer.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
estimator = qk_pr.StatevectorEstimator()


# Cost estimator function
def estimate_cost(param_values):
    try:
        job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
        result = job.result()[0]
        cost = result.data["evs"]
        cost_history.append(cost)
        return cost
    except Exception as e:
        print(f"Error during cost estimation: {e}")
        return np.inf


# Initial parameters for QAOA
initial_params = [
    np.pi / 8,
    np.pi / 4,
    3 * np.pi / 8,
    np.pi / 2,
    np.pi / 2,
    3 * np.pi / 8,
]

# Run QAOA optimization with COBYLA
result = minimize(
    estimate_cost,
    initial_params,
    method="COBYLA",
    options={"maxiter": 1500},
)

print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -3.8319489423814184
           x: [ 7.111e-01  8.882e-02  1.106e+00  2.621e+00  2.031e+00
                1.371e+00]
        nfev: 321
       maxcv: 0.0


## Result Visualization

By repeating the optimization, we can observe that the energy decreases and converges.



```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](vertex_cover_files/vertex_cover_23_0.png)
    


Now, let's run the Optimized paremeter on qiskit `StatevectorSampler`.


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results

From the job counts obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.



```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.5)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()
```


    
![png](vertex_cover_files/vertex_cover_27_0.png)
    


## Plotting the Solution

From the obtained results, we select one solution that minimizes the objective function value and plot it. (The orange vertices are the vertices included in the vertex cover.)



```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):
    # extract feasible solution
    lowests = sampleset.lowest()
    if len(lowests) == 0:
        print("No feasible solution found ...")
    else:
        best_sol = lowests[0]

        # initialize vertex color list
        node_colors = ["#2696EB"] * instance_data["V"]
        # set vertex color
        for t in best_sol.var_values["x"].values.keys():
            node_colors[t[0]] = "#EA9b26"
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, pos=positions, with_labels=True)
        plt.show()


plot_graph_coloring(G, sampleset)
```


    
![png](vertex_cover_files/vertex_cover_29_0.png)
    


Indeed, we can see that a vertex cover has been obtained.
# QAOA for Graph Coloring Problem
In this tutorial, we will solve the Graph Coloring Problem using the Quantum Approximate Optimization Algorithm (QAOA).


```python
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as opt
import networkx as nx
import qiskit.primitives as qk_pr

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt

import qamomile.core as qm
from qamomile.qiskit import QiskitTranspiler
from qamomile.core.circuit.drawer import plot_quantum_circuit
```

First, we will implement the mathematical model of the graph coloring problem using JijModeling.


```python
def graph_coloring_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    N = jm.Placeholder("N")
    x = jm.BinaryVar("x", shape=(V, N))
    n = jm.Element("i", belong_to=(0, N))
    v = jm.Element("v", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)
    # set problem
    problem = jm.Problem("Graph Coloring")
    # set one-hot constraint that each vertex has only one color

    problem += jm.Constraint("one-color", x[v, :].sum() == 1, forall=v)
    # set objective function: minimize edges whose vertices connected by edges are the same color
    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])
    return problem

problem = graph_coloring_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Coloring} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 1} \sum_{e \in E} x_{e_{0}, i} \cdot x_{e_{1}, i} & \\\text{{s.t.}} & & & \\ & \text{one-color} & \displaystyle \sum_{\ast_{1} = 0}^{N - 1} x_{v, \ast_{1}} = 1 & \forall v \in \left\{0,\ldots,V - 1\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will create an instance of the problem.


```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])
nx.draw(G)
```


    
![png](graph_coloring_files/graph_coloring_5_0.png)
    



```python
inst_E = [list(edge) for edge in G.edges]
color_num = 3
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "N": color_num, "E": inst_E}
num_qubits = num_nodes * color_num
```

# Quantum Approximate Optimazation Algorithm (QAOA)
The Quantum Approximate Optimization Algorithm (QAOA) is one of the quantum optimization algorithms that use a variational quantum circuit. For a detailed explanation, please refer to paper [1], but here we will only give a rough overview.
In QAOA, a variational quantum circuit is constructed by applying the Ising Hamiltonian $H_P = \sum_{ij}J_{ij}Z_iZ_j$ and the $X$-mixer Hamiltonian $H_M = \sum_iX_i$ in the following way:
If we start with an initial state $\ket{\psi_0}$, then

$$
\ket{\psi(\beta,\gamma)} = e^{-i\beta_pH_M}e^{-i\gamma_pH_P}\cdots e^{-i\beta_1H_M}e^{-i\gamma_1H_P}\ket{\psi_0}
$$

can be written. Here, $\beta_k,\gamma_k$ are the parameters to be optimized, and since the operation $e^{-\beta_kH_M}e^{-\gamma_kH_P}$ is repeated $p$ times, there are a total of $2p$ parameters. In the standard QAOA, the total number of parameters is independent of the number of qubits and depends only on the number of repetitions.

Optimization of $\beta_k,\gamma_k$ is performed by repeating the following steps 1 and 2:

1. Compute the expectation value $\bra{\psi(\beta,\gamma)}H_P\ket{\psi(\beta,\gamma)}$ on a quantum device.
2. Update the parameters on a classical computer to minimize the expectation value.

By repeating this calculation of the expectation value on the quantum computer and optimization of parameters on the classical computer, we obtain the minimum energy $\langle H_P \rangle$ and the corresponding final state. If we consider QAOA as a mathematical optimization algorithm, this minimum energy corresponds to the minimum objective function value, and the final state becomes the optimal solution.

## Implementing QAOA using Qamomile
Now, let's try solving the Graph Coloring Problem using QAOA.
To execute QAOA, it's necessary to convert the mathematical model into an Ising Hamiltonian, and then create a variational quantum circuit and Hamiltonian using a quantum computing library. However, since Qamomile supports QAOA, it allows for relatively easy execution.

First, using JijModeling-Transpiler, we create a CompiledInstance from JijModeling's mathematical model and instance data.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

Next, we create a QAOAConverter. By setting the weight for the constraints on this Converter, we can create the Hamiltonian.


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode(multipliers={"one-color": 5})
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=1)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](graph_coloring_files/graph_coloring_12_0.png)
    


## Run QAOA using Qiskit

Now that we have the variational quantum circuit and Hamiltonian ready, let's actually execute QAOA using Qiskit.  
Transpile the qamomile's circuit to the qiskit's circuit and run the simulation.


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_cost = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []
def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data['evs']
    cost_history.append(cost)
    return cost

result = opt.minimize(estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 1000})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: 2.8539634674558334
           x: [ 4.544e-01 -3.551e-01]
        nfev: 409
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_coloring_files/graph_coloring_16_0.png)
    



```python
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
plt.show()
job = sampler.run([(qk_circuit, result.x)], shots=10000)
job_result = job.result()
```


```python
sampleset = qaoa_converter.decode(qk_transpiler, job_result[0].data['meas'])
```


```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.experimental.SampleSet):
    # extract feasible solution
    feasibles = sampleset.feasibles()
    if len(feasibles) == 0:
        print("No feasible solution found ...")
    else:
        lowest_sample = sampleset.lowest()[0]

        # get indices of x = 1
        indices = lowest_sample.var_values["x"].values.keys()
        # get vertices and colors
        # initialize vertex color list
        node_colors = [-1] * graph.number_of_nodes()
        # set color list for visualization
        colorlist = ["gold", "violet", "limegreen", "darkorange"]
        # set vertex color list
        for i, j in indices:
            node_colors[i] = colorlist[j]
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)
        plt.show()

# Visualize the graph coloring result
plot_graph_coloring(G, sampleset)
```


    
![png](graph_coloring_files/graph_coloring_19_0.png)
    

# Solving Problems with QAOA

## Tutorials

- [Quantum Approximate Optimization Algorithm for Max-Cut](maxcut.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for Max-Cut problem.
- [Quantum Approximate Optimization Algorithm for Graph Partitioning](graph_partition.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for graph partitioning problem.
- [Quantum Approximate Optimization Algorithm for vertex covering](vertex_cover.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for vertex cover problem.
- [Quantum Approximate Optimization Algorithm for Multi-car Paint Shop Problem](multi_car_paint.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for multi-car paint shop problem.
- [Quantum Approximate Optimization Algorithm for Travelling Salesman Problem](Travelling_Salesman_Problem.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for Travelling Salesman Problem.
- [Quantum Approximate Optimization Algorithm for Graph Coloring](graph_coloring.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for graph coloring problem.
# QAOA for Travelling Salesman Problem

In this tutorial, we will demonstrate how to solve a 5-city Travelling Salesman Problem (TSP) using the Quantum Approximate Optimization Algorithm (QAOA). We will utilize Quri-Parts as our simulator to implement and test the algorithm.


```python
import numpy as np
import matplotlib.pyplot as plt
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile.core as qm
```

First, we will formulate the Travelling Salesman Problem (TSP) using JijModeling. We consider a set of cities labeled from ${0, 1, \dots, N-1}$.

To reduce the number of decision variables, we slightly reformulate the problem. We fix the starting city to be city $N-1$ and focus on determining the visiting order of the remaining cities $0, 1, \dots, N-2$.

In this problem setting, our goal is to find the shortest possible route that starts and ends at city $N-1$ while visiting all other cities exactly once.

We define the variables as follows:

- $N$: The total number of cities.
- $d_{u,v}$: The distance from city $u$ to city $v$.
- $x_{u,j}$: A binary variable that equals 1 if city $u$ is visited at the $j$-th position in the tour, and 0 otherwise, where $u = 0, 1, \dots, N-2$ and $j = 0, 1, \dots, N-2$.


```python
def create_tsp_problem():
  N = jm.Placeholder("N")
  D = jm.Placeholder("d", ndim=2)
  x = jm.BinaryVar("x", shape=(N-1, N-1))
  t = jm.Element("t", belong_to=N-2)
  j = jm.Element("j", belong_to=N-1)
  u = jm.Element("u", belong_to=N-1)
  v = jm.Element("v", belong_to=N-1)

  problem = jm.Problem("TSP")

  problem += jm.Constraint("Visit all cities at least once", jm.sum(j ,x[u,j]) == 1, forall=u)
  problem += jm.Constraint("Visit one city at each time", jm.sum(u, x[u,j]) == 1, forall=j)

  problem += jm.sum(u,  D[N-1][u]*(x[u][0] + x[u][N-2])) + jm.sum(t,jm.sum(u, jm.sum(v, D[u][v]*x[u][t]*x[v][t+1])))
  return problem

problem = create_tsp_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{TSP} & & \\& & \min \quad \displaystyle \sum_{u = 0}^{N - 2} d_{N - 1, u} \cdot \left(x_{u, 0} + x_{u, N - 2}\right) + \sum_{t = 0}^{N - 3} \sum_{u = 0}^{N - 2} \sum_{v = 0}^{N - 2} d_{u, v} \cdot x_{u, t} \cdot x_{v, t + 1} & \\\text{{s.t.}} & & & \\ & \text{Visit all cities at least once} & \displaystyle \sum_{j = 0}^{N - 2} x_{u, j} = 1 & \forall u \in \left\{0,\ldots,N - 2\right\} \\ & \text{Visit one city at each time} & \displaystyle \sum_{u = 0}^{N - 2} x_{u, j} = 1 & \forall j \in \left\{0,\ldots,N - 2\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will prepare the instance data for our TSP problem. This involves defining the distances between each pair of cities, which are essential for formulating the cost function and constraints in our model.


```python
N = 5
np.random.seed(3)

num_qubits = (N - 1)**2

x_pos = np.random.rand(N)
y_pos = np.random.rand(N)

plt.scatter(x_pos, y_pos, c='red', s=100, edgecolors='k', zorder=3)
plt.title(f"City", fontsize=15)
plt.xlabel("X Position", fontsize=15)
plt.ylabel("Y Position", fontsize=15)
plt.xlim(0, 1)
plt.ylim(0, 1)
plt.grid(True, linestyle='--', alpha=0.7)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_5_0.png)
    



```python
d = [[0]*N for _ in range(N)]
for i in range(N):
  for j in range(N):
    d[i][j] = np.sqrt((x_pos[i] - x_pos[j])**2 + (y_pos[i] - y_pos[j])**2)

instance_data = {"N": N, "d": d}

num_qubits = (N - 1)**2
```

# Quantum Approximate Optimization Algorithm (QAOA)
We will solve the TSP using the standard Quantum Approximate Optimization Algorithm (QAOA). An overview of QAOA is provided in another tutorial [1], so please refer to that for more details.

First, we will use the JijModeling-Transpiler to generate an model as intermediate representation from our formulated TSP problem and the instance data.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

Next, we will utilize the `QAOAConverter`. We set the weights for the constraint terms and generate the QAOA circuit and Hamiltonian. In this tutorial, we use $p=2$. However, since the performance of QAOA and the Quantum Alternating Operator Ansatz can vary significantly depending on the value of $p$, interested readers are encouraged to try larger values of $p$ (note that computation time will increase).


```python
p = 4
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode(multipliers={"Visit all cities at least once": 42, "Visit one city at each time": 42})
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_11_0.png)
    


# Executing with Quri-Parts
Next, we will convert the circuit and Hamiltonian generated by Qamomile into objects compatible with Quri-Parts. This will enable us to run the quantum algorithm using Quri-Parts as our simulation framework.


```python
from qamomile.quri_parts import QuriPartsTranspiler

qp_transpiler = QuriPartsTranspiler()
qp_circuit = qp_transpiler.transpile_circuit(qaoa_circuit)
qp_cost = qp_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
from quri_parts.core.state import quantum_state, apply_circuit

cb_state = quantum_state(qaoa_circuit.num_qubits, bits=0)
parametric_state = apply_circuit(qp_circuit, cb_state)
```


```python
from typing import Sequence
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator
from scipy import optimize as opt

estimator = create_qulacs_vector_parametric_estimator()

cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(qp_cost, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost

def create_initial_param(p: int) -> list[float]:
    res = []
    # beta
    for i in range(p):
        res.append(np.pi/(2 * (p - i)))
    # gamma
    for i in range(p):
        res.append(np.pi/(2 * (i + 1)))
    return res


param_result = opt.minimize(cost_fn,create_initial_param(p), method="COBYLA", options={"maxiter": 1000})
param_result
```




     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -16.533742755961427
           x: [ 2.202e-01  6.861e-01  4.927e-01  1.213e+00  2.635e+00
                1.836e-01  1.769e-01 -9.130e-02]
        nfev: 1000
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, 120)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_16_0.png)
    



```python
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
bounded_circuit = qp_circuit.bind_parameters(param_result.x)
qp_result = sampler(bounded_circuit, 10000)
```

Finally, we convert the sampled results back into solutions for the original Travelling Salesman Problem.


```python
sampleset = qaoa_converter.decode(qp_transpiler, (qp_result, qaoa_circuit.num_qubits))
```

# Visualizing the Sampled Results
Finally, we display the sampled results using graphs to visualize the solutions obtained from the algorithm. Please note that in some cases, a feasible solution may not be achieved.


```python
from collections import defaultdict
def show_energy_histogram(sampleset):
    # Create a defaultdict to store the frequency of each energy level
    d = defaultdict(int)
    for sample in sampleset.feasibles():
        d[sample.eval.objective] += sample.num_occurrences

    # Extract energy levels and their corresponding frequencies
    energies = list(d.keys())
    num_occurrences = list(d.values())
    
    # Calculate the total number of shots
    shots = 0
    for sample in sampleset.data:
        shots += sample.num_occurrences

    # Sort energies and corresponding occurrences to ensure proper order
    sorted_pairs = sorted(zip(energies, num_occurrences))
    energies, num_occurrences = zip(*sorted_pairs)
    # Plot the histogram with equally spaced bars
    plt.bar(range(len(energies)), num_occurrences, width=0.15, align='center')
    plt.title("Objective Histogram (Number of feasible samples = {0}, shots = {1})".format(sum(num_occurrences), shots), fontsize=15)
    plt.ylabel("Frequency", fontsize=15)
    plt.xlabel("Objective", fontsize=15)
    plt.xticks(range(len(energies)), np.round(energies,3), rotation=45) 
    plt.show()
    
show_energy_histogram(sampleset)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_21_0.png)
    


We got the optimal solution from the sampleset and display the corresponding route.


```python
def plot_tsp(sampleset, x_pos, y_pos, N):
    feasible_samples = sampleset.feasibles()
    
    if len(feasible_samples) == 0:
        print("No feasible solution")
    else:
        # Extract the best feasible sample
        best_sample = feasible_samples.lowest()[0]
        d = best_sample.var_values["x"].values
        
        # Determine the route
        route = [N - 1] * (N + 1)
        for key in d.keys():
            route[key[1] + 1] = key[0]
        
        # Calculate the total distance and plot the route
        total_distance = 0
        plt.figure(figsize=(10, 6))
        
        for i in range(len(route) - 1):
            x_coords = [x_pos[route[i]], x_pos[route[i + 1]]]
            y_coords = [y_pos[route[i]], y_pos[route[i + 1]]]
            plt.plot(x_coords, y_coords, 'b-', linewidth=2)
            total_distance += np.sqrt((x_coords[0] - x_coords[1]) ** 2 + (y_coords[0] - y_coords[1]) ** 2)
        
        # Plot the nodes
        plt.scatter(x_pos, y_pos, c='red', s=100, edgecolors='k', zorder=3)
        
        # Set plot properties
        plt.title(f"Total Distance = {total_distance:.2f}", fontsize=15)
        plt.xlabel("X Position", fontsize=15)
        plt.ylabel("Y Position", fontsize=15)
        plt.xlim(0, 1)
        plt.ylim(0, 1)
        plt.grid(True, linestyle='--', alpha=0.7)
        
        # Show the plot
        plt.show()
        
plot_tsp(sampleset, x_pos, y_pos, N)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_23_0.png)
    



```python

```
## QAOA for the Max-Cut
In this section, we will solve the Maxcut Problem using QAOA with the help of the `JijModeling` and `Qamomile` libraries.

First, let's install and import the main libraries we will be using.


```python
# !pip install qamomile[qiskit, quri_parts]
```


```python
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import matplotlib.pyplot as plt
import numpy as np
from typing import List, Tuple
```

## What is the Max-Cut Problem

The Max-Cut problem is the problem of dividing the nodes of a graph into two groups such that the **number of edges cut (or the total weight of the edges cut, if the edges have weights)** is maximized. Applications include network partitioning and image processing (segmentation), among others.



```python
import networkx as nx
import matplotlib.pyplot as plt

G = nx.Graph()
num_nodes = 5
edges = [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]
G.add_nodes_from(range(num_nodes))
G.add_edges_from(edges)
pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}

cut_solution = {(1,): 1.0, (2,): 1.0, (4,): 1.0}
edge_colors = []


def get_edge_colors(
    graph, cut_solution, in_cut_color="r", not_in_cut_color="b"
) -> Tuple[List[str], List[str]]:
    cut_set_1 = [node[0] for node, value in cut_solution.items() if value == 1.0]
    cut_set_2 = [node for node in graph.nodes() if node not in cut_set_1]

    edge_colors = []
    for u, v, _ in graph.edges(data=True):
        if (u in cut_set_1 and v in cut_set_2) or (u in cut_set_2 and v in cut_set_1):
            edge_colors.append(in_cut_color)
        else:
            edge_colors.append(not_in_cut_color)
    node_colors = ["#2696EB" if node in cut_set_1 else "#EA9b26" for node in G.nodes()]
    return edge_colors, node_colors


edge_colors, node_colors = get_edge_colors(G, cut_solution)
fig, axes = plt.subplots(1, 2, figsize=(10, 4))

axes[0].set_title("Original Graph G=(V,E)")
nx.draw_networkx(G, pos, ax=axes[0], node_size=500, width=3, with_labels=True)
axes[1].set_title("MaxCut Solution Visualization")
nx.draw_networkx(
    G,
    pos,
    ax=axes[1],
    node_size=500,
    width=3,
    with_labels=True,
    edge_color=edge_colors,
    node_color=node_colors,
)

plt.tight_layout()
plt.show()
```


    
![png](maxcut_files/maxcut_4_0.png)
    


## Constructing the Mathematical Model

The Max-Cut problem can be formulated with the following equation:

$$
  \max \quad \frac{1}{2} \sum_{(i,j) \in E} (1 - s_i s_j)  
$$

Note that this equation is expressed using Ising variables $ s \in \{ +1, -1 \} $. In this case, we want to formulate it using the binary variables $ x \in \{ 0, 1 \} $ from JijModeling. Therefore, we perform the conversion between Ising variables and binary variables using the following equations:

$$
    x_i = \frac{1 + s_i}{2} \quad \Rightarrow \quad s_i = 2x_i - 1
$$



```python
def Maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem


problem = Maxcut_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Maxcut} & & \\& & \max \quad \displaystyle 0.5 \cdot \sum_{e \in E} \left(- s_{e[0]} \cdot s_{e[1]} + 1\right) & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



## Preparing Instance Data

Next, we will solve the Max-Cut Problem for the following graph. The data for the specific problem being solved is referred to as instance data.


```python
import networkx as nx
import numpy as np
from IPython.display import display, Latex

G = nx.Graph()
num_nodes = 5
edges = [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]
G.add_nodes_from(range(num_nodes))
G.add_edges_from(edges)

weight_matrix = nx.to_numpy_array(G, nodelist=list(range(num_nodes)))

plt.title("G=(V,E)")
plt.plot(figsize=(5, 4))

nx.draw_networkx(G, pos, node_size=500)
```


    
![png](maxcut_files/maxcut_8_0.png)
    



```python
V = num_nodes
E = edges

data = {"V": V, "E": E}

data
```




    {'V': 5, 'E': [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]}



## Creating a Compiled Instance
We perform compilation using the JijModeling-Transpiler by providing the formulation and the instance data prepared earlier. This process yields an intermediate representation of the problem with the instance data substituted.


```python
compiled_model = jmt.compile_model(problem, data)
```

## Converting Compiled Instance to QAOA Circuit and Hamiltonian
We generate the QAOA circuit and Hamiltonian from the compiled Instance. The converter used to generate these is `qm.qaoa.QAOAConverter`.

By creating an instance of this class and using `ising_encode`, you can internally generate the Ising Hamiltonian from the compiled Instance. Parameters that arise during the conversion to QUBO can also be set here. If not set, default values are used.

Once the Ising Hamiltonian is generated, you can generate the QAOA quantum circuit and the Hamiltonian respectively. These can be executed using the `get_qaoa_ansatz` and `get_cost_hamiltonian` methods. The number of QAOA layers, $p$, is fixed to be $7$ here.  


```python
import qamomile.core as qm

qaoa_converter = qm.qaoa.QAOAConverter(compiled_model)

qaoa_converter.ising_encode()

qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()

p = 5

qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```

## Visualization of QAOA Circuit
Qamomile provides a method to visualize the quantum circuit. You can use the plot_quantum_circuit function to visualize the QAOA quantum circuit.


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](maxcut_files/maxcut_15_0.png)
    


## Converting the Obtained QAOA Circuit and Hamiltonian for Qiskit
Here, we generate the Qiskit’s QAOA circuit and Hamiltonian using the `qamomile.qiskit.QiskitTranspiler` converters. By utilizing the two methods,`QiskitTranspiler.transpile_circuit` and `QiskitTranspiler.transpile_hamiltonian`, we can transform the QAOA circuit and Hamiltonian into a format compatible with Qiskit. This allows us to leverage Qiskit’s quantum computing framework to execute and analyze.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()

# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)

# Transpile the QAOA Hamitltonian to Qiskit
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIZZ', 'IIZIZ', 'IZIZI', 'ZIIZI', 'ZZIII', 'ZIZII'],
                  coeffs=[0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j])



## Running QAOA
We run QAOA to optimize the parameters. Here, we use COBYLA as the optimizer.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
# Cost estimator function
estimator = qk_pr.StatevectorEstimator()


def estimate_cost(param_values):
    try:
        job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
        result = job.result()[0]
        cost = result.data["evs"]
        cost_history.append(cost)
        return cost
    except Exception as e:
        print(f"Error during cost estimation: {e}")
        return np.inf


# Create initial parameters
initial_params = np.random.uniform(low=-np.pi / 4, high=np.pi / 4, size=2 * p)

# Run QAOA optimization
result = minimize(
    estimate_cost,
    initial_params,
    method="COBYLA",
    options={"maxiter": 2000, "tol": 1e-2},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -1.8395124880637668
           x: [-9.771e-02 -1.080e+00 -3.948e-01  1.184e+00 -1.948e-01
               -2.640e-01  5.865e-02  4.768e-01  9.115e-01  1.014e+00]
        nfev: 176
       maxcv: 0.0


## Result Visualization
By repeating the optimization, we can observe that the energy decreases and converges.


```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](maxcut_files/maxcut_21_0.png)
    


Now, let's run the Optimized paremeter on qiskit `StatevectorSampler`.


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=10000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results
From the job counts obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])
plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](maxcut_files/maxcut_25_0.png)
    



```python
target_energy = max(list(plot_data.keys()))
target_samples = [
    sample for sample in sampleset.feasibles() if sample.eval.objective == target_energy
]

for sample in target_samples:
    print(f"Energy: {sample.eval.objective}")
    print(f"Occurrences: {sample.num_occurrences}")
    print(f"Solution: {sample.var_values['x'].values}")

best_sample = target_samples[0]
best_sample.var_values["x"].values
```

    Energy: 5.0
    Occurrences: 2178
    Solution: {(1,): 1.0, (2,): 1.0, (4,): 1.0}
    Energy: 5.0
    Occurrences: 2173
    Solution: {(4,): 1.0, (1,): 1.0}
    Energy: 5.0
    Occurrences: 2107
    Solution: {(0,): 1.0, (3,): 1.0}
    Energy: 5.0
    Occurrences: 2132
    Solution: {(0,): 1.0, (2,): 1.0, (3,): 1.0}





    {(1,): 1.0, (2,): 1.0, (4,): 1.0}



## Plotting the Solution
From the obtained results, we select one solution that minimizes the objective function value and plot it. (The red are the edges been cutted in Max-Cut.)


```python
best_values = best_sample.var_values["x"].values
edge_colors, node_colors = get_edge_colors(G, best_values)

plt.title("G=(V,E) QAOA")
plt.plot(figsize=(5, 4))
nx.draw_networkx(
    G,
    pos,
    node_size=500,
    width=3,
    with_labels=True,
    edge_color=edge_colors,
    node_color=node_colors,
)
```


    
![png](maxcut_files/maxcut_28_0.png)
    

# QAOA for Two-Color Multi Car Paint Shop Problem
The goal of [the multi-car paint shop problem](https://arxiv.org/pdf/2109.07876) is to reduce the number of color switches between cars in a paint shop line during the manufacturing process, which is recognized as an NP-hard problem.

Let's consider two-color scenario in this tutorial. 

## Expressing the problem using a mathematical model

Given a set of cars $ X = \{x_1, x_2, \dots, x_n\} $ that need to be painted in one of two colors, denoted as $ x_i=0 $ and $ x_i=1 $,  for each $ i = 1, \dots n$. The objective is to minimize the number of color switches (i.e., changes from $ 0 $ to $ 1 $ or from $ 1 $ to $ 0 $) between consecutive cars in the sequence.


The cost of the sequence is the number of times the color switches between consecutive cars, which can be formulated as:

$$
\text{min} \quad - \sum_{i=0}^{N-2} s_i s_{i+1}.
$$

The term, $-s_i \cdot s_{i+1}$, represents consecutive cars and indicates whether they are going to be painted the same color, either $-1$ or $1$. This term becomes $-1$ when the cars are painted the same color, and $+1$ when they are painted different colors. Summing over all the cars in $X$, the cost function is minimized. By converting the spin variables to binary variables, the mathematical expression transforms into the following: 

$$
\text{min} \quad -\sum_{i=0}^{N-2} (x_i - 0.5) \cdot (x_{i+1} - 0.5).
$$

In the Two-Color Multi-Car Paint Shop Problem, the goal is to minimize the number of color switches while meeting specific constraints. In this notebook, we consider the constraint that the scheduled number of cars in each of the two colors per model (the total number of models is $M$) must be met.

$$
 V_{i,m} \cdot x_i = W_m \quad ,\forall m \in \{0, \dots, M-1\}
$$

, where $V_{i,m}$ is a one-hot 2-dimensional matrix representing which model each car $i$ belongs to.


```python
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile as qm
import numpy as np
import random as rand
```

## Formulation using JijModeling
Let's first model the problem using JijModeling.


```python
def get_mcps_problem() -> jm.Problem:
  V = jm.Placeholder("V", ndim=2) # sequence of car entry
  W = jm.Placeholder("W", ndim=1) # number of black cars by model
  N = jm.Placeholder("N") # number of cars
  M = jm.Placeholder("M") # number of car models
  x = jm.BinaryVar("x", shape=(N,))
  i = jm.Element("i", belong_to=(0, N-1))
  j = jm.Element("j", belong_to=(0, N))
  m = jm.Element("m", belong_to=(0, M))

  problem = jm.Problem("MCPS") 
  problem += jm.sum([i], -(x[i] - 0.5) * (x[i+1] - 0.5))
  problem += jm.Constraint("n-hot", jm.sum([j], V[j][m] * x[j]) == W[m], forall=m)
  return problem
problem = get_mcps_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{MCPS} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 2} - \left(x_{i} - 0.5\right) \cdot \left(x_{i + 1} - 0.5\right) & \\\text{{s.t.}} & & & \\ & \text{n-hot} & \displaystyle \sum_{j = 0}^{N - 1} V_{j, m} \cdot x_{j} = W_{m} & \forall m \in \left\{0,\ldots,M - 1\right\} \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$




```python
car_map = {
    0: "🚗",  # Red car
    1: "🚕",  # Taxi
    2: "🚙",  # SUV
    3: "🚓"   # Police car
}

number_of_models = 4 
number_of_cars = 8
# number of black cars by model
black_per_models = [1, 1, 1, 1]

# Create 8 cars in 4 different kinds of models
cars = [0, 0, 1, 1, 2, 2, 3, 3] 
rand.shuffle(cars)
print(f"The order of car intake: {[car_map[car] for car in cars]}") 

#Create a 2d array of the sequence of car entry
cars_onehot = np.eye(number_of_models)[cars]
print([car_map[i] for i in range(4)])
print(cars_onehot)
```

    The order of car intake: ['🚕', '🚕', '🚙', '🚓', '🚙', '🚓', '🚗', '🚗']
    ['🚗', '🚕', '🚙', '🚓']
    [[0. 1. 0. 0.]
     [0. 1. 0. 0.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]
     [1. 0. 0. 0.]
     [1. 0. 0. 0.]]


## Creating a Compiled Instance
A compiled instance is an intermediate representation where actual values are substituted into the constants of the mathematical expressions. Before converting to various algorithms, it is necessary to first create this compiled instance.


```python
data = {"V": cars_onehot, "W":  black_per_models, "N":  number_of_cars, "M": number_of_models}
compiled_model = jmt.compile_model(problem, data)
```

## Generation of QAOA Circuit and Hamiltonian Using Qamomile
Qamomile provides a converter that generates circuits and Hamiltonians for QAOA from the compiled instance. Additionally, it allows setting parameters that arise during the conversion to QUBO.

First, we will generate the Ising Hamiltonian. Once this is done, we can also generate the quantum circuit and Hamiltonian for QAOA. 


```python
from qamomile.core.converters.qaoa import QAOAConverter
from qamomile.core.circuit.drawer import plot_quantum_circuit

qaoa_converter = QAOAConverter(compiled_model)
# Encode to Ising Hamiltonian
qaoa_converter.ising_encode(multipliers={"n-hot": 3})
# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=1)
plot_quantum_circuit(qaoa_circuit) #print it out
# Get the cost Hamiltonian
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


    
![png](multi_car_paint_files/multi_car_paint_9_0.png)
    


## Converting the Obtained Circuit and Hamiltonian for Qiskit
let's first convert the circuit and Hamiltonian for Qiskit.


```python
import qamomile.qiskit as qm_qk
qk_transpiler = qm_qk.QiskitTranspiler()

# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```

## Running QAOA
Now that everything is ready, let's run QAOA. Here, we are using Scipy's COBYLA as the optimization algorithm.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

# Run QAOA optimization
result = minimize(
    cost_estimator,
    np.random.rand(2) * np.pi,
    method="COBYLA",
    options={"maxiter": 100},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -1.0355860005356643
           x: [ 2.787e+00  1.013e+00]
        nfev: 80
       maxcv: 0.0


Let's also take a look at the changes in the cost function


```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](multi_car_paint_files/multi_car_paint_15_0.png)
    


Now we have obtained the QAOA parameters. Let's use them for sampling


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results

One can determine the optimal solution for the painting order.


```python
paint_map = {
    1: "⚫",  # Black heart 
    0: ""    # Empty string
}

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])
max_energy = -1e9
best_values = None
for sample in sampleset.feasibles():
    if max_energy < sample.eval.objective:
        max_energy = sample.eval.objective
        best_values = sample.var_values

best_values = sampleset.lowest()[0].var_values

values = [0] * 8
for idx in best_values["x"].values:
  values[idx[0]] = 1

print("The order of car intake: ", [car_map[car] for car in cars])
print("Color separation: ", [paint_map[value] for value in values])
```

    The order of car intake:  ['🚕', '🚕', '🚙', '🚓', '🚙', '🚓', '🚗', '🚗']
    Color separation:  ['', '⚫', '⚫', '⚫', '', '', '', '⚫']



```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.25)
plt.xticks(sorted(np.array(list(frequencies.keys()))))
plt.xlabel('Objective', fontsize=15)
plt.ylabel('Frequency', fontsize=15)
plt.show()
```


    
![png](multi_car_paint_files/multi_car_paint_21_0.png)
    


## Evaluation using classical algorithms
Comparing the best costs by brute force search.


```python
def eval_mcps_state(cars, black_per_models, state, num_cars, num_models):
  cnt = [0] * num_models
  for i in range(num_cars):
    cnt[cars[i]] += state[i]
  for i in range(num_models):
    if black_per_models[i] != cnt[i]:
      return None
  score = 0
  for i in range(num_cars-1):
    if state[i] != state[i+1]:
      score += 1
  return score

def best_cost_mcps(cars, black_per_models, num_cars, num_models):
  best_score = 1e9
  for i in range(2**num_cars):
    state = [0] * num_cars
    for j in range(num_cars):
      if i & (2**j) != 0:
        state[j] = 1
    score = eval_mcps_state(cars, black_per_models, state, num_cars, num_models)
    if not(score is None):
      best_score = min(best_score, score)
  return best_score

exact_score = best_cost_mcps(cars, black_per_models, number_of_cars, number_of_models)
qaoa_score = eval_mcps_state(cars, black_per_models, values, number_of_cars, number_of_models)
print("exact solution: ", exact_score)
print("solution using QAOA: ", qaoa_score)
```

    exact solution:  3
    solution using QAOA:  3



```python

```
# QAOA for the Graph Partitioning with Qiskit and Quri-Parts
## What is the graph partitioning problem?

The graph partitioning problem is the problem of dividing a graph 
𝐺 with 𝑉 vertices into two parts in such a way that the number of edges cut is minimized. For example, consider a graph with 6 vertices like the following.

![init_graph](graph_partition_fig/graph_init.png)

If we divide this into halves with 3 vertices each, it would be divided as follows,

![colored_graph](graph_partition_fig/graph_colored.png)

and one can see that the number of edges cut is minimized (in this case, two). 

It is known that finding this solution is NP-hard.

## Expressing the graph partitioning problem using a mathematical model

Suppose there is graph $G=(V,E)$, where $V$ is the set of vertices and $E$ is the set of edges. We consider dividing this into two sets, $V_1$ and $V_2$. To formulate the problem, a variable $x_u$ is introduced. This variable is equal to 1 if vertex $x_u$ belongs to $V_1$, and 0 if it belongs to in $V_2$.

In this case, the objective function to be minimized can be expressed as follows.

$$
\mathrm{min}\sum_{(uv)\in E} (\{x_u(1-x_v) + x_v(1-x_u)\})
$$

Here, the term $x_u(1-x_v)$ represents an edge connecting $V_1$ and $V_2$. For example, if $x_u$ belongs to $V_1$, it is 1, and if $x_v$ belongs to $V_2$, it is 0. In such a case, the edge specified by $u$ and $v$ connects $V_1$ and $V_2$, and $x_u(1-x_v)$ becomes 1.

The term $x_v(1-x_u)$ is similar. If we sum this over the edges in $G$, $\sum_{(uv)\in E}$, we can represent the number of edges connecting $V_1$ and $V_2$.

Moreover, the constraint that the vertices of $G$ are evenly divided between $V_1$ and $V_2$ can be written as the following equation.

$$
\sum_{u\in V}x_u=V/2
$$

Let’s formulate the problem as described above using JijModeling, convert it into various quantum algorithms using Qamomile, and solve it.

## Importing Packages


```python
import qamomile.core as qm
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
import matplotlib.pyplot as plt
import random
```

## Formulation using JijModeling
Now that everything is ready, let's first model the problem using JijModeling.


```python
#Formulating the problem
problem = jm.Problem('Graph Partitioning')

#Defining Variables
V = jm.Placeholder('V')
E = jm.Placeholder('E', ndim=2)
x = jm.BinaryVar('x', shape=(V,))
u = jm.Element('u', belong_to=V)
e = jm.Element('e', belong_to=E)

#Formulating the constraint
const = jm.sum(u, x[u])
problem += jm.Constraint('constraint', const==V/2)

#Formulating the objective function
A_1 = x[e[0]]*(1-x[e[1]])
A_2 = (1-x[e[0]])*x[e[1]]
problem += jm.sum(e, (A_1 + A_2))
```

This completes the modeling. Let's display the created model.


```python
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Partitioning} & & \\& & \min \quad \displaystyle \sum_{e \in E} \left(x_{e_{0}} \cdot \left(- x_{e_{1}} + 1\right) + \left(- x_{e_{0}} + 1\right) \cdot x_{e_{1}}\right) & \\\text{{s.t.}} & & & \\ & \text{constraint} & \displaystyle \sum_{u = 0}^{V - 1} x_{u} = V \cdot 2^{(-1)} &  \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



## Preparing the problem
We will now prepare the problem to be solved. Here, we will create it using a random graph


```python
#Parameters
#Number of vertices
num_nodes = 8  
#Edge addition probability
edge_probability = 0.5  

#Creating a random graph
def generate_random_graph(num_nodes, edge_probability):
    G = nx.Graph()
    # Add nodes
    for i in range(num_nodes):
        G.add_node(i)

    # Add edges randomly
    for i in range(num_nodes):
        for j in range(i + 1, num_nodes):
            if random.random() < edge_probability:
                G.add_edge(i, j)

    return G

G = generate_random_graph(num_nodes, edge_probability)

#Visualization of the created random graph
def plot_graph(G):
    pos = nx.spring_layout(G, seed=1)
    plt.figure(figsize=(5,5))
    nx.draw(G, pos, with_labels=True, node_color='white', node_size=700,
           edgecolors='black')
    plt.show()

plot_graph(G)
```


    
![png](graph_partition_files/graph_partition_9_0.png)
    


We will prepare the problem data in a format that can be used with the model created in JijModeling


```python
inst_E = [list(edge) for edge in G.edges]
instance_data = {"V": num_nodes,"E": inst_E}
num_qubits = num_nodes
```

## Creating a Compiled Instance

A compiled instance is an intermediate representation where actual values are substituted into the constants of the mathematical expressions. Before converting to various algorithms, it is necessary to first create this compiled instance.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

## Generation of QAOA Circuit and Hamiltonian Using Qamomile
Qamomile provides a converter that generates circuits and Hamiltonians for QAOA from the compiled instance. Additionally, it allows setting parameters that arise during the conversion to QUBO.

First, we will generate the Ising Hamiltonian. Once this is done, we can also generate the quantum circuit and Hamiltonian for QAOA.









```python
from qamomile.core.circuit.drawer import plot_quantum_circuit
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)

# Encode to Ising Hamiltonian
qaoa_converter.ising_encode()

# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=3) #p is the number of layers 
plot_quantum_circuit(qaoa_circuit) #print it out
# Get the cost Hamiltonian
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
```


    
![png](graph_partition_files/graph_partition_15_0.png)
    


## Converting the Obtained Circuit and Hamiltonian for Qiskit
Qamomile has its own representation of quantum circuits and Hamiltonians to support multiple quantum algorithms. These representations need to be converted for use in the desired quantum libraries.

As of the time of writing this document (December 4, 2024), Qamomile supports:
- Qiskit
- Quri-Parts
- Qutip

As an example, let's first convert the circuit and Hamiltonian for Qiskit. To do this, we will first create an instance of __QiskitTranspiler__. Using the methods __transpile_circuit__ and __transpile_hamiltonian__ from this class, we can generate the quantum circuit and Hamiltonian.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()

# Creating the circuit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)

#Creating the Hamiltonian
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIZIIIZ', 'IIZIIIIZ', 'ZIIIIIIZ', 'IZIIIIIZ', 'ZIIZIIII', 'ZIIIIIZI', 'IIIIZIZI', 'IZIIIIZI', 'ZIZIIIII', 'IIIIZZII', 'IZIIIZII'],
                  coeffs=[0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j,
     0.5+0.j, 0.5+0.j, 0.5+0.j])



## Running QAOA
Now that everything is ready, let's run QAOA. Here, we are using Scipy's COBYLA as the optimization algorithm.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

initial_params = [np.pi / 4, np.pi / 2, np.pi / 2, np.pi / 4,np.pi / 4, np.pi / 2]

# Run QAOA optimization
result = minimize(
    cost_estimator,
    initial_params,
    method="COBYLA",
    options={"maxiter": 1000},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -2.8038438541136963
           x: [ 1.027e+00  2.833e+00  1.673e+00  5.214e-01  8.489e-01
                2.062e+00]
        nfev: 766
       maxcv: 0.0


Let's also take a look at the changes in the cost function


```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_partition_files/graph_partition_21_0.png)
    


Now we have obtained the QAOA parameters. Let's use them for sampling


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results
To evaluate the solution, it is convenient to use the sample_set. It calculates the objective function value, constraint violations, and more from the obtained solution.


```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.5)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()
```


    
![png](graph_partition_files/graph_partition_25_0.png)
    


The value of the objective function represents the number of edges connecting $V_1$ and $V_2$, so the pattern with the smallest value can be considered the solution. Let's plot the obtained results on a graph.



```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):
    # extract feasible solution
    lowests = sampleset.lowest()
    
    if len(lowests) == 0:
        print("No feasible solution found ...")
    else:
        best_sol = lowests[0]
        pos = nx.spring_layout(graph,seed=1)

        color_map = []
        for node in graph.nodes:
            if (node,) in best_sol.var_values["x"].values.keys():
                color_value = best_sol.var_values["x"].values[(node,)]
                color_map.append(color_value)
            else:
                color_map.append(0)  # Default color if not in the solution

        # Draw the graph with the color mapping
        nx.draw_networkx(graph, pos, with_labels=True,
                         node_color=color_map, cmap=plt.get_cmap('rainbow'))

plot_graph_coloring(G, sampleset)
```


    
![png](graph_partition_files/graph_partition_27_0.png)
    


## Conversion to Quri-Parts using Qamomile
Next, let's perform the conversion for Quri-Parts. First, we will import the necessary libraries


```python
from qamomile.quri_parts import QuriPartsTranspiler
```

We will perform the conversion in the same way as with Qiskit


```python
quri_transpiler = QuriPartsTranspiler()
quri_circuit = quri_transpiler.transpile_circuit(qaoa_circuit)
quri_hamiltonian = quri_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
```

We will set the parameters and perform optimization


```python
from quri_parts.core.state import quantum_state, apply_circuit

cb_state = quantum_state(quri_circuit.qubit_count, bits=0)
parametric_state = apply_circuit(quri_circuit, cb_state)
```

Quri-Parts with Qulacs is a quantum circuit simulator that operates faster than Qiskit. Taking advantage of this superior speed, let's increase the number of iterations in our experiment. By doing so, we can potentially improve our results even further and explore the capabilities of Quri-Parts more deeply. Let's modify our code to run more iterations and see how this affects our sampling results and the frequency of obtaining the lowest objective value.


```python
from typing import Sequence
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator

estimator = create_qulacs_vector_parametric_estimator()

cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(quri_hamiltonian, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost

result = minimize(cost_fn, initial_params, method="COBYLA", options={"maxiter": 20000})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -3.032268864311802
           x: [ 3.733e-01  1.044e+00  1.061e+00  4.109e-01 -2.714e-01
                2.404e+00]
        nfev: 3984
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.xscale("log")
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_partition_files/graph_partition_36_0.png)
    


If the cost function appears to have sufficiently decreased, we will use the obtained parameters to sample the solution


```python
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
bounded_circuit = quri_circuit.bind_parameters(result.x)
qp_result = sampler(bounded_circuit, 1000)
```

Let's visualize the sampling results


```python
sampleset = qaoa_converter.decode(quri_transpiler, (qp_result, quri_circuit.qubit_count))

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.5)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()
```


    
![png](graph_partition_files/graph_partition_40_0.png)
    


Let's plot the obtained results


```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):
    # extract feasible solution
    lowests = sampleset.lowest()
    if len(lowests) == 0:
        print("No feasible solution found ...")
    else:
        best_sol = lowests[0]
        pos = nx.spring_layout(graph,seed=1)

        color_map = []
        for node in graph.nodes:
            if (node,) in best_sol.var_values["x"].values.keys():
                color_value = best_sol.var_values["x"].values[(node,)]
                color_map.append(color_value)
            else:
                color_map.append(0)  # Default color if not in the solution

        # Draw the graph with the color mapping
        nx.draw_networkx(graph, pos, with_labels=True,
                         node_color=color_map, cmap=plt.get_cmap('rainbow'))

plot_graph_coloring(G, sampleset)
```


    
![png](graph_partition_files/graph_partition_42_0.png)
    



```python

```
# Quantum Chemistry

## Tutorials

- [Variational Quantum EigenSolver (VQE) for the Hydrogen Molecule](vqe_for_hydrogen.ipynb): Learn how to implement VQE to find the ground state energy of hydrogen molecule.# Variational Quantum EigenSolver (VQE) for the Hydrogen Molecule

In this tutorial, we'll explore the implementation of the Variational Quantum Eigensolver (VQE) algorithm to find the ground state energy of a hydrogen molecule (H2). We'll use various quantum computing frameworks including OpenFermion for molecular Hamiltonians, Qamomile for quantum circuit construction, and Qiskit for quantum simulation.

The workflow includes:
1. Converting molecular Hamiltonians to qubit operators
2. Creating a parametrized quantum circuit (ansatz)
3. Implementing VQE optimization
4. Analyzing the energy landscape at different atomic distances

We'll demonstrate how quantum computing can be used to solve quantum chemistry problems, specifically focusing on finding the minimum energy configuration of H2.


```python
# You can install the required packages by running the following command
# !pip install openfermion pyscf openfermionpyscf
```

## Creating the Hamiltonian of the Hydrogen Molecule


```python
import openfermion.chem as of_chem
import openfermion.transforms as of_trans
import openfermionpyscf as of_pyscf
```


```python
basis = "sto-3g"
multiplicity = 1
charge = 0
distance = 0.977
geometry = [["H", [0, 0, 0]], ["H", [0, 0, distance]]]
description = "tmp"
molecule = of_chem.MolecularData(geometry, basis, multiplicity, charge, description)
molecule = of_pyscf.run_pyscf(molecule, run_scf=True, run_fci=True)
n_qubit = molecule.n_qubits
n_electron = molecule.n_electrons
fermionic_hamiltonian = of_trans.get_fermion_operator(molecule.get_molecular_hamiltonian())
jw_hamiltonian = of_trans.jordan_wigner(fermionic_hamiltonian)
```

## Convert to Qamomile Hamiltonian

In this section, we transform the OpenFermion Hamiltonian into a Qamomile Hamiltonian format. After applying the Jordan-Wigner transformation to convert fermionic operators to qubit operators, we use custom conversion functions to create a compatible Hamiltonian representation for Qamomile.


```python
import qamomile.core.operator as qm_o

def operator_to_qamomile(operators: tuple[tuple[int, str], ...]) -> qm_o.Hamiltonian:
    pauli = {"X": qm_o.X, "Y": qm_o.Y, "Z": qm_o.Z}
    H = qm_o.Hamiltonian()
    H.constant = 1.0
    for ope in operators:
        H = H * pauli[ope[1]](ope[0])
    return H

def openfermion_to_qamomile(of_h) -> qm_o.Hamiltonian:
    H = qm_o.Hamiltonian()
    for k, v in of_h.terms.items():
        if len(k) == 0:
            H.constant += v
        else:
            H += operator_to_qamomile(k) * v
    return H

hamiltonian = openfermion_to_qamomile(jw_hamiltonian)
```

## Create VQE ansatz

In this section, we create a simple ansatz for the VQE algorithm. The ansatz is a parametrized quantum circuit that prepares a trial wavefunction. We use the Qamomile framework to construct the ansatz circuit.


```python
from qamomile.core.ansatz.efficient_su2 import create_efficient_su2_circuit
from qamomile.core.circuit.drawer import plot_quantum_circuit

ansatz = create_efficient_su2_circuit(
    hamiltonian.num_qubits, rotation_blocks=["ry", "rz"],
    reps=4, entanglement="linear"
)
plot_quantum_circuit(ansatz)
```


    
![png](vqe_for_hydrogen_files/vqe_for_hydrogen_8_0.png)
    


## Run VQE with Qiskit

In this section, we execute the VQE using the Qiskit Aer simulator after converting the Qamomile Hamiltonian and ansatz to Qiskit format.  
Of course, you can use other quantum computing frameworks.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()
qk_ansatz = qk_transpiler.transpile_circuit(ansatz)
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(hamiltonian)
```


```python
# !pip install qiskit-aer
```


```python
import qiskit.primitives as qk_pr
import qiskit as qk
from qiskit_aer import AerSimulator
from qiskit_aer.primitives import EstimatorV2
import numpy as np
from scipy.optimize import minimize

cost_history = []

aer_sim = AerSimulator()
qk_circuit_transpiled_ansatz = qk.transpile(qk_ansatz, aer_sim)
estimator = EstimatorV2()

def cost_estimator(param_values):
    job = estimator.run([(qk_ansatz, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data["evs"]
    return cost

def cost_callback(param_values):
    cost_history.append(cost_estimator(param_values))

initial_params = np.random.uniform(0, np.pi, len(qk_ansatz.parameters))

# Run QAOA optimization
result = minimize(
    cost_estimator,
    initial_params,
    method="BFGS",
    options={"disp": True, "maxiter": 50, "gtol": 1e-6},
    callback=cost_callback
)
print(result)
```

             Current function value: -1.105868
             Iterations: 50
             Function evaluations: 2091
             Gradient evaluations: 51
      message: Maximum number of iterations has been exceeded.
      success: False
       status: 1
          fun: -1.1058675315265363
            x: [ 3.157e+00  2.124e+00 ...  1.591e+00  4.345e-01]
          nit: 50
          jac: [ 5.545e-05  1.662e-04 ...  5.196e-04 -2.392e-05]
     hess_inv: [[ 6.494e+00 -2.618e+00 ...  1.032e+01 -6.820e-01]
                [-2.618e+00  9.130e+00 ... -5.761e+00  3.409e+00]
                ...
                [ 1.032e+01 -5.761e+00 ...  2.391e+01 -1.763e+00]
                [-6.820e-01  3.409e+00 ... -1.763e+00  2.796e+00]]
         nfev: 2091
         njev: 51


    /Users/yuyamashiro/Library/Caches/pypoetry/virtualenvs/qamomile-s0Pfpxir-py3.10/lib/python3.10/site-packages/scipy/optimize/_minimize.py:726: OptimizeWarning: Maximum number of iterations has been exceeded.
      res = _minimize_bfgs(fun, x0, args, jac, callback, **options)



```python
import matplotlib.pyplot as plt
plt.plot(cost_history)
plt.plot(
    range(len(cost_history)),
    [molecule.fci_energy] * len(cost_history),
    linestyle="dashed",
    color="black",
    label="Exact Solution",
)
plt.legend()
plt.show()
```


    
![png](vqe_for_hydrogen_files/vqe_for_hydrogen_13_0.png)
    


## Change distance between atoms


```python
def hydrogen_molecule(bond_length):
    basis = "sto-3g"
    multiplicity = 1
    charge = 0
    geometry = [["H", [0, 0, 0]], ["H", [0, 0, bond_length]]]
    description = "tmp"
    molecule = of_chem.MolecularData(geometry, basis, multiplicity, charge, description)
    molecule = of_pyscf.run_pyscf(molecule, run_scf=True, run_fci=True)
    n_qubit = molecule.n_qubits
    n_electron = molecule.n_electrons
    fermionic_hamiltonian = of_trans.get_fermion_operator(
        molecule.get_molecular_hamiltonian()
    )
    jw_hamiltonian = of_trans.jordan_wigner(fermionic_hamiltonian)
    return openfermion_to_qamomile(jw_hamiltonian), molecule.fci_energy

bond_lengths = np.linspace(0.2, 1.5, 15)
energies = []
for bond_length in bond_lengths:
    hamiltonian, fci_energy = hydrogen_molecule(bond_length)
    
    ansatz = create_efficient_su2_circuit(
        hamiltonian.num_qubits, rotation_blocks=["ry", "rz"],
        reps=4, entanglement="linear"
    )

    qk_ansatz = qk_transpiler.transpile_circuit(ansatz)
    qk_hamiltonian = qk_transpiler.transpile_hamiltonian(hamiltonian)

    cost_history = []
    initial_params = np.random.uniform(0, np.pi, len(qk_ansatz.parameters))
    result = minimize(
        cost_estimator,
        initial_params,
        method="BFGS",
        options={"maxiter": 50, "gtol": 1e-6},
    )

    energies.append(result.fun)

    print("distance: ", bond_length, "energy: ", result.fun, "fci_energy: ", fci_energy)
```

    distance:  0.2 energy:  0.15754119488608387 fci_energy:  0.15748213479836348
    distance:  0.29285714285714287 energy:  -0.5679350331466697 fci_energy:  -0.5679447209710022
    distance:  0.38571428571428573 energy:  -0.8833020521044717 fci_energy:  -0.8833596636183383
    distance:  0.4785714285714286 energy:  -1.0335991644424345 fci_energy:  -1.0336011797110967
    distance:  0.5714285714285714 energy:  -1.1035710721430323 fci_energy:  -1.1042094222435161
    distance:  0.6642857142857144 energy:  -1.1322058758760072 fci_energy:  -1.132350882707551
    distance:  0.7571428571428571 energy:  -1.136784862771528 fci_energy:  -1.1369026717971324
    distance:  0.8500000000000001 energy:  -1.1281267827080066 fci_energy:  -1.1283618784581124
    distance:  0.9428571428571428 energy:  -1.1125670649192354 fci_energy:  -1.1127252078468768
    distance:  1.0357142857142858 energy:  -1.093269672823594 fci_energy:  -1.0934760882294043
    distance:  1.1285714285714286 energy:  -1.0725622262836512 fci_energy:  -1.0727578805453502
    distance:  1.2214285714285713 energy:  -1.0519588130652564 fci_energy:  -1.0520081621708446
    distance:  1.3142857142857143 energy:  -1.0322273864176297 fci_energy:  -1.032240030624708
    distance:  1.4071428571428573 energy:  -1.0137141437663768 fci_energy:  -1.014147058669549
    distance:  1.5 energy:  -0.9978997023749084 fci_energy:  -0.9981493534714101



```python
plt.plot(bond_lengths, energies, "-o")
plt.xlabel("Distance")
plt.ylabel("Energy")
plt.show()
```


    
![png](vqe_for_hydrogen_files/vqe_for_hydrogen_16_0.png)
    



```python

```
# Using the PennyLaneTranspiler in Qamomile
This tutorial demonstrates the usage of the PennyLaneTranspiler in Qamomile and provides key examples to guide users in applying it effectively.

## Translating a Hamiltonian into PennyLane

We begin by defining a Hamiltonian as a test example and use our transpiler to convert it into a PennyLane-compatible representation. This step shows how seamlessly the Hamiltonian defined in our own library’s format can be translated into operators recognized by PennyLane.


```python
import pennylane as qml
import numpy as np
import qamomile
from qamomile.pennylane.transpiler import PennylaneTranspiler
from qamomile.core.operator import Hamiltonian, Pauli, X, Y, Z
from qamomile.core.circuit import QuantumCircuit as QamomileCircuit
from qamomile.core.circuit import (
    QuantumCircuit,
    SingleQubitGate,
    TwoQubitGate,
    ParametricSingleQubitGate,
    ParametricTwoQubitGate,
    SingleQubitGateType,
    TwoQubitGateType,
    ParametricSingleQubitGateType,
    ParametricTwoQubitGateType,
    Parameter
)

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
```

In this snippet, we start from a custom-defined Hamiltonian using various Pauli operators (X, Y, Z) and then employ `PennylaneTranspiler` to convert it into a format directly suitable for PennyLane devices. By inspecting `ops_first_term` and printing out `pennylane_hamiltonian`, we can verify the correctness of the translation.


```python
hamiltonian = Hamiltonian()
hamiltonian += X(0)*Z(1)
hamiltonian += Y(0)*Y(1)*Z(2)*X(3)*X(4)

transpiler = PennylaneTranspiler()
pennylane_hamiltonian = transpiler.transpile_hamiltonian(hamiltonian)

ops_first_term = pennylane_hamiltonian.terms()[1][0]
print(pennylane_hamiltonian)
```

    1.0 * (X(0) @ Z(1) @ I(2) @ I(3) @ I(4)) + 1.0 * (Y(0) @ Y(1) @ Z(2) @ X(3) @ X(4))


## Constructing a Parameterized Quantum Circuit

Next, we build a parameterized quantum circuit using QamomileCircuit. We include single-qubit rotations (e.g., rx, ry, rz) and controlled variants (crx, crz, cry), as well as two-qubit entangling gates (rxx, ryy, rzz). The parameters (theta, beta, gamma) allow for flexible variational adjustments.


```python
qc = QamomileCircuit(3)
theta = Parameter("theta")
beta = Parameter("beta")
gamma = Parameter("gamma")

qc.rx(theta, 0)
qc.ry(beta, 1)
qc.rz(gamma, 2)
qc.crx(gamma, 0 ,1)
qc.crz(theta, 1 ,2)
qc.cry(beta, 2 ,0)
qc.rxx(gamma, 0 ,1)
qc.ryy(theta, 1 ,2)
qc.rzz(beta, 2 ,0)

transpiler = PennylaneTranspiler()
QNode = transpiler.transpile_circuit(qc)
```

## Formulating the MaxCut Problem and Converting it into a Quantum Form

In the following part, we demonstrate how to take a classical optimization problem—MaxCut—and encode it into an Ising-form Hamiltonian. We then construct a QAOA-style ansatz circuit that, when executed and optimized, attempts to solve the MaxCut instance.


```python
def maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem

def maxcut_instance():
    # Construct a simple graph for a MaxCut instance
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 4])
    G.add_edges_from([(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)])
    E = [list(edge) for edge in G.edges]
    instance_data = {"V": G.number_of_nodes(), "E": E}
    pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
    nx.draw_networkx(G, pos, node_size=500)
    return instance_data

problem = maxcut_problem()
instance_data = maxcut_instance()
compiled_instance = jmt.compile_model(problem, instance_data)

# Convert the compiled problem into a QAOA form.
qaoa_converter = qamomile.core.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode()

p = 5
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_8_0.png)
    



```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_9_0.png)
    


We have now translated the MaxCut problem into a cost Hamiltonian suitable for a QAOA-like algorithm. The parameter `p` determines the number of layers of problem and mixer Hamiltonians. Each layer’s parameters are variational and will be tuned to minimize the expvalue, ideally leading to a good solution to the MaxCut instance.

## Transpiling and Executing the QAOA Circuit in PennyLane

With the QAOA circuit and Hamiltonian defined, we use the transpiler again, this time to convert the QAOA circuit and cost Hamiltonian into PennyLane forms:


```python
from pennylane import numpy as p_np
transpiler = PennylaneTranspiler()
circ_func = transpiler.transpile_circuit(qaoa_circuit)
qml_hamiltonian = transpiler.transpile_hamiltonian(qaoa_hamiltonian)

dev = qml.device("default.qubit", wires=qaoa_circuit.num_qubits)

@qml.qnode(dev)
def circuit(params, return_samples=False):
    circ_func(params)
    if return_samples:
        return qml.sample()
    return qml.expval(qml_hamiltonian)

parameters = p_np.array([np.pi/4, np.pi/4]*p, requires_grad=True)
print("Initial Expectation Value:", circuit(parameters))
cost_history = []
cost_history.append(circuit(parameters))
```

    Initial Expectation Value: 0.6975904406316911


Here, `circ_func` is the PennyLane circuit function generated from the QAOA ansatz. Evaluating `circuit(p)` gives the expectation value of the cost Hamiltonian for the given set of parameters `p`.

## Optimizing the Parameters

Finally, we leverage PennyLane’s optimizers to update the parameters and attempt to find those that yield better results (e.g., lower cost for the MaxCut objective):


```python
max_iterations = 1000
optimizer = qml.GradientDescentOptimizer(stepsize=5e-2)
for i in range(max_iterations):
    parameters, loss= optimizer.step_and_cost(circuit, parameters)
    cost_history.append(loss)
    
print("Optimal Parameters")
print(parameters)
```

    Optimal Parameters
    [ 0.35271931  1.02327598  0.74961704  1.12583207  0.91321306 -0.38421535
      1.08607428  1.27879381  1.12025286  1.42425253]



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, max_iterations)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_16_0.png)
    


Once the optimized parameters are obtained, we use PennyLane's QNode to sample from the parameterized quantum circuit to get the circuit counts.


```python
dev_counts = qml.device("default.qubit", wires=qaoa_circuit.num_qubits, shots=1000)
@qml.qnode(dev_counts)
def circuit_counts(params):
    circ_func(params)
    return qml.counts()
result = circuit_counts(parameters)
```


```python
# Prepare data for plotting
keys = list(result.keys())
values = list(result.values())

# Plotting
plt.figure(figsize=(12, 6))
plt.bar(keys, values, width=0.6)
plt.xlabel("State", fontsize=12)
plt.ylabel("Frequency", fontsize=12)
plt.title("Distribution of State", fontsize=14)
plt.xticks(rotation=90, fontsize=10)
plt.tight_layout()
plt.show()
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_19_0.png)
    


## Evaluating the Results
From the `circuit_counts` obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(transpiler, result) 
plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_21_0.png)
    



```python

```
# Building Quantum Circuits

## Introduction
Welcome to this tutorial on building quantum circuits with Qamomile! While Qamomile is primarily designed for quantum optimization tasks, it also offers powerful capabilities for constructing arbitrary quantum circuits. This tutorial will guide you through the process of creating and manipulating quantum circuits using Qamomile's unique intermediate representation.


## Prerequisites
Before we begin, make sure you have:

- Qamomile Installed in your Python Environment


## Getting Started
First, let's import the necessary modules from Qamomile:


```python
import qamomile.core as qm
```

## Creating a Quantum Circuit
To create a quantum circuit in Qamomile, we start by initializing quantum and classical registers, then use these to create a QuantumCircuit object:


```python
circuit = qm.circuit.QuantumCircuit(2)  # Create a quantum circuit with 2 qubits
```

## Adding Gates to the Circuit
Qamomile supports a wide range of quantum gates. Let's add some common gates to our circuit:


```python
# Apply Hadamard gate to the first qubit
circuit.h(0)

# Apply CNOT gate with first qubit as control and second as target
circuit.cx(0, 1)

# Apply X-gate to the second qubit
circuit.x(1)
```

The quantum gates supported by Qamomile can be found at the following link: 
https://jij-inc.github.io/Qamomile/autoapi/core/circuit/circuit/index.html#core.circuit.circuit.QuantumCircuit

## Measurements
To perform measurements in Qamomile:


```python
circuit.measure_all()
```

## Visualizing the Circuit
Qamomile provides a method to visualize the quantum circuit:


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(circuit)
```


    
![png](building_quantum_circuits_files/building_quantum_circuits_11_0.png)
    


## Circuit Composition

You can combine smaller circuits to create more complex ones:


```python
# Create two separate circuits
circuit1 = qm.circuit.QuantumCircuit(2)
circuit1.h(0)
circuit1.h(1)

circuit2 = qm.circuit.QuantumCircuit(2)
circuit2.cx(0, 1)


circuit1.append(circuit2)

plot_quantum_circuit(circuit1)
```


    
![png](building_quantum_circuits_files/building_quantum_circuits_13_0.png)
    


By specifying the `decompose_level` when plotting, you can display the circuit in more detail.


```python
plot_quantum_circuit(circuit1, decompose_level=1)
```


    
![png](building_quantum_circuits_files/building_quantum_circuits_15_0.png)
    


## Executing the Quantum Circuit

While Qamomile itself doesn't have the functionality to execute quantum circuits, it can translate the circuit to other quantum SDKs for execution.

### Qiskit Backend

Here's how you can execute a Qamomile circuit using Qiskit:

1- First import the necessary modules:


```python
from qamomile.qiskit import QiskitTranspiler
import qiskit.primitives as qk_pr
```

2- Create a QiskitTranspiler object:


```python
qk_transpiler = QiskitTranspiler()
```

3- Trasnpile your Qamomile circuit to a Qiskit circuit:


```python
qk_circuit = qk_transpiler.transpile_circuit(circuit)
```

4- Now you can use Qiskit's functionality to execute the circuit. For example, to run the circuit on a simulator:


```python
simulator = qk_pr.StatevectorSampler()
job = simulator.run([qk_circuit], shots=1000)
result = job.result()
```

5- The results can then be processed and analyzed using Qiskit's tools:


```python
result[0].data['c'].get_counts()
```




    {'10': 494, '01': 506}



### QURI-Parts with Qulacs Backend

Here's how you can execute a Qamomile circuit using QURI-Parts with Qulacs.

Execute the quantum circuit by converting it in the same way as Qiskit.


```python
from qamomile.quri_parts import QuriPartsTranspiler

# Transpile the circuit to QURI-Parts
qp_transpiler = QuriPartsTranspiler()
qp_circuit = qp_transpiler.transpile_circuit(circuit)
```

Now you can use Qulacs to execute the circuit:


```python
from quri_parts.core.state import quantum_state, apply_circuit
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
sampling_result = sampler(qp_circuit, 1000)
```


```python
sampling_result
```




    Counter({1: 501, 2: 499})



### Pennylane Backend

Here's how you can execute a Qamomile circuit using Pennylane.

Execute the quantum circuit by converting it in the same way as Qiskit.


```python
from qamomile.pennylane import PennylaneTranspiler

# Transpile the circuit to Pennylane
qml_transpiler = PennylaneTranspiler()
qml_circuit_func = qml_transpiler.transpile_circuit(circuit)
```


```python
import pennylane as qml

dev = qml.device("default.qubit", wires=circuit.num_qubits, shots=1000)
@qml.qnode(dev)
def qml_circuit(params):
    qml_circuit_func(params)
        
    return qml.counts()
```


```python
qml_circuit(None)
```




    {'01': 483, '10': 517}



## Conclusion

This tutorial has introduced you to building quantum circuits using Qamomile's intermediate representation and executing them using Qiskit and QURI-Parts. While Qamomile's primary focus is on quantum optimization, these circuit-building capabilities provide flexibility for various quantum computing tasks.  
Happy quantum computing with Qamomile!
## Using the QuTiPTranspiler in Qamomile

We will introduce applications in quantum annealing using Qamomile and QuTip. We focus on a Hamiltonian of the following form:

$$
H(s) = s H_0 + (1 - s) H_1
$$

where $ H_0 $ is the Hamiltonian for the Max-Cut problem we want to solve and often formulated in terms of an Ising model, and $ H_1 $ is the Hamiltonian for the transverse magnetic field. For further details on how to construct the Hamiltonian for the max-cut problem, please refer to [QAOA for Max-Cut](https://jij-inc.github.io/Qamomile/tutorial/maxcut.html).
The Hamiltonians are defined as follows: 

$$
H_0 = -\frac{1}{2} \sum_{(i,j) \in E} w_{i,j}(1 - s_i s_j)  , \quad H_1 = - \sum_{i=1}^N \sigma_i^x
$$


As the parameter $s$ gradually shifts from 0 to 1, the system gradually evolves from the ground state of $H_1$ to the ground state of  $H_0$, which corresponds to the solution to the optimization problem. 

First, let’s import the Qamomile library and other libraries used in this example.



```python
import jijmodeling as jm
import numpy as np
import qamomile.core.operator as qm_o
import matplotlib.pyplot as plt
import qamomile.qutip as qm_qt

def Maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    w = jm.Placeholder("w", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)

    problem = jm.Problem("Maxcut")
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = -1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem


problem = Maxcut_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Maxcut} & & \\& & \min \quad \displaystyle (-0.5) \cdot \sum_{e \in E} \left(- s_{e[0]} \cdot s_{e[1]} + 1\right) & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$




```python
import networkx as nx
from IPython.display import display, Latex

G = nx.Graph()
num_nodes = 5
edges = [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]
G.add_nodes_from(range(num_nodes))
G.add_edges_from(edges)

pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
plt.title("G=(V,E)")
plt.plot(figsize=(5, 4))

nx.draw_networkx(G, pos, node_size=500)
```


    
![png](quantum_annealing_files/quantum_annealing_3_0.png)
    



```python
import jijmodeling_transpiler.core as jmt
compiled_model = jmt.compile_model(problem, {"V": num_nodes, "E": edges})
```


```python
import qamomile.core as qm

# Obtain cost hamiltonian
qaoa_converter = qm.qaoa.QAOAConverter(compiled_model)
H0 = qaoa_converter.get_cost_hamiltonian()
```

Now transpile the qamomile’s hamiltonian to the qutip’s hamiltonian


```python
qt_transpiler = qm_qt.QuTiPTranspiler()
qt_H0= qt_transpiler.transpile_hamiltonian(H0)
```

Hamiltonian $H_1$ for the transverse magnetic field is also needed to be constructed


```python
H1 = qm_o.Hamiltonian()
for q1 in range(num_nodes):
    H1 -= qm_o.X(q1)
qt_H1= qt_transpiler.transpile_hamiltonian(H1)
```

We define the annealing time $T$ with $s = t / T$, where $s$ is the parameter in the Hamiltonian $H(s)$ introduced earlier. In Quantum Annealing, if $T$ is taken sufficiently large, the ground state of $H_0$ can theoretically be obtained. We perform quantum annealing for the Max-Cut problem and examine whether the final state $|\psi(T)\rangle$ is an optimal solution to the problem.

The entire Hamiltonian of the quantum annealing is given as a list where each element is a pair consisting of a Hamiltonian and its coefficient. Also, We create the initial state $ \psi(t)$ at $t = 0$, which is the ground state of $H_1$.


```python
from qutip import tensor, Qobj, mesolve

T=100

def coef0(t, args):
    return t/T

def coef1(t, args):
    return 1-t/T

H = [[qt_H0, coef0], [qt_H1, coef1]]
psi0 = tensor([Qobj([[1], [1]])/np.sqrt(2) for _ in range(num_nodes)])
```

To solve the Schrödinger equation, we use `mesolve`with the Hamiltonian, the initial state and a list of times.


```python
tlist = np.linspace(0.0, T, 101)
result = mesolve(H, psi0, tlist, [])
psi_final = result.states[-1]
```

We can visualize the probability distribution of the final state after annealing.


```python
probs = np.abs(psi_final.full())**2
plt.figure(figsize=(10, 6))
basis_labels = [f"{i:0{num_nodes}b}" for i in range(2**num_nodes)]
bars=plt.bar(range(len(probs)), probs.flatten())
plt.xticks(ticks=range(len(probs)), labels=basis_labels, rotation=90)
plt.xlabel("States")
plt.ylabel("Probability")
plt.title("Probability Distribution of Final States")

plt.show()
```


    
![png](quantum_annealing_files/quantum_annealing_16_0.png)
    


The final states and their corresponding probabilities are:


```python
final_states = []
for bar, label in zip(bars, basis_labels):
    if bar.get_height() > 1e-4:
        print(f"Final state: {label}, Probability: {bar.get_height():.4f}")
        array_label = np.array([int(bit) for bit in label])
        final_states.append((array_label, bar.get_height())) 
```

    Final state: 01100, Probability: 0.2500
    Final state: 01110, Probability: 0.2500
    Final state: 10001, Probability: 0.2500
    Final state: 10011, Probability: 0.2500


According to the result, there are four degenerate solutions. Let's visualize all the solutions. Meanswhile, we can refer to the result obtained using [QAOA](https://jij-inc.github.io/Qamomile/tutorial/maxcut.html)


```python
from qamomile.core.bitssample import BitsSample, BitsSampleSet
samples = []
for state,prob in final_states:
    sample = BitsSample(int(prob), state)
    samples.append(sample)

sample_set = BitsSampleSet(bitarrays=samples)

transformed_state = []
for transformed in qaoa_converter.decode_bits_to_sampleset(sample_set).data:
    transformed_state.append(transformed.var_values['x'].values)
print(transformed_state)
```

    [{(1,): 1.0, (4,): 1.0}, {(4,): 1.0, (2,): 1.0, (1,): 1.0}, {(0,): 1.0, (3,): 1.0}, {(2,): 1.0, (3,): 1.0, (0,): 1.0}]



```python
edge_colors = []

def get_edge_colors(graph, cut_solution, in_cut_color="r", not_in_cut_color="b"):
    cut_set_1 = [node[0] for node, value in cut_solution.items() if value == 1.0]
    cut_set_2 = [node for node in graph.nodes() if node not in cut_set_1]

    edge_colors = []
    for u, v, _ in graph.edges(data=True):
        if (u in cut_set_1 and v in cut_set_2) or (u in cut_set_2 and v in cut_set_1):
            edge_colors.append(in_cut_color)
        else:
            edge_colors.append(not_in_cut_color)
            
    node_colors = ["#2696EB" if node in cut_set_1 else "#EA9B26" for node in graph.nodes()]
    return edge_colors, node_colors

fig, axes = plt.subplots(2, 2, figsize=(10, 8)) 
axes = axes.flatten()

for i, cut_solution in enumerate(transformed_state):
    
    edge_colors, node_colors = get_edge_colors(G, cut_solution)
    
    # Create the plot
    ax = axes[i]  # Select subplot
    ax.set_title(f"Solution {i+1}")
    
    nx.draw_networkx(
        G,
        pos,
        node_size=500,
        width=3,
        with_labels=True,
        edge_color=edge_colors,
        node_color=node_colors,
        ax=ax,
    )

plt.tight_layout()
plt.show()
```


    
![png](quantum_annealing_files/quantum_annealing_21_0.png)
    


We can also visualize how the eigenenergy of the Hamiltonian changes as the parameter $s$ varies from 0 to 1 on the energy spectrum calculated by `eigenenergies`. 


```python
slist = np.linspace(0.0, 1.0, 101)
enegry_list = [[] for i in range(2**num_nodes)]

for s in slist:
    qt_H = s*qt_H0 + (1-s)*qt_H1
    enegry = qt_H.eigenenergies()
    for i in range(2**num_nodes):
        enegry_list[i].append(enegry[i])
```


```python
for i in range(2**num_nodes):
    plt.plot(slist, enegry_list[i], label=f"{i+1}th")

plt.xlabel("s")
plt.ylabel("Eigenenergies")
plt.title("Energy Spectrum")
plt.show()
```


    
![png](quantum_annealing_files/quantum_annealing_24_0.png)
    


We can see that there are four degenerate states that share the same lowest energy level, which agrees with the annealing result.

Masaphys. *PythonとQuTiPで量子アニーリングのダイナミクスを追う*. Qiita. Accessed October 30, 2024. [https://qiita.com/masaphys/items/38aeaee5313f81e15414](https://qiita.com/masaphys/items/38aeaee5313f81e15414)



```python

```
# Using the QuriPartsTranspiler in Qamomile
This tutorial demonstrates the usage of the QuriPartsTranspiler in Qamomile and provides key examples to guide users in applying it effectively.

## Translating a Hamiltonian into QuriParts

We begin by defining a Hamiltonian as a test example and use our transpiler to convert it into a QuriParts-compatible representation. 
This step shows how seamlessly the Hamiltonian defined in our own library’s format can be translated into operators recognized by QuriParts.


```python
import numpy as np
import qamomile
from qamomile.quri_parts.transpiler import QuriPartsTranspiler
from qamomile.core.operator import Hamiltonian, Pauli, X, Y, Z
from qamomile.core.circuit import QuantumCircuit as QamomileCircuit
from qamomile.core.circuit import (
    QuantumCircuit,
    SingleQubitGate,
    TwoQubitGate,
    ParametricSingleQubitGate,
    ParametricTwoQubitGate,
    SingleQubitGateType,
    TwoQubitGateType,
    ParametricSingleQubitGateType,
    ParametricTwoQubitGateType,
    Parameter
)

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
```

In this snippet, we start from a custom-defined Hamiltonian using various Pauli operators (X, Y, Z) and then employ `QuriPartsTranspiler` to convert it into a format directly suitable for QuriParts. By printing out `quriParts_hamiltonian`, we can verify the correctness of the translation.


```python
hamiltonian = Hamiltonian()
hamiltonian += X(0)*Z(1)
hamiltonian += Y(0)*Y(1)*Z(2)*X(3)*X(4)

transpiler = QuriPartsTranspiler()
quriParts_hamiltonian = transpiler.transpile_hamiltonian(hamiltonian)

quriParts_hamiltonian
```




    {frozenset({(0, <SinglePauli.X: 1>), (1, <SinglePauli.Z: 3>)}): 1.0,
     frozenset({(0, <SinglePauli.Y: 2>),
                (1, <SinglePauli.Y: 2>),
                (2, <SinglePauli.Z: 3>),
                (3, <SinglePauli.X: 1>),
                (4, <SinglePauli.X: 1>)}): 1.0}



## Constructing a Parameterized Quantum Circuit

Next, we build a parameterized quantum circuit using QamomileCircuit. We include single-qubit rotations (e.g., rx, ry, rz) and controlled variants (crx, crz, cry), as well as two-qubit entangling gates (rxx, ryy, rzz). The parameters (theta, beta, gamma) allow for flexible variational adjustments.


```python
qc = QamomileCircuit(3)
theta = Parameter("theta")
beta = Parameter("beta")
gamma = Parameter("gamma")

qc.rx(theta, 0)
qc.ry(beta, 1)
qc.rz(gamma, 2)
qc.rxx(gamma, 0 ,1)
qc.ryy(theta, 1 ,2)
qc.rzz(beta, 2 ,0)

transpiler = QuriPartsTranspiler()
qp_circuit = transpiler.transpile_circuit(qc)
```

## Formulating the MaxCut Problem and Converting it into a Quantum Form

In the following part, we demonstrate how to take a classical optimization problem—MaxCut—and encode it into an Ising-form Hamiltonian. We then construct a QAOA-style ansatz circuit that, when executed and optimized, attempts to solve the MaxCut instance.


```python
def maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem

def maxcut_instance():
    # Construct a simple graph for a MaxCut instance
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 4])
    G.add_edges_from([(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)])
    E = [list(edge) for edge in G.edges]
    instance_data = {"V": G.number_of_nodes(), "E": E}
    pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
    nx.draw_networkx(G, pos, node_size=500)
    return instance_data

problem = maxcut_problem()
instance_data = maxcut_instance()
compiled_instance = jmt.compile_model(problem, instance_data)

# Convert the compiled problem into a QAOA form.
qaoa_converter = qamomile.core.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode()

p = 5
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_8_0.png)
    



```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_9_0.png)
    


We have now translated the MaxCut problem into a cost Hamiltonian suitable for a QAOA-like algorithm. The parameter `p` determines the number of layers of problem and mixer Hamiltonians. Each layer’s parameters are variational and will be tuned to minimize the expvalue, ideally leading to a good solution to the MaxCut instance.

## Transpiling and Executing the QAOA Circuit in PennyLane

With the QAOA circuit and Hamiltonian defined, we use the transpiler again, this time to convert the QAOA circuit and cost Hamiltonian into QuriParts forms:


```python
transpiler = QuriPartsTranspiler()
# Transpile the QAOA circuit to QuriParts
qp_circuit = transpiler.transpile_circuit(qaoa_circuit)

# Transpile the QAOA Hamitltonian to QuriParts
qp_hamiltonian = transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qp_hamiltonian
```




    {frozenset({(0, <SinglePauli.Z: 3>), (1, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(0, <SinglePauli.Z: 3>), (2, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(1, <SinglePauli.Z: 3>), (3, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(1, <SinglePauli.Z: 3>), (4, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(3, <SinglePauli.Z: 3>), (4, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(2, <SinglePauli.Z: 3>), (4, <SinglePauli.Z: 3>)}): 0.5,
     PauliLabel(): -3.0}



Here, `qk_circuit` is the QuriParts circuit generated from the Qamomile QAOA ansatz and `qk_hamiltonian` is build from Qamomile Hamiltonian based on the mathematical model.

## Optimizing the Parameters

Finally, we optimize the variational parameter and attempt to find those that yield better results (e.g., lower cost for the MaxCut objective):


```python
from typing import Sequence
from scipy.optimize import minimize
from quri_parts.core.state import quantum_state, apply_circuit
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator

cost_history = []
# Cost estimator function


cb_state = quantum_state(qp_circuit.qubit_count, bits=0)
parametric_state = apply_circuit(qp_circuit, cb_state)


estimator = create_qulacs_vector_parametric_estimator()

cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(qp_hamiltonian, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost


# Create initial parameters
initial_params = np.random.uniform(low=-np.pi / 4, high=np.pi / 4, size=2 * p)

# Run QAOA optimization
result = minimize(
    cost_fn,
    initial_params,
    method="COBYLA",
    options={"maxiter": 2000},
)
print(result)
```

     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -4.711600340952039
           x: [ 1.579e+00 -9.337e-01  2.224e+00  1.642e+00  9.104e-01
               -9.487e-01 -7.253e-01 -2.557e-01 -4.168e-01  8.613e-01]
        nfev: 2000
       maxcv: 0.0



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_16_0.png)
    


Once the optimized parameters are obtained, we use QuriParts's `create_qulacs_vector_sampler` to sample from the parameterized quantum circuit to get the circuit counts.


```python
# Run Optimized QAOA circuit
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
bounded_circuit = qp_circuit.bind_parameters(result.x)
qp_result = sampler(bounded_circuit, 1000)
```


```python
bitcounts = {bin(i)[2:].zfill(qp_circuit.qubit_count): count for i, count in qp_result.items()}
```


```python
# Prepare data for plotting
keys = list(bitcounts.keys())
values = list(bitcounts.values())

# Plotting
plt.figure(figsize=(12, 6))
plt.bar(keys, values, width=0.6)
plt.xlabel("State", fontsize=12)
plt.ylabel("Frequency", fontsize=12)
plt.title("Distribution of State", fontsize=14)
plt.xticks(rotation=90, fontsize=10)
plt.tight_layout()
plt.show()
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_20_0.png)
    


## Evaluating the Results
From the `qp_result` and `qubit_count` obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
sampleset = qaoa_converter.decode(transpiler, (qp_result, qp_circuit.qubit_count))

plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_22_0.png)
    



```python

```
# Using the QiskitTranspiler in Qamomile
This tutorial demonstrates the usage of the QiskitTranspiler in Qamomile and provides key examples to guide users in applying it effectively.

## Translating a Hamiltonian into Qiskit

We begin by defining a Hamiltonian as a test example and use our transpiler to convert it into a Qiskit-compatible representation. 
This step shows how seamlessly the Hamiltonian defined in our own library’s format can be translated into operators recognized by Qiskit.


```python
import numpy as np
import qamomile
from qamomile.qiskit.transpiler import QiskitTranspiler
from qamomile.core.operator import Hamiltonian, Pauli, X, Y, Z
from qamomile.core.circuit import QuantumCircuit as QamomileCircuit
from qamomile.core.circuit import (
    QuantumCircuit,
    SingleQubitGate,
    TwoQubitGate,
    ParametricSingleQubitGate,
    ParametricTwoQubitGate,
    SingleQubitGateType,
    TwoQubitGateType,
    ParametricSingleQubitGateType,
    ParametricTwoQubitGateType,
    Parameter
)

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
```

In this snippet, we start from a custom-defined Hamiltonian using various Pauli operators (X, Y, Z) and then employ `QiskitTranspiler` to convert it into a format directly suitable for Qiskit. By printing out `qiskit_hamiltonian`, we can verify the correctness of the translation.


```python
hamiltonian = Hamiltonian()
hamiltonian += X(0)*Z(1)
hamiltonian += Y(0)*Y(1)*Z(2)*X(3)*X(4)

transpiler = QiskitTranspiler()
qiskit_hamiltonian = transpiler.transpile_hamiltonian(hamiltonian)

qiskit_hamiltonian
```




    SparsePauliOp(['IIIZX', 'XXZYY'],
                  coeffs=[1.+0.j, 1.+0.j])



## Constructing a Parameterized Quantum Circuit

Next, we build a parameterized quantum circuit using QamomileCircuit. We include single-qubit rotations (e.g., rx, ry, rz) and controlled variants (crx, crz, cry), as well as two-qubit entangling gates (rxx, ryy, rzz). The parameters (theta, beta, gamma) allow for flexible variational adjustments.


```python
qc = QamomileCircuit(3)
theta = Parameter("theta")
beta = Parameter("beta")
gamma = Parameter("gamma")

qc.rx(theta, 0)
qc.ry(beta, 1)
qc.rz(gamma, 2)
qc.crx(gamma, 0 ,1)
qc.crz(theta, 1 ,2)
qc.cry(beta, 2 ,0)
qc.rxx(gamma, 0 ,1)
qc.ryy(theta, 1 ,2)
qc.rzz(beta, 2 ,0)

transpiler = QiskitTranspiler()
qk_circuit = transpiler.transpile_circuit(qc)
```

## Formulating the MaxCut Problem and Converting it into a Quantum Form

In the following part, we demonstrate how to take a classical optimization problem—MaxCut—and encode it into an Ising-form Hamiltonian. We then construct a QAOA-style ansatz circuit that, when executed and optimized, attempts to solve the MaxCut instance.


```python
def maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem

def maxcut_instance():
    # Construct a simple graph for a MaxCut instance
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 4])
    G.add_edges_from([(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)])
    E = [list(edge) for edge in G.edges]
    instance_data = {"V": G.number_of_nodes(), "E": E}
    pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
    nx.draw_networkx(G, pos, node_size=500)
    return instance_data

problem = maxcut_problem()
instance_data = maxcut_instance()
compiled_instance = jmt.compile_model(problem, instance_data)

# Convert the compiled problem into a QAOA form.
qaoa_converter = qamomile.core.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode()

p = 5
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_8_0.png)
    



```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_9_0.png)
    


We have now translated the MaxCut problem into a cost Hamiltonian suitable for a QAOA-like algorithm. The parameter `p` determines the number of layers of problem and mixer Hamiltonians. Each layer’s parameters are variational and will be tuned to minimize the expvalue, ideally leading to a good solution to the MaxCut instance.

## Transpiling and Executing the QAOA Circuit in Qiskit

With the QAOA circuit and Hamiltonian defined, we use the transpiler again, this time to convert the QAOA circuit and cost Hamiltonian into Qiskit forms:


```python
transpiler = QiskitTranspiler()
# Transpile the QAOA circuit to Qiskit
qk_circuit = transpiler.transpile_circuit(qaoa_circuit)

# Transpile the QAOA Hamitltonian to Qiskit
qk_hamiltonian = transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIZZ', 'IIZIZ', 'IZIZI', 'ZIIZI', 'ZZIII', 'ZIZII', 'IIIII'],
                  coeffs=[ 0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j, -3. +0.j])



Here, `qk_circuit` is the Qiskit circuit generated from the Qamomile QAOA ansatz and `qk_hamiltonian` is build from Qamomile Hamiltonian based on the mathematical model.

## Optimizing the Parameters

Finally, we optimize the variational parameter and attempt to find those that yield better results (e.g., lower cost for the MaxCut objective):


```python
import qiskit.primitives as qk_pr
from scipy.optimize import minimize

cost_history = []
# Cost estimator function
estimator = qk_pr.StatevectorEstimator()


def estimate_cost(param_values):
    try:
        job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
        result = job.result()[0]
        cost = result.data["evs"]
        cost_history.append(cost)
        return cost
    except Exception as e:
        print(f"Error during cost estimation: {e}")
        return np.inf


# Create initial parameters
initial_params = np.random.uniform(low=-np.pi / 4, high=np.pi / 4, size=2 * p)

# Run QAOA optimization
result = minimize(
    estimate_cost,
    initial_params,
    method="COBYLA",
    options={"maxiter": 2000},
)
print(result)
```

     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -4.948032219792361
           x: [-5.640e-01 -4.659e-01 -3.222e-01 -5.174e-01  3.372e-01
                4.496e-01  8.850e-01  1.022e+00  1.040e+00 -8.994e-02]
        nfev: 2000
       maxcv: 0.0



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_16_0.png)
    


Once the optimized parameters are obtained, we use Qiskit's `StatevectorSampler` to sample from the parameterized quantum circuit to get the circuit counts.


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=10000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```


```python
# Prepare data for plotting
keys = list(qaoa_counts.get_counts().keys())
values = list(qaoa_counts.get_counts().values())

# Plotting
plt.figure(figsize=(12, 6))
plt.bar(keys, values, width=0.6)
plt.xlabel("State", fontsize=12)
plt.ylabel("Frequency", fontsize=12)
plt.title("Distribution of State", fontsize=14)
plt.xticks(rotation=90, fontsize=10)
plt.tight_layout()
plt.show()
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_19_0.png)
    


## Evaluating the Results
From the `qaoa_counts` obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
sampleset = qaoa_converter.decode(transpiler, qaoa_counts) 
plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_21_0.png)
    



```python

```
# Basic Usage of the Library

Welcome to the Qamomile tutorial! This guide will help you get started with Qamomile, a powerful SDK designed for quantum optimization algorithms. 
Qamomile specializes in the conversion of mathematical models into quantum circuits, serving as a bridge between classical optimization problems and quantum computing solutions.

## Supported Quantum Optimization Encodings and Algorithms

- **QAOA**: Quantum Approximate Optimization Algorithm
- **QRAO**: Quantum Random Approximation Optimization


## Supported Quantum Circuit SDKs

- **Qiskit**
- **Quri-parts**
- **PennyLane**
- **Qutip**


## Tutorials

- [Building Quantum Circuits](building_quantum_circuits.ipynb): Learn how to build a quantum circuit using Qamomile.
- [Write Hamiltonian Algebraically](algebraic_operator.ipynb): Learn how to create a Qamomile Hamiltonian using an algebraic modeler `jijmodeling`.
- [Using the QiskitTranspiler in Qamomile](Using_the_QiskitTranspiler_in_Qamomile.ipynb): Learn how to transpile from Qamomile to Qiskit.
- [Using the QuriPartsTranspiler in Qamomile](Using_the_QuriPartsTranspiler_in_Qamomile.ipynb): Learn how to transpile from Qamomile to Quri-Parts.
- [Using the PennyLaneTranspiler in Qamomile](Using_the_PennyLaneTranspiler_in_Qamomile.ipynb): Learn how to transpile from Qamomile to PennyLane.
- [Using the QuTiPTranspiler in Qamomile](quantum_annealing.ipynb): Learn how to run the Quantum Annealing with QuTiP's built-in functions.

# Write Hamiltonian Algebraically
This tutorial explains how to create a Qamomile Hamiltonian using an algebraic modeler `jijmodeling`.

Using this functionality will allow you to create Hamiltonians in a more intuitive way.


```python
import jijmodeling as jm
import qamomile.core.modeler as qm_m
```

## Write Algebraic Hamiltonian
Let us write Heisenberg model without the external field with periodic boundary condition by using qamomile modeler in this tutorial.

To define Pauli Operator Expression we need to use `qm_m.PauliExpr`.
In the Heisenberg model, there are $X$, $Y$ and $Z$ Pauli Operator, so let us define them first.


```python
N = jm.Placeholder("N")
Z = qm_m.PauliExpr.z(shape=(N,))
X = qm_m.PauliExpr.x(shape=(N,))
Y = qm_m.PauliExpr.y(shape=(N,))
Y
```




$$\displaystyle \hat{Y}$$



Next, let us define the Hamiltonian which is

$$
\hat{H} = - \sum_{i = 0}^{N-1} J_x X_i X_{i+1} + J_y Y_i Y_{i+1} + J_z Z_i Z_{i+1}
$$

Here we assume periodic boundary condition ( $X_N = X_0$ ).

We can define this by using `jijmodeling`.


```python
i = jm.Element("i", belong_to = (0,N))
J_x = jm.Placeholder("J_x")
J_y = jm.Placeholder("J_y")
J_z = jm.Placeholder("J_z")
expr = -jm.sum(i, J_x * X[i] * X[(i+1) % N] + J_y * Y[i] * Y[(i+1) % N] + J_z * Z[i] * Z[(i+1) % N])
h_expr = qm_m.HamiltonianExpr(expr)
h_expr
```




$$\displaystyle - \sum_{i = 0}^{N - 1} \left(J_x \cdot \hat{X}_{i} \cdot \hat{X}_{\left(i + 1\right) \bmod N} + J_y \cdot \hat{Y}_{i} \cdot \hat{Y}_{\left(i + 1\right) \bmod N} + J_z \cdot \hat{Z}_{i} \cdot \hat{Z}_{\left(i + 1\right) \bmod N}\right)$$



## Build Qamomile Hamiltonian from Algebraic Hamiltonian Expression
We can build qamomile `Hamiltonian` by inserting the value into `HamiltonianExpr`.

Let us create some data to insert first. 
We can provide the data as `dict`.

To make it easier to see whether the output of the results is correct, let's create some unusual data.


```python
instance_data = {"N":10, "J_x":1.0, "J_y":-1.0, "J_z":2.0}
```

We can use `HamiltonianBuilder` to insert the instance data into `HamiltonianExpr`.


```python

builder = qm_m.hamiltonian_expr.HamiltonianBuilder(h_expr,instance_data)
h = builder.build()
h
```




    Hamiltonian((X0, X1): -1.0, (Y0, Y1): 1.0, (Z0, Z1): -2.0, (X1, X2): -1.0, (Y1, Y2): 1.0, (Z1, Z2): -2.0, (X2, X3): -1.0, (Y2, Y3): 1.0, (Z2, Z3): -2.0, (X3, X4): -1.0, (Y3, Y4): 1.0, (Z3, Z4): -2.0, (X4, X5): -1.0, (Y4, Y5): 1.0, (Z4, Z5): -2.0, (X5, X6): -1.0, (Y5, Y6): 1.0, (Z5, Z6): -2.0, (X6, X7): -1.0, (Y6, Y7): 1.0, (Z6, Z7): -2.0, (X7, X8): -1.0, (Y7, Y8): 1.0, (Z7, Z8): -2.0, (X8, X9): -1.0, (Y8, Y9): 1.0, (Z8, Z9): -2.0, (X0, X9): -1.0, (Y0, Y9): 1.0, (Z0, Z9): -2.0)



If you also want to check the `Hamiltonian` in LaTex, you can do it as follows.


```python
import IPython.display as ipd

ipd.display(ipd.Latex("$" + h.to_latex() + "$"))
```


$-X_{0}X_{1}+Y_{0}Y_{1}-2.0Z_{0}Z_{1}-X_{1}X_{2}+Y_{1}Y_{2}-2.0Z_{1}Z_{2}-X_{2}X_{3}+Y_{2}Y_{3}-2.0Z_{2}Z_{3}-X_{3}X_{4}+Y_{3}Y_{4}-2.0Z_{3}Z_{4}-X_{4}X_{5}+Y_{4}Y_{5}-2.0Z_{4}Z_{5}-X_{5}X_{6}+Y_{5}Y_{6}-2.0Z_{5}Z_{6}-X_{6}X_{7}+Y_{6}Y_{7}-2.0Z_{6}Z_{7}-X_{7}X_{8}+Y_{7}Y_{8}-2.0Z_{7}Z_{8}-X_{8}X_{9}+Y_{8}Y_{9}-2.0Z_{8}Z_{9}-X_{0}X_{9}+Y_{0}Y_{9}-2.0Z_{0}Z_{9}$

# Qamomile Tutorial

Welcome to the Qamomile tutorial! This guide will help you get started with Qamomile, a powerful SDK designed for quantum optimization algorithms. Qamomile specializes in the conversion of mathematical models into quantum circuits, serving as a bridge between classical optimization problems and quantum computing solutions.

## Supported Quantum Optimization Encodings and Algorithms

- **QAOA**: Quantum Approximate Optimization Algorithm
- **QRAO**: Quantum Random Approximation Optimization


## Supported Quantum Circuit SDKs

- **Qiskit**
- **Quri-parts**
- **Qutip**


## Tutorials

- [Building Quantum Circuits](building_quantum_circuits.ipynb): Learn how to build a quantum circuit using Qamomile.
- [Write Hamiltonian Algebraically](algebraic_operator.ipynb): Learn how to create a Qamomile Hamiltonian using an algebraic modeler `jijmodeling`.
- [Quantum Alternating Ansatz for Graph Coloring](alternating_ansatz_graph_coloring.ipynb): Learn how to run the Quantum Alternating Ansatz for graph coloring problem.
- [Quantum Approximate Optimization Algorithm for Graph Partitioning](graph_partition.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for graph partitioning problem.
- [Quantum Approximate Optimization Algorithm for vertex covering](vertex_cover.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for vertex cover problem.
- [Quantum Approximate Optimization Algorithm for Max-Cut](maxcut.ipynb): Learn how to run the Quantum Quantum Approximate Optimization Algorithm for Max-Cut problem.
- [Quantum Approximate Optimization Algorithm for Multi-car Paint Shop Problem](multi_car_paint.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for multi-car paint shop problem.
- [Quantum Random Access Optimization (QRAO) for Maxcut problem](qrao_tutorial.ipynb): Learn how to use Quantum Random Access Optimization.
- [Quantum Approximate Optimization Algorithm for Travelling Salesman Problem](qaoa/Travelling_Salesman_Problem.ipynb): Learn how to run the Quantum Approximate Optimization Algorithm for Travelling Salesman Problem.
- [Quantum Annealing using QuTiP](quantum_annealing.ipynb): Learn how to run the Quantum Annealing with QuTiP's built-in functions.
- [Using the PennyLaneTranspiler in Qamomile](Using_the_PennyLaneTranspiler_in_Qamomile.ipynb): Learn how to transpile from Qamomile to PennyLane.

# Qamomile Quickstart Guide

This guide will help you get started with Qamomile quickly, covering installation and basic usage.

## Installation

### Prerequisites
Before installing Qamomile, ensure you have the following:

- Python 3.10 or higher
- pip (Python package installer)

### Installing Qamomile

Install Qamomile using pip:

```bash
pip install qamomile
```

### Optional Dependencies

Depending on your needs, you might want to install additional packages:

- For Qiskit integration: `pip install "qamomile[qiskit]"`
- For Quri Parts integration: `pip install "qamomile[quri-parts]"`
- For Qutip integration: `pip install "qamomile[qutip]"`

## Basic Usages

Let's walk through a simple example to demonstrate how to use Qamomile.

### 1. Import Qamomile and JijModeling


```python
import qamomile.core as qm
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
```

### 2. Create a Mathematical Model with JijModeling


```python
# Simple QUBO

Q = jm.Placeholder("Q", ndim=2)
n = Q.len_at(0, latex="n")
x = jm.BinaryVar("x", shape=(n,))

problem = jm.Problem("qubo")
i, j = jm.Element("i", n), jm.Element("j", n)
problem += jm.sum([i, j], Q[i, j] * x[i] * x[j])

problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{qubo} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{n - 1} \sum_{j = 0}^{n - 1} Q_{i, j} \cdot x_{i} \cdot x_{j} & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$




```python
# Prepare data
instance_data = {
    "Q": [[0.1, 0.2, -0.1],
          [0.2, 0.3, 0.4],
          [-0.1, 0.4, 0.0]]
}

# Compile the problem:
# Substitute the data into the problem.
compiled_instance = jmt.compile_model(problem, instance_data)
```

### 3. Create a Quantum Circuit and a Hamiltonian with Qamomile


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)

# Encode to Ising Hamiltonian
qaoa_converter.ising_encode()

# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=2)
# Get the cost Hamiltonian
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
```

### 4. Transpile to a Quantum Computing SDK (Qiskit or Quri Parts)
In this example, we will use Qiskit.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()

# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_circuit.draw(output="mpl")
```




    
![png](quickstart_files/quickstart_9_0.png)
    




```python
# Transpile the QAOA Hamiltonian to Qiskit
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIZ', 'IZI', 'ZII', 'IZZ', 'ZIZ', 'ZZI'],
                  coeffs=[-0.1 +0.j, -0.45+0.j, -0.15+0.j,  0.1 +0.j, -0.05+0.j,  0.2 +0.j])



### 5. Run the Quantum Circuit

Run the quantum circuit on a quantum simulator or a real quantum computer.  
In this example, we will use the Qiskit.  

In Qamomile, the execution of quantum circuits is delegated to the respective SDKs, allowing users to implement this part themselves if they choose to do so. Given that the primary applications of current quantum computers are research and education, we believe that the majority of cases where quantum optimization algorithms are executed will fall under these categories. To avoid turning Qamomile into a black box, the execution of quantum circuits is left to the users, making it easier to customize algorithms.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

# Run QAOA optimization
result = minimize(
    cost_estimator,
    [np.pi / 4, np.pi / 2, np.pi / 2, np.pi / 4],
    method="COBYLA",
    options={"maxiter": 1000},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -0.428242617622815
           x: [ 8.005e-01  1.940e+00  1.020e+00  1.509e+00]
        nfev: 281
       maxcv: 0.0



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](quickstart_files/quickstart_13_0.png)
    



```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
qaoa_counts.get_counts()
```




    {'000': 622, '100': 107, '010': 8, '001': 226, '101': 35, '011': 1, '111': 1}



### 6. Decode the Result

After running the quantum circuit, decode the result to obtain the solution.


```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.05)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()

```


    
![png](quickstart_files/quickstart_16_0.png)
    



```python

```
# Contributing to qamomile Documentation

We welcome contributions to the qamomile documentation! This guide will help you get started with contributing to our docs using Jupyter Book.

## Prerequisites

Before you begin, ensure you have the following installed:

1. Python 3.x
2. Git
3. Jupyter Book (`pip install jupyter-book`)

## Setting Up

1. Fork the qamomile repository on GitHub.
2. Clone your fork locally:
   ```
   gh repo clone username/Qamomile
   cd Qamomile
   ```
3. Create a virtual environment and activate it:
   ```
   poetry install
   poetry shell
   ```

## Making Changes to the Documentation

1. Navigate to the `docs/` directory in your local repository.
2. Find the appropriate Markdown (`.md`) or Jupyter Notebook (`.ipynb`) file you want to edit, or create a new one.
3. Make your changes using your preferred text editor.
4. If you're adding new pages, update the `_toc.yml` file to include your new page in the table of contents.

## Building the Documentation Locally

To preview your changes:

1. From the `docs/` directory, run:
   ```
   jupyter-book build .
   ```
2. Open `_build/html/index.html` in your web browser to view the built documentation.

## Submitting Your Changes

1. Commit your changes:
   ```
   git add .
   git commit -m "Brief description of your changes"
   ```
2. Push to your fork:
   ```
   git push origin main
   ```
3. Create a pull request from your fork to the main qamomile repository on GitHub.

## Style Guidelines

- Use clear, concise language.
- Follow the existing documentation structure and formatting.
- Include code examples where appropriate, especially when explaining qamomile's features or API.
- Use proper Markdown syntax for headings, lists, code blocks, etc.
- When documenting code, follow the docstring style used in the qamomile project.

## Documentation Structure

Our documentation is organized as follows:

- `index.md`: The main landing page
- `quickstart.md`: Guide for new users
- `api/`: API reference documentation for qamomile.
- `tutorial/`: Usage examples and tutorials
- `contribute.md`: This guide

Feel free to suggest improvements to this structure if you think it can be made more intuitive.

## Questions or Need Help?

If you have any questions or need assistance while contributing, please don't hesitate to:

- Open an issue on GitHub
- Reach out to the maintainers via [contact method]

Thank you for your interest in improving qamomile's documentation!# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh
# Welcome to Qamomile

Qamomile is a powerful SDK designed for quantum optimization algorithms, specializing in the conversion of mathematical models into quantum circuits. It serves as a bridge between classical optimization problems and quantum computing solutions.

## Key Features

- **Versatile Compatibility**: Supports leading quantum circuit SDKs including Qiskit and Quri-parts.
- **Advanced Algorithm Support**: Goes beyond QAOA to include sophisticated encoding and algorithms like QRAO.
- **Flexible Model Conversion**: Utilizes JijModeling for describing mathematical models and converting them to various quantum circuit SDKs.
- **Intermediate Representation**: Capable of representing both Hamiltonians and quantum circuits as intermediate forms.
- **Standalone Functionality**: Can implement quantum circuits independently, similar to other quantum circuit SDKs.

## Quick Start

To get started with Qamomile, please see the [Quick Start Guide](quickstart.ipynb) for installation instructions and a simple example.

## Learn More

Explore our documentation to dive deeper into Qamomile's capabilities:

- [Quick Start Guide](quickstart.ipynb): Installation instructions and a simple example to get you started.
- [API Reference](api/index.md): Complete documentation of Qamomile's API.
- [Tutorials](tutorial/index.md): Step-by-step guides and examples to get you started.

## Contributing

We welcome contributions from the community! If you're interested in improving Qamomile, please check out our [Contribution Guidelines](contribute.md).

## Support

If you encounter any issues or have questions, please file an issue on our [GitHub repository](https://github.com/Jij-Inc/Qamomile) or join our community discussion forum.

Welcome aboard, and happy quantum optimizing with Qamomile!# API Reference

```{eval-rst}
.. autoapisummary::
# Graph Coloring Problem with Quantum Alternating Operator Ansatz
In this tutorial, we will solve the Graph Coloring Problem using the Quantum Alternating Operator Ansatz.


```python
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as opt
import networkx as nx
import qiskit.primitives as qk_pr

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt

import qamomile.core as qm
from qamomile.qiskit import QiskitTranspiler
from qamomile.core.circuit.drawer import plot_quantum_circuit
```

First, we will implement the mathematical model of the graph coloring problem using JijModeling.


```python
def graph_coloring_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    N = jm.Placeholder("N")
    x = jm.BinaryVar("x", shape=(V, N))
    n = jm.Element("i", belong_to=(0, N))
    v = jm.Element("v", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)
    # set problem
    problem = jm.Problem("Graph Coloring")
    # set one-hot constraint that each vertex has only one color

    problem += jm.Constraint("one-color", x[v, :].sum() == 1, forall=v)
    # set objective function: minimize edges whose vertices connected by edges are the same color
    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])
    return problem

problem = graph_coloring_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Coloring} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 1} \sum_{e \in E} x_{e_{0}, i} \cdot x_{e_{1}, i} & \\\text{{s.t.}} & & & \\ & \text{one-color} & \displaystyle \sum_{\ast_{1} = 0}^{N - 1} x_{v, \ast_{1}} = 1 & \forall v \in \left\{0,\ldots,V - 1\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will create an instance of the problem.


```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])
nx.draw(G)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_5_0.png)
    



```python
inst_E = [list(edge) for edge in G.edges]
color_num = 3
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "N": color_num, "E": inst_E}
num_qubits = num_nodes * color_num
```

# Quantum Alternating Operator Ansatz
Next, let's try solving the graph coloring problem using the Quantum Alternating Operator Ansatz. The Quantum Alternating Operator Ansatz[2] is a modification of QAOA, where the mixer is changed from an $X$-mixer to a mixer tailored to the problem, ensuring that only solutions satisfying the constraints are searched for. For more detailed information, please refer to the original paper. Here, we will look at how to implement it in JTQ.

For the Graph Coloring problem, there is a one-hot constraint:

$$
\sum_k x_{v,k} = 1\quad \forall v
$$

However, turning this into an $XY$-mixer is the Quantum Alternating Operator Ansatz approach to the Graph Coloring problem.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
```


```python
gamma_1 = qm.circuit.Parameter("gamma_1")
# Delete one-color penalty.
qaoa_converter.ising_encode(multipliers={"one-color": 0.0})
# Get exp(-i gamma H_P) circuit without mixer circuit.  
qaoa_cost_circuit = qaoa_converter.get_cost_ansatz(gamma_1)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```

Next, we will create an $XY$-mixer. The $XY$-mixer can be written as

$$
XY_{ij} = \frac{1}{2}\left(X_iX_j + Y_iY_j \right).
$$

This is an operator that swaps the bits 1 and 0 in bit $i,j$. Therefore, it can transform a bit string $100$, which satisfies the one-hot constraint, into another bit string $010$, which also satisfies the one-hot constraint.

Here, the only part under the one-hot constraint is related to color, so in terms of the mathematical model, we need to transform the bits between $x_{v0}$ and $x_{v1}$.
On the other hand, as these variables are usually embedded in qubits, it is necessary to remember which bit corresponds to which variable when constructing the algorithm and handle them appropriately.
In JTQ, the correspondence of variables is contained in var_map inside CompiledInstance.
```python
var_map['variable_name'][indices]
```
You can check which qubit corresponds to a variable in the mathematical model in this way.
Let's use this to create an $XY$-mixer.

What we want here is the transformation between $x_{v,k}$ and $x_{v,k+1}$, so we can obtain the index of the corresponding qubit by accessing compiled_instance.var_map.var_map["x"][(i,k)]."


```python
def create_xy_mixer(
    beta: qm.circuit.Parameter,
    num_nodes: int,
    num_color: int,
    compiled_instance: jmt.CompiledInstance,
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n, name="XY-mixer")
    var_map = compiled_instance.var_map.var_map["x"]
    # even
    for i in range(num_nodes):
        for k in range(0, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # odd
    for i in range(num_nodes):
        for k in range(1, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # ini-last
    if num_color % 2 == 1:
        for i in range(num_nodes):
            qc.rxx(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
            qc.ryy(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
    return qc
```


```python
def create_initial_state(
    compiled_instance: jmt.CompiledInstance, num_nodes: int, num_color: int
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n)
    var_map = compiled_instance.var_map.var_map["x"]
    for i in range(num_nodes):
        qc.x(var_map[(i, 0)])  # set all nodes to color 0
    return qc
```

Now that the Ansatz has been created, we would like to run the Quantum Alternating Operator Ansatz.


```python
initial_circuit = create_initial_state(compiled_instance, num_nodes, color_num)
initial_circuit.update_qubits_label(qaoa_converter.int2varlabel)
beta_1 = qm.circuit.Parameter("beta_1")
mixer_circuit = create_xy_mixer(beta_1, num_nodes, color_num, compiled_instance)
mixer_circuit.update_qubits_label(qaoa_converter.int2varlabel)
plot_quantum_circuit(mixer_circuit)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_14_0.png)
    



```python
initial_circuit.append(qaoa_cost_circuit)
initial_circuit.append(mixer_circuit)

alternating_ansatz = initial_circuit

plot_quantum_circuit(alternating_ansatz)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_15_0.png)
    


## Run Quantum Alternating Operator Ansatz using Qiskit


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(alternating_ansatz)
qk_cost = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []

def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data["evs"]
    cost_history.append(cost)
    return cost


result = opt.minimize(
    estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 100}
)
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: 2.0625000215201315
           x: [ 7.853e-01  1.102e+00]
        nfev: 34
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_19_0.png)
    



```python
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
plt.show()
job = sampler.run([(qk_circuit, result.x)])
job_result = job.result()
```


```python
sampleset = qaoa_converter.decode(qk_transpiler, job_result[0].data['meas'])
```


```python
import numpy as np
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.experimental.SampleSet):
    # extract feasible solution
    feasibles = sampleset.feasibles()
    if len(feasibles) == 0:
        print("No feasible solution found ...")
    else:
        lowest_sample = sampleset.lowest()[0]

        # get indices of x = 1
        indices = lowest_sample.var_values["x"].values.keys()
        # get vertices and colors
        # initialize vertex color list
        node_colors = [-1] * graph.number_of_nodes()
        # set color list for visualization
        colorlist = ["gold", "violet", "limegreen", "darkorange"]
        # set vertex color list
        for i, j in indices:
            node_colors[i] = colorlist[j]
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)
        plt.show()

plot_graph_coloring(G, sampleset)
```


    
![png](graph_coloring_alternating_ansatz_files/graph_coloring_alternating_ansatz_22_0.png)
    


# References
[[1] Farhi, Edward, Jeffrey Goldstone, and Sam Gutmann. "A quantum approximate optimization algorithm." arXiv preprint arXiv:1411.4028 (2014).](https://arxiv.org/abs/1411.4028)

[[2] Hadfield, Stuart, Zhihui Wang, Bryan O’gorman, Eleanor G. Rieffel, Davide Venturelli, and Rupak Biswas. "From the quantum approximate optimization algorithm to a quantum alternating operator ansatz." Algorithms 12, no. 2 (2019): 34.](https://arxiv.org/abs/1709.03489)
# Quantum Random Access Optimization (QRAO) for Maxcut problem

In this tutorial, we will explain the quantum optimization algorithm called Quantum Random Access Optimization (QRAO)[1].

In the usual QAOA ($(1,1,1)$-QRAO), the optimization problem is encoded in the Ising Hamiltonian. 
In this case, the problem Hamiltonian uses only the Pauli $Z$ operator, but in QRAO, the problem Hamiltonian is constructed using not only Pauli $Z$, but also Pauli $X$ and $Y$.
The Hamiltonian constructed by QRAO is called a relaxed Hamiltonian because the ground state of the relaxed Hamiltonian is not the optimal solution to the original problem.

Several QRAOs have been proposed. The following QRAOs are supported by Qamomile.

| algorithm name | `class name` |
| ---- | ---- |
| $(3,1,p)$-QRAO [1] | [`QRAC31Converter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao31/index.html) |
| $(2,1,p)$-QRAO [1] | [`QRAC21Converter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao21/index.html) |
| $(3,2,p)$-QRAO [2] | [`QRAC32Converter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao32/index.html) |
| Space Compression Ratio Preserving QRAO [2] | [`QRACSpaceEfficientConverter`](https://jij-inc.github.io/Qamomile/autoapi/core/converters/qrao/qrao_space_efficient/index.html) |

The API documentation explains how each algorithm constructs a relaxed Hamiltonian.


```python
import networkx as nx
import matplotlib.pyplot as plt
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile.core as qm
import qamomile.qiskit as qm_qk
```

# Create problem data and mathematical model
First, we will create the problem data to be solved.

Here, we will solve the maxcut problem for a 3-regular graph, in the same way as [1].


```python
def Maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e,  (1 - si * sj))
    problem += obj
    return problem

problem = Maxcut_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Maxcut} & & \\& & \max \quad \displaystyle 0.5 \cdot \sum_{e \in E} \left(- s_{e[0]} \cdot s_{e[1]} + 1\right) & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



We will create a problem with 12 nodes.


```python
graph = nx.random_regular_graph(3, 12)
nx.draw(graph, with_labels=True)
```


    
![png](qrao_tutorial_files/qrao_tutorial_5_0.png)
    


# Create QRAO Hamiltonian
From here, we will create the relaxed Hamiltonian for QRAO.

First, use `jijmodeling_transpiler` to create a compiled_instance


```python
compiled_instance = jmt.compile_model(problem, {"E": list(graph.edges), "V": len(graph.nodes)})
```

Next, use `QRAC31Converter` to create a relaxed Hamiltonian.


```python
from qamomile.core.converters.qrao.qrao31 import QRAC31Converter

# Initialize with a compiled optimization problem instance
qrao_converter = QRAC31Converter(compiled_instance, normalize_model=False)

# Generate relaxed Hamiltonian
qrao31_hamiltonian = qrao_converter.get_cost_hamiltonian()
qrao31_hamiltonian
```




    Hamiltonian((Z0, Z1): 1.5, (Z0, Z2): 1.5, (Z0, X2): 1.5, (Z1, X2): 1.5, (Z1, Z2): 1.5, (X0, X1): 1.5, (X0, Y1): 1.5, (X0, Z3): 1.5, (Y0, X1): 1.5, (X1, Y2): 1.5, (Y2, Z3): 1.5, (Y2, X3): 1.5, (Z2, Z3): 1.5, (Y1, Z4): 1.5, (Y0, Z4): 1.5, (X3, Z4): 1.5, (Y1, X2): 1.5, (Y0, X3): 1.5)



Since we will use VQE in QRAO, we will create an VQE ansatz.
We can create a simple ansatz using `create_efficient_su2_circuit`.


```python
from qamomile.core.ansatz.efficient_su2 import create_efficient_su2_circuit
from qamomile.core.circuit.drawer import plot_quantum_circuit

ansatz = create_efficient_su2_circuit(qrao31_hamiltonian.num_qubits, rotation_blocks = ["ry", "rz"], reps = 1)
plot_quantum_circuit(ansatz)
```


    
![png](qrao_tutorial_files/qrao_tutorial_11_0.png)
    


Above qamomile Hamiltonian and circuit can be converted into Qiskit Hamiltonian and circuit using `QiskitTranspiler`


```python
qk_transpiler = qm_qk.QiskitTranspiler()
qk_ansatz = qk_transpiler.transpile_circuit(ansatz)
qk_qrao31_hamiltonian = qk_transpiler.transpile_hamiltonian(qrao31_hamiltonian)
```

You can also create QAOA Hamiltonian using `QAOAConverter`.



```python
from qamomile.core.converters.qaoa import QAOAConverter
qaoa_hamiltonian = QAOAConverter(compiled_instance, normalize_model=False).get_cost_hamiltonian()
qk_qaoa_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
```


```python
print("The compression ratio of this problem is ", qaoa_hamiltonian.num_qubits / qrao31_hamiltonian.num_qubits)
```

    The compression ratio of this problem is  2.4


# Obtain grand state of the relaxed Hamiltonian
We have created the relaxed Hamiltonian and VQE ansatz, so let us run VQE using qiskit.



```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_ansatz, qk_qrao31_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

initial_params = np.random.uniform(0, np.pi, len(qk_ansatz.parameters))

# Run QAOA optimization
result = minimize(
    cost_estimator,
    initial_params,
    method="COBYLA",
    options={"maxiter": 10000},
)
print(result)
```

     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -9.4649972737437
           x: [ 3.075e+00  1.912e+00 ... -3.416e-03  4.928e-05]
        nfev: 10000
       maxcv: 0.0


Let's also check the optimal value using diagonalization and plot them.


```python
from scipy.sparse.linalg import eigsh

qrao_eigvals = eigsh(qk_qrao31_hamiltonian.to_matrix(), k=1, which='SA', return_eigenvectors=False)
qaoa_eigvals = eigsh(qk_qaoa_hamiltonian.to_matrix(), k=1, which='SA', return_eigenvectors=False)
```


```python
plt.plot(- (np.array(cost_history) + qrao31_hamiltonian.constant), label = "VQE")
plt.hlines(-(qrao_eigvals + qrao31_hamiltonian.constant), 0, len(cost_history), linestyles="dashed", label="Optimal Quantum Relaxed Value",colors="red")
plt.hlines(-(qaoa_eigvals + qrao31_hamiltonian.constant), 0, len(cost_history), linestyles="dashed", label="Optimal Binary Solution",colors="black")
plt.xlabel("Iteration")
plt.ylabel("Objective Value")
plt.xscale("log")
plt.legend(loc="lower right")
plt.show()
```


    
![png](qrao_tutorial_files/qrao_tutorial_21_0.png)
    


This is quite similar to Fig. 2 in [1].

# Pauli Rounding

As we mentioned, the ground state of the relaxed Hamiltonian is not classical optimal solution.
We need the rounding algorithm to decode the classical solution from the quantum state.

[1] proposed two rounding algorithms, Pauli Rounding and Magic State Rounding.
In this tutorial, we use Puali Rounding to decode the classical solution.

We can get Pauli Operators list using `get_encoded_pauli_list`.
The order of the Pauli operators corresponds to the order of the corresponding encoded variables.


```python
pauli_list = qrao_converter.get_encoded_pauli_list()
print(pauli_list)
```

    [Hamiltonian((Z0,): 1.0), Hamiltonian((Z1,): 1.0), Hamiltonian((Z2,): 1.0), Hamiltonian((X2,): 1.0), Hamiltonian((X0,): 1.0), Hamiltonian((X1,): 1.0), Hamiltonian((Y1,): 1.0), Hamiltonian((Z3,): 1.0), Hamiltonian((Y0,): 1.0), Hamiltonian((Y2,): 1.0), Hamiltonian((X3,): 1.0), Hamiltonian((Z4,): 1.0)]


We can calculate the expecation value of this.


```python
qiskit_pauli_list = [qk_transpiler.transpile_hamiltonian(pauli) for pauli in pauli_list]

estimator = qk_pr.StatevectorEstimator()
job = estimator.run([(qk_ansatz, pauli, result.x) for pauli in qiskit_pauli_list])
rounded_values = [np.sign(_res.data['evs']) for _res in job.result()]
binary_values = [(1 - _val) // 2 for _val in rounded_values]
binary_values
```




    [0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0]



We can map this bianry variable result into `sampleset` using `decode_bits_to_sampleset`.


```python
bitsample = qm.BitsSample(1,binary_values)
sampleset = qrao_converter.decode_bits_to_sampleset(qm.BitsSampleSet([bitsample]))
```

Finally, we have result!
Let us visualize it.


```python
def get_edge_colors(
    graph, cut_solution, in_cut_color="r", not_in_cut_color="b"
):
    cut_set_1 = [node[0] for node, value in cut_solution.items() if value == 1.0]
    cut_set_2 = [node for node in graph.nodes() if node not in cut_set_1]

    edge_colors = []
    for u, v, _ in graph.edges(data=True):
        if (u in cut_set_1 and v in cut_set_2) or (u in cut_set_2 and v in cut_set_1):
            edge_colors.append(in_cut_color)
        else:
            edge_colors.append(not_in_cut_color)
    node_colors = ["#2696EB" if node in cut_set_1 else "#EA9b26" for node in graph.nodes()]
    return edge_colors, node_colors
```


```python
best_values = sampleset[0].var_values["x"].values
edge_colors, node_colors = get_edge_colors(graph, best_values)
edge_labels = nx.get_edge_attributes(graph, "weight")

plt.title("G=(V,E) QAOA")
plt.plot(figsize=(5, 4))
nx.draw_networkx(
    graph,
    node_size=500,
    width=3,
    with_labels=True,
    edge_color=edge_colors,
    node_color=node_colors,
)

```


    
![png](qrao_tutorial_files/qrao_tutorial_32_0.png)
    


# References
[1] Bryce Fuller, Charles Hadfield, Jennifer R. Glick, Takashi Imamichi, Toshinari Itoko, Richard J. Thompson, Yang Jiao, Marna M. Kagele, Adriana W. Blom-Schieber, Rudy Raymond, and Antonio Mezzacapo. Approximate solutions of combinatorial problems via quantum relaxations. IEEE Transactions on Quantum Engineering, 5():1–15, 2024. doi:10.1109/TQE.2024.3421294.

[2] Kosei Teramoto, Rudy Raymond, Eyuri Wakakuwa, and Hiroshi Imai. Quantum-relaxation based optimization algorithms: theoretical extensions. 2023. URL: https://arxiv.org/abs/2302.09481, arXiv:2302.09481.
# Quantum Alternating Operator Ansatz for Graph Coloring Problem with Qiskit and Quri-Parts
In this tutorial, we would like to explain the functionality while solving the Graph Coloring Problem using the Quantum Approximate Optimization Algorithm and the Quantum Alternating Operator Ansatz. This time, we are going to conduct simulations using qiskit and quri-parts.


```python
import networkx as nx
import scipy.optimize as opt
import numpy as np
import qiskit.primitives as qk_pr

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt

import qamomile.core as qm
from qamomile.qiskit import QiskitTranspiler
from qamomile.core.circuit.drawer import plot_quantum_circuit
```

First, we will implement the mathematical model of the graph coloring problem using JijModeling.


```python
def graph_coloring_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    N = jm.Placeholder("N")
    x = jm.BinaryVar("x", shape=(V, N))
    n = jm.Element("i", belong_to=(0, N))
    v = jm.Element("v", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)
    # set problem
    problem = jm.Problem("Graph Coloring")
    # set one-hot constraint that each vertex has only one color

    problem += jm.Constraint("one-color", x[v, :].sum() == 1, forall=v)
    # set objective function: minimize edges whose vertices connected by edges are the same color
    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])
    return problem

problem = graph_coloring_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Coloring} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 1} \sum_{e \in E} x_{e_{0}, i} \cdot x_{e_{1}, i} & \\\text{{s.t.}} & & & \\ & \text{one-color} & \displaystyle \sum_{\ast_{1} = 0}^{N - 1} x_{v, \ast_{1}} = 1 & \forall v \in \left\{0,\ldots,V - 1\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will create an instance of the problem.


```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])
nx.draw(G)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_5_0.png)
    



```python
inst_E = [list(edge) for edge in G.edges]
color_num = 3
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "N": color_num, "E": inst_E}
num_qubits = num_nodes * color_num
```

# Quantum Approximate Optimazation Algorithm (QAOA)
The Quantum Approximate Optimization Algorithm (QAOA) is one of the quantum optimization algorithms that use a variational quantum circuit. For a detailed explanation, please refer to paper [1], but here we will only give a rough overview.
In QAOA, a variational quantum circuit is constructed by applying the Ising Hamiltonian $H_P = \sum_{ij}J_{ij}Z_iZ_j$ and the $X$-mixer Hamiltonian $H_M = \sum_iX_i$ in the following way:
If we start with an initial state $\ket{\psi_0}$, then

$$
\ket{\psi(\beta,\gamma)} = e^{-i\beta_pH_M}e^{-i\gamma_pH_P}\cdots e^{-i\beta_1H_M}e^{-i\gamma_1H_P}\ket{\psi_0}
$$

can be written. Here, $\beta_k,\gamma_k$ are the parameters to be optimized, and since the operation $e^{-\beta_kH_M}e^{-\gamma_kH_P}$ is repeated $p$ times, there are a total of $2p$ parameters. In the standard QAOA, the total number of parameters is independent of the number of qubits and depends only on the number of repetitions.

Optimization of $\beta_k,\gamma_k$ is performed by repeating the following steps 1 and 2:

1. Compute the expectation value $\bra{\psi(\beta,\gamma)}H_P\ket{\psi(\beta,\gamma)}$ on a quantum device.
2. Update the parameters on a classical computer to minimize the expectation value.

By repeating this calculation of the expectation value on the quantum computer and optimization of parameters on the classical computer, we obtain the minimum energy $\langle H_P \rangle$ and the corresponding final state. If we consider QAOA as a mathematical optimization algorithm, this minimum energy corresponds to the minimum objective function value, and the final state becomes the optimal solution.

## Implementing QAOA using Qamomile
Now, let's try solving the Graph Coloring Problem using QAOA.
To execute QAOA, it's necessary to convert the mathematical model into an Ising Hamiltonian, and then create a variational quantum circuit and Hamiltonian using a quantum computing library. However, since Qamomile supports QAOA, it allows for relatively easy execution.

First, using JijModeling-Transpiler, we create a CompiledInstance from JijModeling's mathematical model and instance data.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

Next, we create a QAOAConverter. By setting the weight for the constraints on this Converter, we can create the Hamiltonian.


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode(multipliers={"one-color": 1})
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=1)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


```python
plot_quantum_circuit(qaoa_circuit)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_12_0.png)
    


## Run QAOA using Qiskit

Now that we have the variational quantum circuit and Hamiltonian ready, let's actually execute QAOA using Qiskit.  
Transpile the qamomile's circuit to the qiskit's circuit and run the simulation.


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_cost = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []
def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data['evs']
    cost_history.append(cost)
    return cost

result = opt.minimize(estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 100})
result
```




     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: 5.889501085009066
           x: [ 9.116e-01 -6.631e-01]
        nfev: 100
       maxcv: 0.0




```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_16_0.png)
    


# Quantum Alternating Operator Ansatz
Next, let's try solving the graph coloring problem using the Quantum Alternating Operator Ansatz. The Quantum Alternating Operator Ansatz[2] is a modification of QAOA, where the mixer is changed from an $X$-mixer to a mixer tailored to the problem, ensuring that only solutions satisfying the constraints are searched for. For more detailed information, please refer to the original paper. Here, we will look at how to implement it in JTQ.

For the Graph Coloring problem, there is a one-hot constraint:

$$
\sum_k x_{v,k} = 1\quad \forall v
$$

However, turning this into an $XY$-mixer is the Quantum Alternating Operator Ansatz approach to the Graph Coloring problem.


```python
gamma_1 = qm.circuit.Parameter("gamma_1")
# Delete one-color penalty.
qaoa_converter.ising_encode(multipliers={"one-color": 0.0})
# Get exp(-i gamma H_P) circuit without mixer circuit.  
qaoa_cost_circuit = qaoa_converter.get_cost_ansatz(gamma_1)
```

Next, we will create an $XY$-mixer. The $XY$-mixer can be written as

$$
XY_{ij} = \frac{1}{2}\left(X_iX_j + Y_iY_j \right).
$$

This is an operator that swaps the bits 1 and 0 in bit $i,j$. Therefore, it can transform a bit string $100$, which satisfies the one-hot constraint, into another bit string $010$, which also satisfies the one-hot constraint.

Here, the only part under the one-hot constraint is related to color, so in terms of the mathematical model, we need to transform the bits between $x_{v0}$ and $x_{v1}$.
On the other hand, as these variables are usually embedded in qubits, it is necessary to remember which bit corresponds to which variable when constructing the algorithm and handle them appropriately.
In JTQ, the correspondence of variables is contained in var_map inside CompiledInstance.
```python
var_map['variable_name'][indices]
```
You can check which qubit corresponds to a variable in the mathematical model in this way.
Let's use this to create an $XY$-mixer.

What we want here is the transformation between $x_{v,k}$ and $x_{v,k+1}$, so we can obtain the index of the corresponding qubit by accessing compiled_instance.var_map.var_map["x"][(i,k)]."


```python
def create_xy_mixer(
    beta: qm.circuit.Parameter,
    num_nodes: int,
    num_color: int,
    compiled_instance: jmt.CompiledInstance,
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n, name="XY-mixer")
    var_map = compiled_instance.var_map.var_map["x"]
    # even
    for i in range(num_nodes):
        for k in range(0, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # odd
    for i in range(num_nodes):
        for k in range(1, num_color - 1, 2):
            qc.rxx(beta, var_map[(i, k)], var_map[(i, k + 1)])
            qc.ryy(beta, var_map[(i, k)], var_map[(i, k + 1)])

    # ini-last
    if num_color % 2 == 1:
        for i in range(num_nodes):
            qc.rxx(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
            qc.ryy(beta, var_map[(i, 0)], var_map[(i, num_color - 1)])
    return qc
```


```python
def create_initial_state(
    compiled_instance: jmt.CompiledInstance, num_nodes: int, num_color: int
):
    n = num_color * num_nodes
    qc = qm.circuit.QuantumCircuit(n)
    var_map = compiled_instance.var_map.var_map["x"]
    for i in range(num_nodes):
        qc.x(var_map[(i, 0)])  # set all nodes to color 0
    return qc
```

Now that the Ansatz has been created, we would like to run the Quantum Alternating Operator Ansatz.


```python
initial_circuit = create_initial_state(compiled_instance, num_nodes, color_num)
initial_circuit.update_qubits_label(qaoa_converter.int2varlabel)
beta_1 = qm.circuit.Parameter("beta_1")
mixer_circuit = create_xy_mixer(beta_1, num_nodes, color_num, compiled_instance)
mixer_circuit.update_qubits_label(qaoa_converter.int2varlabel)
plot_quantum_circuit(mixer_circuit)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_23_0.png)
    



```python
initial_circuit.append(qaoa_cost_circuit)
initial_circuit.append(mixer_circuit)

alternating_ansatz = initial_circuit

plot_quantum_circuit(alternating_ansatz)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_24_0.png)
    


## Run Quantum Alternating Operator Ansatz using Qiskit


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(alternating_ansatz)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []

def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data["evs"]
    cost_history.append(cost)
    return cost


result = opt.minimize(
    estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 100}
)
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -7.43749997649938
           x: [ 7.855e-01 -1.425e-01]
        nfev: 31
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_28_0.png)
    



```python
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
plt.show()
job = sampler.run([(qk_circuit, result.x)])
job_result = job.result()
```


```python
sampleset = qaoa_converter.decode(qk_transpiler, job_result[0].data['meas'])
```


```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.experimental.SampleSet):
    # extract feasible solution
    feasibles = sampleset.feasibles()
    if len(feasibles) == 0:
        print("No feasible solution found ...")
    else:
        lowest_sample = sampleset.lowest()[0]

        # get indices of x = 1
        indices = lowest_sample.var_values["x"].values.keys()
        # get vertices and colors
        # initialize vertex color list
        node_colors = [-1] * graph.number_of_nodes()
        # set color list for visualization
        colorlist = ["gold", "violet", "limegreen", "darkorange"]
        # set vertex color list
        for i, j in indices:
            node_colors[i] = colorlist[j]
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)
        plt.show()

plot_graph_coloring(G, sampleset)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_31_0.png)
    


## Alternating Ansatz with Quri-Parts


```python
# !pip install quri-parts-algo
```


```python
from qamomile.quri_parts import QuriPartsTranspiler
```


```python
from quri_parts.circuit.utils.circuit_drawer import draw_circuit

qp_transpiler = QuriPartsTranspiler()
qp_alternating_circuit = qp_transpiler.transpile_circuit(alternating_ansatz)
qp_cost = qp_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
from quri_parts.core.state import quantum_state, apply_circuit

cb_state = quantum_state(alternating_ansatz.num_qubits, bits=0)
parametric_state = apply_circuit(qp_alternating_circuit, cb_state)
```


```python
from typing import Sequence
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator

estimator = create_qulacs_vector_parametric_estimator()


cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(qp_cost, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost


result = opt.minimize(cost_fn, [0, 0], method="COBYLA", options={"maxiter": 100})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -7.437499976499405
           x: [-1.831e-03  7.855e-01]
        nfev: 35
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_38_0.png)
    



```python
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler


sampler = create_qulacs_vector_sampler()
bounded_circuit = qp_alternating_circuit.bind_parameters(result.x)
qp_result = sampler(bounded_circuit, 1000)
```


```python
sampleset = qaoa_converter.decode(qp_transpiler, (qp_result, alternating_ansatz.num_qubits))
```


```python
plot_graph_coloring(G, sampleset)
```


    
![png](alternating_ansatz_graph_coloring_files/alternating_ansatz_graph_coloring_41_0.png)
    


# References
[[1] Farhi, Edward, Jeffrey Goldstone, and Sam Gutmann. "A quantum approximate optimization algorithm." arXiv preprint arXiv:1411.4028 (2014).](https://arxiv.org/abs/1411.4028)

[[2] Hadfield, Stuart, Zhihui Wang, Bryan O’gorman, Eleanor G. Rieffel, Davide Venturelli, and Rupak Biswas. "From the quantum approximate optimization algorithm to a quantum alternating operator ansatz." Algorithms 12, no. 2 (2019): 34.](https://arxiv.org/abs/1709.03489)
# QAOA for the Vertex Cover

In this section, we will solve the Vertex Cover Problem using QAOA with the help of the `JijModeling` and `Qamomile` libraries.

First, let's install and import the main libraries we will be using.



```python
# !pip install qamomile[qiskit,quri-parts]
# !pip install pylatexenc
```


```python
import qamomile.core as qm
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
import matplotlib.pyplot as plt
```

## The Vertex Cover Problem

First, let's review the definition of the Vertex Cover Problem. In an undirected graph $G = (V, E)$, a vertex set $S \subseteq V$ is called a vertex cover if for every edge $e = (i, j) \in E$, either $i \in S$ or $j \in S$ holds. The Vertex Cover Problem is the problem of finding a vertex cover $S$ with the smallest possible number of elements.

As an example, consider the minimum vertex cover of the following graph. Let $S = \{0, 1\}$. In this case, every edge of the graph has at least one in either vertex $0$ or vertex $1$, so $S$ is a vertex cover set. Furthermore, in the graph we are considering, there is no vertex cover $S$ with only one element, so $\{0, 1\}$ is indeed the minimum vertex cover.



```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (1, 4)])
positions = nx.spring_layout(G)
color = ["#2696EB"] * 5
color[0] = color[1] = "#EA9b26"
nx.draw(G, node_color=color, pos=positions, with_labels=True)
```


    
![png](vertex_cover_files/vertex_cover_4_0.png)
    


## Formulation of the Vertex Cover Problem

Let's consider the formulation of the Vertex Cover Problem.

We define a binary variable $x_i$ such that $x_i = 1$ if vertex $i$ is included in $S$, and $x_i = 0$ otherwise. The objective function, which represents the size of $S$, can be expressed as follows.

$$
\sum_{i \in V} x_i
$$


The constraint is that all edges must be covered, meaning that for each edge, at least one of its endpoints must be included in $S$. This can be formulated as:

$$
x_{e_0} + x_{e_1} \geq 1 \quad \forall e \in E
$$


In summary, the Vertex Cover Problem can be formulated as follows:

$$
\begin{align}
&\min \sum_{i \in V} x_i \\
\text{s.t. } &x_{e_0} + x_{e_1} \geq 1 \quad \forall e \in E
\end{align}
$$

## Creating Problem Model using JijModeling

We describe the above formulation and then using JijModeling to create the problem model. `Placeholder` defines the values to be substituted as data, `BinaryVar` defines the decision variables, and `Element` defines the indices used in the summation. By checking the output, we can confirm that the formulation is correct.



```python
def vertex_cover_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    i = jm.Element("i", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)

    # set problem
    problem = jm.Problem("Vertex Cover Problem")
    # ensure that at least one vertex of each edge is included in the cover
    problem += jm.Constraint("cover", x[e[0]] + x[e[1]] >= 1, forall=e)
    # minimize the number of vertices included in the cover
    problem += jm.sum(i, x[i])

    return problem


problem = vertex_cover_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Vertex Cover Problem} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{V - 1} x_{i} & \\\text{{s.t.}} & & & \\ & \text{cover} & \displaystyle x_{e_{0}} + x_{e_{1}} \geq 1 & \forall e \in E \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



## Preparing Instance Data
Next, we will solve the Vertex Cover Problem for the following graph. The data for the specific problem being solved is referred to as instance data.



```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
G.add_edges_from(
    [
        (0, 6),
        (0, 5),
        (1, 5),
        (2, 5),
        (3, 8),
        (4, 9),
        (4, 7),
        (5, 7),
        (6, 7),
        (7, 8),
        (8, 9),
    ]
)
positions = nx.spring_layout(G)
color = ["#2696EB"] * G.number_of_nodes()
nx.draw(G, node_color=color, pos=positions, with_labels=True)
```


    
![png](vertex_cover_files/vertex_cover_11_0.png)
    



## Creating a Compiled Instance

We perform compilation using the JijModeling-Transpiler by providing the formulation and the instance data prepared earlier. This process yields an intermediate representation of the problem with the instance data substituted.



```python
inst_E = [list(edge) for edge in G.edges]
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "E": inst_E}
num_qubits = num_nodes
compiled_instance = jmt.compile_model(problem, instance_data)
```

## Converting Compiled Instance to QAOA Circuit and Hamiltonian

We generate the QAOA circuit and Hamiltonian from the compiled Instance. The converter used to generate these is `qm.qaoa.QAOAConverter`.

By creating an instance of this class and using `ising_encode`, you can internally generate the Ising Hamiltonian from the compiled Instance. Parameters that arise during the conversion to QUBO can also be set here. If not set, default values are used.

Once the Ising Hamiltonian is generated, you can generate the QAOA quantum circuit and the Hamiltonian respectively. These can be executed using the `get_qaoa_ansatz` and `get_cost_hamiltonian` methods. The number of QAOA layers, $p$, is fixed to be $4$ here.   


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
# Encode to Ising Hamiltonian
qaoa_converter.ising_encode()
# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=3)
# Get the cost Hamiltonian
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
```

## Visualization of QAOA Circuit
Qamomile provides a method to visualize the quantum circuit. You can use the `plot_quantum_circuit` function to visualize the QAOA quantum circuit.


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](vertex_cover_files/vertex_cover_17_0.png)
    


## Converting the Obtained QAOA Circuit and Hamiltonian for Qiskit

Here, we generate the Qiskit's QAOA circuit and Hamiltonian using the `qamomile.qiskit.QiskitTranspiler` converters. By utilizing the two methods,`QiskitTranspiler.transpile_circuit` and `QiskitTranspiler.transpile_hamiltonian`, we can transform the QAOA circuit and Hamiltonian into a format compatible with Qiskit. This allows us to leverage Qiskit's quantum computing framework to execute and analyze.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()
# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
# Transpile the QAOA Hamiltonian to Qiskit
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIIIIIIIZ', 'IIIIIZIIII', 'IIIIZIIIII', 'IIIZIIIIII', 'IIZIIIIIII', 'IZIIIIIIII', 'ZIIIIIIIII', 'IIIZIIIIIZ', 'IIIIZIIIIZ', 'IIIIZIIIZI', 'IIIIZIIZII', 'IZIIIIZIII', 'ZIIIIZIIII', 'IIZIIZIIII', 'IIZIZIIIII', 'IIZZIIIIII', 'IZZIIIIIII', 'ZZIIIIIIII'],
                  coeffs=[0.5+0.j, 0.5+0.j, 1.5+0.j, 0.5+0.j, 1.5+0.j, 1. +0.j, 0.5+0.j, 0.5+0.j,
     0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j,
     0.5+0.j, 0.5+0.j])



## Running QAOA

We run QAOA to optimize the parameters. Here, we use COBYLA as the optimizer.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
estimator = qk_pr.StatevectorEstimator()


# Cost estimator function
def estimate_cost(param_values):
    try:
        job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
        result = job.result()[0]
        cost = result.data["evs"]
        cost_history.append(cost)
        return cost
    except Exception as e:
        print(f"Error during cost estimation: {e}")
        return np.inf


# Initial parameters for QAOA
initial_params = [
    np.pi / 8,
    np.pi / 4,
    3 * np.pi / 8,
    np.pi / 2,
    np.pi / 2,
    3 * np.pi / 8,
]

# Run QAOA optimization with COBYLA
result = minimize(
    estimate_cost,
    initial_params,
    method="COBYLA",
    options={"maxiter": 1500},
)

print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -3.8319489423814184
           x: [ 7.111e-01  8.882e-02  1.106e+00  2.621e+00  2.031e+00
                1.371e+00]
        nfev: 321
       maxcv: 0.0


## Result Visualization

By repeating the optimization, we can observe that the energy decreases and converges.



```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](vertex_cover_files/vertex_cover_23_0.png)
    


Now, let's run the Optimized paremeter on qiskit `StatevectorSampler`.


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results

From the job counts obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.



```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.5)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()
```


    
![png](vertex_cover_files/vertex_cover_27_0.png)
    


## Plotting the Solution

From the obtained results, we select one solution that minimizes the objective function value and plot it. (The orange vertices are the vertices included in the vertex cover.)



```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):
    # extract feasible solution
    lowests = sampleset.lowest()
    if len(lowests) == 0:
        print("No feasible solution found ...")
    else:
        best_sol = lowests[0]

        # initialize vertex color list
        node_colors = ["#2696EB"] * instance_data["V"]
        # set vertex color
        for t in best_sol.var_values["x"].values.keys():
            node_colors[t[0]] = "#EA9b26"
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, pos=positions, with_labels=True)
        plt.show()


plot_graph_coloring(G, sampleset)
```


    
![png](vertex_cover_files/vertex_cover_29_0.png)
    


Indeed, we can see that a vertex cover has been obtained.
# QAOA for Graph Coloring Problem
In this tutorial, we will solve the Graph Coloring Problem using the Quantum Approximate Optimization Algorithm (QAOA).


```python
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as opt
import networkx as nx
import qiskit.primitives as qk_pr

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt

import qamomile.core as qm
from qamomile.qiskit import QiskitTranspiler
from qamomile.core.circuit.drawer import plot_quantum_circuit
```

First, we will implement the mathematical model of the graph coloring problem using JijModeling.


```python
def graph_coloring_problem() -> jm.Problem:
    # define variables
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    N = jm.Placeholder("N")
    x = jm.BinaryVar("x", shape=(V, N))
    n = jm.Element("i", belong_to=(0, N))
    v = jm.Element("v", belong_to=(0, V))
    e = jm.Element("e", belong_to=E)
    # set problem
    problem = jm.Problem("Graph Coloring")
    # set one-hot constraint that each vertex has only one color

    problem += jm.Constraint("one-color", x[v, :].sum() == 1, forall=v)
    # set objective function: minimize edges whose vertices connected by edges are the same color
    problem += jm.sum([n, e], x[e[0], n] * x[e[1], n])
    return problem

problem = graph_coloring_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Coloring} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 1} \sum_{e \in E} x_{e_{0}, i} \cdot x_{e_{1}, i} & \\\text{{s.t.}} & & & \\ & \text{one-color} & \displaystyle \sum_{\ast_{1} = 0}^{N - 1} x_{v, \ast_{1}} = 1 & \forall v \in \left\{0,\ldots,V - 1\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will create an instance of the problem.


```python
G = nx.Graph()
G.add_nodes_from([0, 1, 2, 3, 4])
G.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])
nx.draw(G)
```


    
![png](graph_coloring_files/graph_coloring_5_0.png)
    



```python
inst_E = [list(edge) for edge in G.edges]
color_num = 3
num_nodes = G.number_of_nodes()
instance_data = {"V": num_nodes, "N": color_num, "E": inst_E}
num_qubits = num_nodes * color_num
```

# Quantum Approximate Optimazation Algorithm (QAOA)
The Quantum Approximate Optimization Algorithm (QAOA) is one of the quantum optimization algorithms that use a variational quantum circuit. For a detailed explanation, please refer to paper [1], but here we will only give a rough overview.
In QAOA, a variational quantum circuit is constructed by applying the Ising Hamiltonian $H_P = \sum_{ij}J_{ij}Z_iZ_j$ and the $X$-mixer Hamiltonian $H_M = \sum_iX_i$ in the following way:
If we start with an initial state $\ket{\psi_0}$, then

$$
\ket{\psi(\beta,\gamma)} = e^{-i\beta_pH_M}e^{-i\gamma_pH_P}\cdots e^{-i\beta_1H_M}e^{-i\gamma_1H_P}\ket{\psi_0}
$$

can be written. Here, $\beta_k,\gamma_k$ are the parameters to be optimized, and since the operation $e^{-\beta_kH_M}e^{-\gamma_kH_P}$ is repeated $p$ times, there are a total of $2p$ parameters. In the standard QAOA, the total number of parameters is independent of the number of qubits and depends only on the number of repetitions.

Optimization of $\beta_k,\gamma_k$ is performed by repeating the following steps 1 and 2:

1. Compute the expectation value $\bra{\psi(\beta,\gamma)}H_P\ket{\psi(\beta,\gamma)}$ on a quantum device.
2. Update the parameters on a classical computer to minimize the expectation value.

By repeating this calculation of the expectation value on the quantum computer and optimization of parameters on the classical computer, we obtain the minimum energy $\langle H_P \rangle$ and the corresponding final state. If we consider QAOA as a mathematical optimization algorithm, this minimum energy corresponds to the minimum objective function value, and the final state becomes the optimal solution.

## Implementing QAOA using Qamomile
Now, let's try solving the Graph Coloring Problem using QAOA.
To execute QAOA, it's necessary to convert the mathematical model into an Ising Hamiltonian, and then create a variational quantum circuit and Hamiltonian using a quantum computing library. However, since Qamomile supports QAOA, it allows for relatively easy execution.

First, using JijModeling-Transpiler, we create a CompiledInstance from JijModeling's mathematical model and instance data.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

Next, we create a QAOAConverter. By setting the weight for the constraints on this Converter, we can create the Hamiltonian.


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode(multipliers={"one-color": 5})
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=1)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](graph_coloring_files/graph_coloring_12_0.png)
    


## Run QAOA using Qiskit

Now that we have the variational quantum circuit and Hamiltonian ready, let's actually execute QAOA using Qiskit.  
Transpile the qamomile's circuit to the qiskit's circuit and run the simulation.


```python
qk_transpiler = QiskitTranspiler()
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_cost = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
# Variational Step
estimator = qk_pr.StatevectorEstimator()

cost_history = []
def estinamate_cost(params):
    job = estimator.run([(qk_circuit, qk_cost, params)])
    job_result = job.result()
    cost = job_result[0].data['evs']
    cost_history.append(cost)
    return cost

result = opt.minimize(estinamate_cost, [0, 0], method="COBYLA", options={"maxiter": 1000})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: 2.8539634674558334
           x: [ 4.544e-01 -3.551e-01]
        nfev: 409
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_coloring_files/graph_coloring_16_0.png)
    



```python
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
plt.show()
job = sampler.run([(qk_circuit, result.x)], shots=10000)
job_result = job.result()
```


```python
sampleset = qaoa_converter.decode(qk_transpiler, job_result[0].data['meas'])
```


```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.experimental.SampleSet):
    # extract feasible solution
    feasibles = sampleset.feasibles()
    if len(feasibles) == 0:
        print("No feasible solution found ...")
    else:
        lowest_sample = sampleset.lowest()[0]

        # get indices of x = 1
        indices = lowest_sample.var_values["x"].values.keys()
        # get vertices and colors
        # initialize vertex color list
        node_colors = [-1] * graph.number_of_nodes()
        # set color list for visualization
        colorlist = ["gold", "violet", "limegreen", "darkorange"]
        # set vertex color list
        for i, j in indices:
            node_colors[i] = colorlist[j]
        # make figure
        nx.draw_networkx(graph, node_color=node_colors, with_labels=True)
        plt.show()

# Visualize the graph coloring result
plot_graph_coloring(G, sampleset)
```


    
![png](graph_coloring_files/graph_coloring_19_0.png)
    

# QAOA for Travelling Salesman Problem

In this tutorial, we will demonstrate how to solve a 5-city Travelling Salesman Problem (TSP) using the Quantum Approximate Optimization Algorithm (QAOA). We will utilize Quri-Parts as our simulator to implement and test the algorithm.


```python
import numpy as np
import matplotlib.pyplot as plt
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile.core as qm
```

First, we will formulate the Travelling Salesman Problem (TSP) using JijModeling. We consider a set of cities labeled from ${0, 1, \dots, N-1}$.

To reduce the number of decision variables, we slightly reformulate the problem. We fix the starting city to be city $N-1$ and focus on determining the visiting order of the remaining cities $0, 1, \dots, N-2$.

In this problem setting, our goal is to find the shortest possible route that starts and ends at city $N-1$ while visiting all other cities exactly once.

We define the variables as follows:

- $N$: The total number of cities.
- $d_{u,v}$: The distance from city $u$ to city $v$.
- $x_{u,j}$: A binary variable that equals 1 if city $u$ is visited at the $j$-th position in the tour, and 0 otherwise, where $u = 0, 1, \dots, N-2$ and $j = 0, 1, \dots, N-2$.


```python
def create_tsp_problem():
  N = jm.Placeholder("N")
  D = jm.Placeholder("d", ndim=2)
  x = jm.BinaryVar("x", shape=(N-1, N-1))
  t = jm.Element("t", belong_to=N-2)
  j = jm.Element("j", belong_to=N-1)
  u = jm.Element("u", belong_to=N-1)
  v = jm.Element("v", belong_to=N-1)

  problem = jm.Problem("TSP")

  problem += jm.Constraint("Visit all cities at least once", jm.sum(j ,x[u,j]) == 1, forall=u)
  problem += jm.Constraint("Visit one city at each time", jm.sum(u, x[u,j]) == 1, forall=j)

  problem += jm.sum(u,  D[N-1][u]*(x[u][0] + x[u][N-2])) + jm.sum(t,jm.sum(u, jm.sum(v, D[u][v]*x[u][t]*x[v][t+1])))
  return problem

problem = create_tsp_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{TSP} & & \\& & \min \quad \displaystyle \sum_{u = 0}^{N - 2} d_{N - 1, u} \cdot \left(x_{u, 0} + x_{u, N - 2}\right) + \sum_{t = 0}^{N - 3} \sum_{u = 0}^{N - 2} \sum_{v = 0}^{N - 2} d_{u, v} \cdot x_{u, t} \cdot x_{v, t + 1} & \\\text{{s.t.}} & & & \\ & \text{Visit all cities at least once} & \displaystyle \sum_{j = 0}^{N - 2} x_{u, j} = 1 & \forall u \in \left\{0,\ldots,N - 2\right\} \\ & \text{Visit one city at each time} & \displaystyle \sum_{u = 0}^{N - 2} x_{u, j} = 1 & \forall j \in \left\{0,\ldots,N - 2\right\} \\\text{{where}} & & & \\& x & 2\text{-dim binary variable}\\\end{array}$$



Next, we will prepare the instance data for our TSP problem. This involves defining the distances between each pair of cities, which are essential for formulating the cost function and constraints in our model.


```python
N = 5
np.random.seed(3)

num_qubits = (N - 1)**2

x_pos = np.random.rand(N)
y_pos = np.random.rand(N)

plt.scatter(x_pos, y_pos, c='red', s=100, edgecolors='k', zorder=3)
plt.title(f"City", fontsize=15)
plt.xlabel("X Position", fontsize=15)
plt.ylabel("Y Position", fontsize=15)
plt.xlim(0, 1)
plt.ylim(0, 1)
plt.grid(True, linestyle='--', alpha=0.7)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_5_0.png)
    



```python
d = [[0]*N for _ in range(N)]
for i in range(N):
  for j in range(N):
    d[i][j] = np.sqrt((x_pos[i] - x_pos[j])**2 + (y_pos[i] - y_pos[j])**2)

instance_data = {"N": N, "d": d}

num_qubits = (N - 1)**2
```

# Quantum Approximate Optimization Algorithm (QAOA)
We will solve the TSP using the standard Quantum Approximate Optimization Algorithm (QAOA). An overview of QAOA is provided in another tutorial [1], so please refer to that for more details.

First, we will use the JijModeling-Transpiler to generate an model as intermediate representation from our formulated TSP problem and the instance data.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

Next, we will utilize the `QAOAConverter`. We set the weights for the constraint terms and generate the QAOA circuit and Hamiltonian. In this tutorial, we use $p=2$. However, since the performance of QAOA and the Quantum Alternating Operator Ansatz can vary significantly depending on the value of $p$, interested readers are encouraged to try larger values of $p$ (note that computation time will increase).


```python
p = 4
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode(multipliers={"Visit all cities at least once": 42, "Visit one city at each time": 42})
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p)
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_11_0.png)
    


# Executing with Quri-Parts
Next, we will convert the circuit and Hamiltonian generated by Qamomile into objects compatible with Quri-Parts. This will enable us to run the quantum algorithm using Quri-Parts as our simulation framework.


```python
from qamomile.quri_parts import QuriPartsTranspiler

qp_transpiler = QuriPartsTranspiler()
qp_circuit = qp_transpiler.transpile_circuit(qaoa_circuit)
qp_cost = qp_transpiler.transpile_hamiltonian(qaoa_cost)
```


```python
from quri_parts.core.state import quantum_state, apply_circuit

cb_state = quantum_state(qaoa_circuit.num_qubits, bits=0)
parametric_state = apply_circuit(qp_circuit, cb_state)
```


```python
from typing import Sequence
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator
from scipy import optimize as opt

estimator = create_qulacs_vector_parametric_estimator()

cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(qp_cost, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost

def create_initial_param(p: int) -> list[float]:
    res = []
    # beta
    for i in range(p):
        res.append(np.pi/(2 * (p - i)))
    # gamma
    for i in range(p):
        res.append(np.pi/(2 * (i + 1)))
    return res


param_result = opt.minimize(cost_fn,create_initial_param(p), method="COBYLA", options={"maxiter": 1000})
param_result
```




     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -16.533742755961427
           x: [ 2.202e-01  6.861e-01  4.927e-01  1.213e+00  2.635e+00
                1.836e-01  1.769e-01 -9.130e-02]
        nfev: 1000
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, 120)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_16_0.png)
    



```python
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
bounded_circuit = qp_circuit.bind_parameters(param_result.x)
qp_result = sampler(bounded_circuit, 10000)
```

Finally, we convert the sampled results back into solutions for the original Travelling Salesman Problem.


```python
sampleset = qaoa_converter.decode(qp_transpiler, (qp_result, qaoa_circuit.num_qubits))
```

# Visualizing the Sampled Results
Finally, we display the sampled results using graphs to visualize the solutions obtained from the algorithm. Please note that in some cases, a feasible solution may not be achieved.


```python
from collections import defaultdict
def show_energy_histogram(sampleset):
    # Create a defaultdict to store the frequency of each energy level
    d = defaultdict(int)
    for sample in sampleset.feasibles():
        d[sample.eval.objective] += sample.num_occurrences

    # Extract energy levels and their corresponding frequencies
    energies = list(d.keys())
    num_occurrences = list(d.values())
    
    # Calculate the total number of shots
    shots = 0
    for sample in sampleset.data:
        shots += sample.num_occurrences

    # Sort energies and corresponding occurrences to ensure proper order
    sorted_pairs = sorted(zip(energies, num_occurrences))
    energies, num_occurrences = zip(*sorted_pairs)
    # Plot the histogram with equally spaced bars
    plt.bar(range(len(energies)), num_occurrences, width=0.15, align='center')
    plt.title("Objective Histogram (Number of feasible samples = {0}, shots = {1})".format(sum(num_occurrences), shots), fontsize=15)
    plt.ylabel("Frequency", fontsize=15)
    plt.xlabel("Objective", fontsize=15)
    plt.xticks(range(len(energies)), np.round(energies,3), rotation=45) 
    plt.show()
    
show_energy_histogram(sampleset)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_21_0.png)
    


We got the optimal solution from the sampleset and display the corresponding route.


```python
def plot_tsp(sampleset, x_pos, y_pos, N):
    feasible_samples = sampleset.feasibles()
    
    if len(feasible_samples) == 0:
        print("No feasible solution")
    else:
        # Extract the best feasible sample
        best_sample = feasible_samples.lowest()[0]
        d = best_sample.var_values["x"].values
        
        # Determine the route
        route = [N - 1] * (N + 1)
        for key in d.keys():
            route[key[1] + 1] = key[0]
        
        # Calculate the total distance and plot the route
        total_distance = 0
        plt.figure(figsize=(10, 6))
        
        for i in range(len(route) - 1):
            x_coords = [x_pos[route[i]], x_pos[route[i + 1]]]
            y_coords = [y_pos[route[i]], y_pos[route[i + 1]]]
            plt.plot(x_coords, y_coords, 'b-', linewidth=2)
            total_distance += np.sqrt((x_coords[0] - x_coords[1]) ** 2 + (y_coords[0] - y_coords[1]) ** 2)
        
        # Plot the nodes
        plt.scatter(x_pos, y_pos, c='red', s=100, edgecolors='k', zorder=3)
        
        # Set plot properties
        plt.title(f"Total Distance = {total_distance:.2f}", fontsize=15)
        plt.xlabel("X Position", fontsize=15)
        plt.ylabel("Y Position", fontsize=15)
        plt.xlim(0, 1)
        plt.ylim(0, 1)
        plt.grid(True, linestyle='--', alpha=0.7)
        
        # Show the plot
        plt.show()
        
plot_tsp(sampleset, x_pos, y_pos, N)
```


    
![png](Travelling_Salesman_Problem_files/Travelling_Salesman_Problem_23_0.png)
    



```python

```
## QAOA for the Max-Cut
In this section, we will solve the Maxcut Problem using QAOA with the help of the `JijModeling` and `Qamomile` libraries.

First, let's install and import the main libraries we will be using.


```python
# !pip install qamomile[qiskit, quri_parts]
```


```python
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import matplotlib.pyplot as plt
import numpy as np
from typing import List, Tuple
```

## What is the Max-Cut Problem

The Max-Cut problem is the problem of dividing the nodes of a graph into two groups such that the **number of edges cut (or the total weight of the edges cut, if the edges have weights)** is maximized. Applications include network partitioning and image processing (segmentation), among others.



```python
import networkx as nx
import matplotlib.pyplot as plt

G = nx.Graph()
num_nodes = 5
edges = [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]
G.add_nodes_from(range(num_nodes))
G.add_edges_from(edges)
pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}

cut_solution = {(1,): 1.0, (2,): 1.0, (4,): 1.0}
edge_colors = []


def get_edge_colors(
    graph, cut_solution, in_cut_color="r", not_in_cut_color="b"
) -> Tuple[List[str], List[str]]:
    cut_set_1 = [node[0] for node, value in cut_solution.items() if value == 1.0]
    cut_set_2 = [node for node in graph.nodes() if node not in cut_set_1]

    edge_colors = []
    for u, v, _ in graph.edges(data=True):
        if (u in cut_set_1 and v in cut_set_2) or (u in cut_set_2 and v in cut_set_1):
            edge_colors.append(in_cut_color)
        else:
            edge_colors.append(not_in_cut_color)
    node_colors = ["#2696EB" if node in cut_set_1 else "#EA9b26" for node in G.nodes()]
    return edge_colors, node_colors


edge_colors, node_colors = get_edge_colors(G, cut_solution)
fig, axes = plt.subplots(1, 2, figsize=(10, 4))

axes[0].set_title("Original Graph G=(V,E)")
nx.draw_networkx(G, pos, ax=axes[0], node_size=500, width=3, with_labels=True)
axes[1].set_title("MaxCut Solution Visualization")
nx.draw_networkx(
    G,
    pos,
    ax=axes[1],
    node_size=500,
    width=3,
    with_labels=True,
    edge_color=edge_colors,
    node_color=node_colors,
)

plt.tight_layout()
plt.show()
```


    
![png](maxcut_files/maxcut_4_0.png)
    


## Constructing the Mathematical Model

The Max-Cut problem can be formulated with the following equation:

$$
  \max \quad \frac{1}{2} \sum_{(i,j) \in E} (1 - s_i s_j)  
$$

Note that this equation is expressed using Ising variables $ s \in \{ +1, -1 \} $. In this case, we want to formulate it using the binary variables $ x \in \{ 0, 1 \} $ from JijModeling. Therefore, we perform the conversion between Ising variables and binary variables using the following equations:

$$
    x_i = \frac{1 + s_i}{2} \quad \Rightarrow \quad s_i = 2x_i - 1
$$



```python
def Maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem


problem = Maxcut_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Maxcut} & & \\& & \max \quad \displaystyle 0.5 \cdot \sum_{e \in E} \left(- s_{e[0]} \cdot s_{e[1]} + 1\right) & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



## Preparing Instance Data

Next, we will solve the Max-Cut Problem for the following graph. The data for the specific problem being solved is referred to as instance data.


```python
import networkx as nx
import numpy as np
from IPython.display import display, Latex

G = nx.Graph()
num_nodes = 5
edges = [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]
G.add_nodes_from(range(num_nodes))
G.add_edges_from(edges)

weight_matrix = nx.to_numpy_array(G, nodelist=list(range(num_nodes)))

plt.title("G=(V,E)")
plt.plot(figsize=(5, 4))

nx.draw_networkx(G, pos, node_size=500)
```


    
![png](maxcut_files/maxcut_8_0.png)
    



```python
V = num_nodes
E = edges

data = {"V": V, "E": E}

data
```




    {'V': 5, 'E': [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]}



## Creating a Compiled Instance
We perform compilation using the JijModeling-Transpiler by providing the formulation and the instance data prepared earlier. This process yields an intermediate representation of the problem with the instance data substituted.


```python
compiled_model = jmt.compile_model(problem, data)
```

## Converting Compiled Instance to QAOA Circuit and Hamiltonian
We generate the QAOA circuit and Hamiltonian from the compiled Instance. The converter used to generate these is `qm.qaoa.QAOAConverter`.

By creating an instance of this class and using `ising_encode`, you can internally generate the Ising Hamiltonian from the compiled Instance. Parameters that arise during the conversion to QUBO can also be set here. If not set, default values are used.

Once the Ising Hamiltonian is generated, you can generate the QAOA quantum circuit and the Hamiltonian respectively. These can be executed using the `get_qaoa_ansatz` and `get_cost_hamiltonian` methods. The number of QAOA layers, $p$, is fixed to be $7$ here.  


```python
import qamomile.core as qm

qaoa_converter = qm.qaoa.QAOAConverter(compiled_model)

qaoa_converter.ising_encode()

qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()

p = 5

qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```

## Visualization of QAOA Circuit
Qamomile provides a method to visualize the quantum circuit. You can use the plot_quantum_circuit function to visualize the QAOA quantum circuit.


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](maxcut_files/maxcut_15_0.png)
    


## Converting the Obtained QAOA Circuit and Hamiltonian for Qiskit
Here, we generate the Qiskit’s QAOA circuit and Hamiltonian using the `qamomile.qiskit.QiskitTranspiler` converters. By utilizing the two methods,`QiskitTranspiler.transpile_circuit` and `QiskitTranspiler.transpile_hamiltonian`, we can transform the QAOA circuit and Hamiltonian into a format compatible with Qiskit. This allows us to leverage Qiskit’s quantum computing framework to execute and analyze.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()

# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)

# Transpile the QAOA Hamitltonian to Qiskit
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIZZ', 'IIZIZ', 'IZIZI', 'ZIIZI', 'ZZIII', 'ZIZII'],
                  coeffs=[0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j])



## Running QAOA
We run QAOA to optimize the parameters. Here, we use COBYLA as the optimizer.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
# Cost estimator function
estimator = qk_pr.StatevectorEstimator()


def estimate_cost(param_values):
    try:
        job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
        result = job.result()[0]
        cost = result.data["evs"]
        cost_history.append(cost)
        return cost
    except Exception as e:
        print(f"Error during cost estimation: {e}")
        return np.inf


# Create initial parameters
initial_params = np.random.uniform(low=-np.pi / 4, high=np.pi / 4, size=2 * p)

# Run QAOA optimization
result = minimize(
    estimate_cost,
    initial_params,
    method="COBYLA",
    options={"maxiter": 2000, "tol": 1e-2},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -1.8395124880637668
           x: [-9.771e-02 -1.080e+00 -3.948e-01  1.184e+00 -1.948e-01
               -2.640e-01  5.865e-02  4.768e-01  9.115e-01  1.014e+00]
        nfev: 176
       maxcv: 0.0


## Result Visualization
By repeating the optimization, we can observe that the energy decreases and converges.


```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](maxcut_files/maxcut_21_0.png)
    


Now, let's run the Optimized paremeter on qiskit `StatevectorSampler`.


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=10000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results
From the job counts obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])
plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](maxcut_files/maxcut_25_0.png)
    



```python
target_energy = max(list(plot_data.keys()))
target_samples = [
    sample for sample in sampleset.feasibles() if sample.eval.objective == target_energy
]

for sample in target_samples:
    print(f"Energy: {sample.eval.objective}")
    print(f"Occurrences: {sample.num_occurrences}")
    print(f"Solution: {sample.var_values['x'].values}")

best_sample = target_samples[0]
best_sample.var_values["x"].values
```

    Energy: 5.0
    Occurrences: 2178
    Solution: {(1,): 1.0, (2,): 1.0, (4,): 1.0}
    Energy: 5.0
    Occurrences: 2173
    Solution: {(4,): 1.0, (1,): 1.0}
    Energy: 5.0
    Occurrences: 2107
    Solution: {(0,): 1.0, (3,): 1.0}
    Energy: 5.0
    Occurrences: 2132
    Solution: {(0,): 1.0, (2,): 1.0, (3,): 1.0}





    {(1,): 1.0, (2,): 1.0, (4,): 1.0}



## Plotting the Solution
From the obtained results, we select one solution that minimizes the objective function value and plot it. (The red are the edges been cutted in Max-Cut.)


```python
best_values = best_sample.var_values["x"].values
edge_colors, node_colors = get_edge_colors(G, best_values)

plt.title("G=(V,E) QAOA")
plt.plot(figsize=(5, 4))
nx.draw_networkx(
    G,
    pos,
    node_size=500,
    width=3,
    with_labels=True,
    edge_color=edge_colors,
    node_color=node_colors,
)
```


    
![png](maxcut_files/maxcut_28_0.png)
    

# QAOA for Two-Color Multi Car Paint Shop Problem
The goal of [the multi-car paint shop problem](https://arxiv.org/pdf/2109.07876) is to reduce the number of color switches between cars in a paint shop line during the manufacturing process, which is recognized as an NP-hard problem.

Let's consider two-color scenario in this tutorial. 

## Expressing the problem using a mathematical model

Given a set of cars $ X = \{x_1, x_2, \dots, x_n\} $ that need to be painted in one of two colors, denoted as $ x_i=0 $ and $ x_i=1 $,  for each $ i = 1, \dots n$. The objective is to minimize the number of color switches (i.e., changes from $ 0 $ to $ 1 $ or from $ 1 $ to $ 0 $) between consecutive cars in the sequence.


The cost of the sequence is the number of times the color switches between consecutive cars, which can be formulated as:

$$
\text{min} \quad - \sum_{i=0}^{N-2} s_i s_{i+1}.
$$

The term, $-s_i \cdot s_{i+1}$, represents consecutive cars and indicates whether they are going to be painted the same color, either $-1$ or $1$. This term becomes $-1$ when the cars are painted the same color, and $+1$ when they are painted different colors. Summing over all the cars in $X$, the cost function is minimized. By converting the spin variables to binary variables, the mathematical expression transforms into the following: 

$$
\text{min} \quad -\sum_{i=0}^{N-2} (x_i - 0.5) \cdot (x_{i+1} - 0.5).
$$

In the Two-Color Multi-Car Paint Shop Problem, the goal is to minimize the number of color switches while meeting specific constraints. In this notebook, we consider the constraint that the scheduled number of cars in each of the two colors per model (the total number of models is $M$) must be met.

$$
 V_{i,m} \cdot x_i = W_m \quad ,\forall m \in \{0, \dots, M-1\}
$$

, where $V_{i,m}$ is a one-hot 2-dimensional matrix representing which model each car $i$ belongs to.


```python
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import qamomile as qm
import numpy as np
import random as rand
```

## Formulation using JijModeling
Let's first model the problem using JijModeling.


```python
def get_mcps_problem() -> jm.Problem:
  V = jm.Placeholder("V", ndim=2) # sequence of car entry
  W = jm.Placeholder("W", ndim=1) # number of black cars by model
  N = jm.Placeholder("N") # number of cars
  M = jm.Placeholder("M") # number of car models
  x = jm.BinaryVar("x", shape=(N,))
  i = jm.Element("i", belong_to=(0, N-1))
  j = jm.Element("j", belong_to=(0, N))
  m = jm.Element("m", belong_to=(0, M))

  problem = jm.Problem("MCPS") 
  problem += jm.sum([i], -(x[i] - 0.5) * (x[i+1] - 0.5))
  problem += jm.Constraint("n-hot", jm.sum([j], V[j][m] * x[j]) == W[m], forall=m)
  return problem
problem = get_mcps_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{MCPS} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{N - 2} - \left(x_{i} - 0.5\right) \cdot \left(x_{i + 1} - 0.5\right) & \\\text{{s.t.}} & & & \\ & \text{n-hot} & \displaystyle \sum_{j = 0}^{N - 1} V_{j, m} \cdot x_{j} = W_{m} & \forall m \in \left\{0,\ldots,M - 1\right\} \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$




```python
car_map = {
    0: "🚗",  # Red car
    1: "🚕",  # Taxi
    2: "🚙",  # SUV
    3: "🚓"   # Police car
}

number_of_models = 4 
number_of_cars = 8
# number of black cars by model
black_per_models = [1, 1, 1, 1]

# Create 8 cars in 4 different kinds of models
cars = [0, 0, 1, 1, 2, 2, 3, 3] 
rand.shuffle(cars)
print(f"The order of car intake: {[car_map[car] for car in cars]}") 

#Create a 2d array of the sequence of car entry
cars_onehot = np.eye(number_of_models)[cars]
print([car_map[i] for i in range(4)])
print(cars_onehot)
```

    The order of car intake: ['🚕', '🚕', '🚙', '🚓', '🚙', '🚓', '🚗', '🚗']
    ['🚗', '🚕', '🚙', '🚓']
    [[0. 1. 0. 0.]
     [0. 1. 0. 0.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]
     [1. 0. 0. 0.]
     [1. 0. 0. 0.]]


## Creating a Compiled Instance
A compiled instance is an intermediate representation where actual values are substituted into the constants of the mathematical expressions. Before converting to various algorithms, it is necessary to first create this compiled instance.


```python
data = {"V": cars_onehot, "W":  black_per_models, "N":  number_of_cars, "M": number_of_models}
compiled_model = jmt.compile_model(problem, data)
```

## Generation of QAOA Circuit and Hamiltonian Using Qamomile
Qamomile provides a converter that generates circuits and Hamiltonians for QAOA from the compiled instance. Additionally, it allows setting parameters that arise during the conversion to QUBO.

First, we will generate the Ising Hamiltonian. Once this is done, we can also generate the quantum circuit and Hamiltonian for QAOA. 


```python
from qamomile.core.converters.qaoa import QAOAConverter
from qamomile.core.circuit.drawer import plot_quantum_circuit

qaoa_converter = QAOAConverter(compiled_model)
# Encode to Ising Hamiltonian
qaoa_converter.ising_encode(multipliers={"n-hot": 3})
# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=1)
plot_quantum_circuit(qaoa_circuit) #print it out
# Get the cost Hamiltonian
qaoa_cost = qaoa_converter.get_cost_hamiltonian()
```


    
![png](multi_car_paint_files/multi_car_paint_9_0.png)
    


## Converting the Obtained Circuit and Hamiltonian for Qiskit
let's first convert the circuit and Hamiltonian for Qiskit.


```python
import qamomile.qiskit as qm_qk
qk_transpiler = qm_qk.QiskitTranspiler()

# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_cost)
```

## Running QAOA
Now that everything is ready, let's run QAOA. Here, we are using Scipy's COBYLA as the optimization algorithm.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

# Run QAOA optimization
result = minimize(
    cost_estimator,
    np.random.rand(2) * np.pi,
    method="COBYLA",
    options={"maxiter": 100},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -1.0355860005356643
           x: [ 2.787e+00  1.013e+00]
        nfev: 80
       maxcv: 0.0


Let's also take a look at the changes in the cost function


```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](multi_car_paint_files/multi_car_paint_15_0.png)
    


Now we have obtained the QAOA parameters. Let's use them for sampling


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results

One can determine the optimal solution for the painting order.


```python
paint_map = {
    1: "⚫",  # Black heart 
    0: ""    # Empty string
}

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])
max_energy = -1e9
best_values = None
for sample in sampleset.feasibles():
    if max_energy < sample.eval.objective:
        max_energy = sample.eval.objective
        best_values = sample.var_values

best_values = sampleset.lowest()[0].var_values

values = [0] * 8
for idx in best_values["x"].values:
  values[idx[0]] = 1

print("The order of car intake: ", [car_map[car] for car in cars])
print("Color separation: ", [paint_map[value] for value in values])
```

    The order of car intake:  ['🚕', '🚕', '🚙', '🚓', '🚙', '🚓', '🚗', '🚗']
    Color separation:  ['', '⚫', '⚫', '⚫', '', '', '', '⚫']



```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.25)
plt.xticks(sorted(np.array(list(frequencies.keys()))))
plt.xlabel('Objective', fontsize=15)
plt.ylabel('Frequency', fontsize=15)
plt.show()
```


    
![png](multi_car_paint_files/multi_car_paint_21_0.png)
    


## Evaluation using classical algorithms
Comparing the best costs by brute force search.


```python
def eval_mcps_state(cars, black_per_models, state, num_cars, num_models):
  cnt = [0] * num_models
  for i in range(num_cars):
    cnt[cars[i]] += state[i]
  for i in range(num_models):
    if black_per_models[i] != cnt[i]:
      return None
  score = 0
  for i in range(num_cars-1):
    if state[i] != state[i+1]:
      score += 1
  return score

def best_cost_mcps(cars, black_per_models, num_cars, num_models):
  best_score = 1e9
  for i in range(2**num_cars):
    state = [0] * num_cars
    for j in range(num_cars):
      if i & (2**j) != 0:
        state[j] = 1
    score = eval_mcps_state(cars, black_per_models, state, num_cars, num_models)
    if not(score is None):
      best_score = min(best_score, score)
  return best_score

exact_score = best_cost_mcps(cars, black_per_models, number_of_cars, number_of_models)
qaoa_score = eval_mcps_state(cars, black_per_models, values, number_of_cars, number_of_models)
print("exact solution: ", exact_score)
print("solution using QAOA: ", qaoa_score)
```

    exact solution:  3
    solution using QAOA:  3



```python

```
# QAOA for the Graph Partitioning with Qiskit and Quri-Parts
## What is the graph partitioning problem?

The graph partitioning problem is the problem of dividing a graph 
𝐺 with 𝑉 vertices into two parts in such a way that the number of edges cut is minimized. For example, consider a graph with 6 vertices like the following.

![init_graph](graph_partition_fig/graph_init.png)

If we divide this into halves with 3 vertices each, it would be divided as follows,

![colored_graph](graph_partition_fig/graph_colored.png)

and one can see that the number of edges cut is minimized (in this case, two). 

It is known that finding this solution is NP-hard.

## Expressing the graph partitioning problem using a mathematical model

Suppose there is graph $G=(V,E)$, where $V$ is the set of vertices and $E$ is the set of edges. We consider dividing this into two sets, $V_1$ and $V_2$. To formulate the problem, a variable $x_u$ is introduced. This variable is equal to 1 if vertex $x_u$ belongs to $V_1$, and 0 if it belongs to in $V_2$.

In this case, the objective function to be minimized can be expressed as follows.

$$
\mathrm{min}\sum_{(uv)\in E} (\{x_u(1-x_v) + x_v(1-x_u)\})
$$

Here, the term $x_u(1-x_v)$ represents an edge connecting $V_1$ and $V_2$. For example, if $x_u$ belongs to $V_1$, it is 1, and if $x_v$ belongs to $V_2$, it is 0. In such a case, the edge specified by $u$ and $v$ connects $V_1$ and $V_2$, and $x_u(1-x_v)$ becomes 1.

The term $x_v(1-x_u)$ is similar. If we sum this over the edges in $G$, $\sum_{(uv)\in E}$, we can represent the number of edges connecting $V_1$ and $V_2$.

Moreover, the constraint that the vertices of $G$ are evenly divided between $V_1$ and $V_2$ can be written as the following equation.

$$
\sum_{u\in V}x_u=V/2
$$

Let’s formulate the problem as described above using JijModeling, convert it into various quantum algorithms using Qamomile, and solve it.

## Importing Packages


```python
import qamomile.core as qm
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
import matplotlib.pyplot as plt
import random
```

## Formulation using JijModeling
Now that everything is ready, let's first model the problem using JijModeling.


```python
#Formulating the problem
problem = jm.Problem('Graph Partitioning')

#Defining Variables
V = jm.Placeholder('V')
E = jm.Placeholder('E', ndim=2)
x = jm.BinaryVar('x', shape=(V,))
u = jm.Element('u', belong_to=V)
e = jm.Element('e', belong_to=E)

#Formulating the constraint
const = jm.sum(u, x[u])
problem += jm.Constraint('constraint', const==V/2)

#Formulating the objective function
A_1 = x[e[0]]*(1-x[e[1]])
A_2 = (1-x[e[0]])*x[e[1]]
problem += jm.sum(e, (A_1 + A_2))
```

This completes the modeling. Let's display the created model.


```python
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Graph Partitioning} & & \\& & \min \quad \displaystyle \sum_{e \in E} \left(x_{e_{0}} \cdot \left(- x_{e_{1}} + 1\right) + \left(- x_{e_{0}} + 1\right) \cdot x_{e_{1}}\right) & \\\text{{s.t.}} & & & \\ & \text{constraint} & \displaystyle \sum_{u = 0}^{V - 1} x_{u} = V \cdot 2^{(-1)} &  \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$



## Preparing the problem
We will now prepare the problem to be solved. Here, we will create it using a random graph


```python
#Parameters
#Number of vertices
num_nodes = 8  
#Edge addition probability
edge_probability = 0.5  

#Creating a random graph
def generate_random_graph(num_nodes, edge_probability):
    G = nx.Graph()
    # Add nodes
    for i in range(num_nodes):
        G.add_node(i)

    # Add edges randomly
    for i in range(num_nodes):
        for j in range(i + 1, num_nodes):
            if random.random() < edge_probability:
                G.add_edge(i, j)

    return G

G = generate_random_graph(num_nodes, edge_probability)

#Visualization of the created random graph
def plot_graph(G):
    pos = nx.spring_layout(G, seed=1)
    plt.figure(figsize=(5,5))
    nx.draw(G, pos, with_labels=True, node_color='white', node_size=700,
           edgecolors='black')
    plt.show()

plot_graph(G)
```


    
![png](graph_partition_files/graph_partition_9_0.png)
    


We will prepare the problem data in a format that can be used with the model created in JijModeling


```python
inst_E = [list(edge) for edge in G.edges]
instance_data = {"V": num_nodes,"E": inst_E}
num_qubits = num_nodes
```

## Creating a Compiled Instance

A compiled instance is an intermediate representation where actual values are substituted into the constants of the mathematical expressions. Before converting to various algorithms, it is necessary to first create this compiled instance.


```python
compiled_instance = jmt.compile_model(problem, instance_data)
```

## Generation of QAOA Circuit and Hamiltonian Using Qamomile
Qamomile provides a converter that generates circuits and Hamiltonians for QAOA from the compiled instance. Additionally, it allows setting parameters that arise during the conversion to QUBO.

First, we will generate the Ising Hamiltonian. Once this is done, we can also generate the quantum circuit and Hamiltonian for QAOA.









```python
from qamomile.core.circuit.drawer import plot_quantum_circuit
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)

# Encode to Ising Hamiltonian
qaoa_converter.ising_encode()

# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=3) #p is the number of layers 
plot_quantum_circuit(qaoa_circuit) #print it out
# Get the cost Hamiltonian
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
```


    
![png](graph_partition_files/graph_partition_15_0.png)
    


## Converting the Obtained Circuit and Hamiltonian for Qiskit
Qamomile has its own representation of quantum circuits and Hamiltonians to support multiple quantum algorithms. These representations need to be converted for use in the desired quantum libraries.

As of the time of writing this document (December 4, 2024), Qamomile supports:
- Qiskit
- Quri-Parts
- Qutip

As an example, let's first convert the circuit and Hamiltonian for Qiskit. To do this, we will first create an instance of __QiskitTranspiler__. Using the methods __transpile_circuit__ and __transpile_hamiltonian__ from this class, we can generate the quantum circuit and Hamiltonian.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()

# Creating the circuit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)

#Creating the Hamiltonian
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIZIIIZ', 'IIZIIIIZ', 'ZIIIIIIZ', 'IZIIIIIZ', 'ZIIZIIII', 'ZIIIIIZI', 'IIIIZIZI', 'IZIIIIZI', 'ZIZIIIII', 'IIIIZZII', 'IZIIIZII'],
                  coeffs=[0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j,
     0.5+0.j, 0.5+0.j, 0.5+0.j])



## Running QAOA
Now that everything is ready, let's run QAOA. Here, we are using Scipy's COBYLA as the optimization algorithm.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

initial_params = [np.pi / 4, np.pi / 2, np.pi / 2, np.pi / 4,np.pi / 4, np.pi / 2]

# Run QAOA optimization
result = minimize(
    cost_estimator,
    initial_params,
    method="COBYLA",
    options={"maxiter": 1000},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -2.8038438541136963
           x: [ 1.027e+00  2.833e+00  1.673e+00  5.214e-01  8.489e-01
                2.062e+00]
        nfev: 766
       maxcv: 0.0


Let's also take a look at the changes in the cost function


```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_partition_files/graph_partition_21_0.png)
    


Now we have obtained the QAOA parameters. Let's use them for sampling


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```

## Evaluating the Results
To evaluate the solution, it is convenient to use the sample_set. It calculates the objective function value, constraint violations, and more from the obtained solution.


```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.5)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()
```


    
![png](graph_partition_files/graph_partition_25_0.png)
    


The value of the objective function represents the number of edges connecting $V_1$ and $V_2$, so the pattern with the smallest value can be considered the solution. Let's plot the obtained results on a graph.



```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):
    # extract feasible solution
    lowests = sampleset.lowest()
    
    if len(lowests) == 0:
        print("No feasible solution found ...")
    else:
        best_sol = lowests[0]
        pos = nx.spring_layout(graph,seed=1)

        color_map = []
        for node in graph.nodes:
            if (node,) in best_sol.var_values["x"].values.keys():
                color_value = best_sol.var_values["x"].values[(node,)]
                color_map.append(color_value)
            else:
                color_map.append(0)  # Default color if not in the solution

        # Draw the graph with the color mapping
        nx.draw_networkx(graph, pos, with_labels=True,
                         node_color=color_map, cmap=plt.get_cmap('rainbow'))

plot_graph_coloring(G, sampleset)
```


    
![png](graph_partition_files/graph_partition_27_0.png)
    


## Conversion to Quri-Parts using Qamomile
Next, let's perform the conversion for Quri-Parts. First, we will import the necessary libraries


```python
from qamomile.quri_parts import QuriPartsTranspiler
```

We will perform the conversion in the same way as with Qiskit


```python
quri_transpiler = QuriPartsTranspiler()
quri_circuit = quri_transpiler.transpile_circuit(qaoa_circuit)
quri_hamiltonian = quri_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
```

We will set the parameters and perform optimization


```python
from quri_parts.core.state import quantum_state, apply_circuit

cb_state = quantum_state(quri_circuit.qubit_count, bits=0)
parametric_state = apply_circuit(quri_circuit, cb_state)
```

Quri-Parts with Qulacs is a quantum circuit simulator that operates faster than Qiskit. Taking advantage of this superior speed, let's increase the number of iterations in our experiment. By doing so, we can potentially improve our results even further and explore the capabilities of Quri-Parts more deeply. Let's modify our code to run more iterations and see how this affects our sampling results and the frequency of obtaining the lowest objective value.


```python
from typing import Sequence
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator

estimator = create_qulacs_vector_parametric_estimator()

cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(quri_hamiltonian, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost

result = minimize(cost_fn, initial_params, method="COBYLA", options={"maxiter": 20000})
result
```




     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -3.032268864311802
           x: [ 3.733e-01  1.044e+00  1.061e+00  4.109e-01 -2.714e-01
                2.404e+00]
        nfev: 3984
       maxcv: 0.0




```python
plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.xscale("log")
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](graph_partition_files/graph_partition_36_0.png)
    


If the cost function appears to have sufficiently decreased, we will use the obtained parameters to sample the solution


```python
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
bounded_circuit = quri_circuit.bind_parameters(result.x)
qp_result = sampler(bounded_circuit, 1000)
```

Let's visualize the sampling results


```python
sampleset = qaoa_converter.decode(quri_transpiler, (qp_result, quri_circuit.qubit_count))

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.5)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()
```


    
![png](graph_partition_files/graph_partition_40_0.png)
    


Let's plot the obtained results


```python
def plot_graph_coloring(graph: nx.Graph, sampleset: jm.SampleSet):
    # extract feasible solution
    lowests = sampleset.lowest()
    if len(lowests) == 0:
        print("No feasible solution found ...")
    else:
        best_sol = lowests[0]
        pos = nx.spring_layout(graph,seed=1)

        color_map = []
        for node in graph.nodes:
            if (node,) in best_sol.var_values["x"].values.keys():
                color_value = best_sol.var_values["x"].values[(node,)]
                color_map.append(color_value)
            else:
                color_map.append(0)  # Default color if not in the solution

        # Draw the graph with the color mapping
        nx.draw_networkx(graph, pos, with_labels=True,
                         node_color=color_map, cmap=plt.get_cmap('rainbow'))

plot_graph_coloring(G, sampleset)
```


    
![png](graph_partition_files/graph_partition_42_0.png)
    



```python

```
# Variational Quantum EigenSolver (VQE) for the Hydrogen Molecule

In this tutorial, we'll explore the implementation of the Variational Quantum Eigensolver (VQE) algorithm to find the ground state energy of a hydrogen molecule (H2). We'll use various quantum computing frameworks including OpenFermion for molecular Hamiltonians, Qamomile for quantum circuit construction, and Qiskit for quantum simulation.

The workflow includes:
1. Converting molecular Hamiltonians to qubit operators
2. Creating a parametrized quantum circuit (ansatz)
3. Implementing VQE optimization
4. Analyzing the energy landscape at different atomic distances

We'll demonstrate how quantum computing can be used to solve quantum chemistry problems, specifically focusing on finding the minimum energy configuration of H2.


```python
# You can install the required packages by running the following command
# !pip install openfermion pyscf openfermionpyscf
```

## Creating the Hamiltonian of the Hydrogen Molecule


```python
import openfermion.chem as of_chem
import openfermion.transforms as of_trans
import openfermionpyscf as of_pyscf
```


```python
basis = "sto-3g"
multiplicity = 1
charge = 0
distance = 0.977
geometry = [["H", [0, 0, 0]], ["H", [0, 0, distance]]]
description = "tmp"
molecule = of_chem.MolecularData(geometry, basis, multiplicity, charge, description)
molecule = of_pyscf.run_pyscf(molecule, run_scf=True, run_fci=True)
n_qubit = molecule.n_qubits
n_electron = molecule.n_electrons
fermionic_hamiltonian = of_trans.get_fermion_operator(molecule.get_molecular_hamiltonian())
jw_hamiltonian = of_trans.jordan_wigner(fermionic_hamiltonian)
```

## Convert to Qamomile Hamiltonian

In this section, we transform the OpenFermion Hamiltonian into a Qamomile Hamiltonian format. After applying the Jordan-Wigner transformation to convert fermionic operators to qubit operators, we use custom conversion functions to create a compatible Hamiltonian representation for Qamomile.


```python
import qamomile.core.operator as qm_o

def operator_to_qamomile(operators: tuple[tuple[int, str], ...]) -> qm_o.Hamiltonian:
    pauli = {"X": qm_o.X, "Y": qm_o.Y, "Z": qm_o.Z}
    H = qm_o.Hamiltonian()
    H.constant = 1.0
    for ope in operators:
        H = H * pauli[ope[1]](ope[0])
    return H

def openfermion_to_qamomile(of_h) -> qm_o.Hamiltonian:
    H = qm_o.Hamiltonian()
    for k, v in of_h.terms.items():
        if len(k) == 0:
            H.constant += v
        else:
            H += operator_to_qamomile(k) * v
    return H

hamiltonian = openfermion_to_qamomile(jw_hamiltonian)
```

## Create VQE ansatz

In this section, we create a simple ansatz for the VQE algorithm. The ansatz is a parametrized quantum circuit that prepares a trial wavefunction. We use the Qamomile framework to construct the ansatz circuit.


```python
from qamomile.core.ansatz.efficient_su2 import create_efficient_su2_circuit
from qamomile.core.circuit.drawer import plot_quantum_circuit

ansatz = create_efficient_su2_circuit(
    hamiltonian.num_qubits, rotation_blocks=["ry", "rz"],
    reps=4, entanglement="linear"
)
plot_quantum_circuit(ansatz)
```


    
![png](vqe_for_hydrogen_files/vqe_for_hydrogen_8_0.png)
    


## Run VQE with Qiskit

In this section, we execute the VQE using the Qiskit Aer simulator after converting the Qamomile Hamiltonian and ansatz to Qiskit format.  
Of course, you can use other quantum computing frameworks.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()
qk_ansatz = qk_transpiler.transpile_circuit(ansatz)
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(hamiltonian)
```


```python
# !pip install qiskit-aer
```


```python
import qiskit.primitives as qk_pr
import qiskit as qk
from qiskit_aer import AerSimulator
from qiskit_aer.primitives import EstimatorV2
import numpy as np
from scipy.optimize import minimize

cost_history = []

aer_sim = AerSimulator()
qk_circuit_transpiled_ansatz = qk.transpile(qk_ansatz, aer_sim)
estimator = EstimatorV2()

def cost_estimator(param_values):
    job = estimator.run([(qk_ansatz, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data["evs"]
    return cost

def cost_callback(param_values):
    cost_history.append(cost_estimator(param_values))

initial_params = np.random.uniform(0, np.pi, len(qk_ansatz.parameters))

# Run QAOA optimization
result = minimize(
    cost_estimator,
    initial_params,
    method="BFGS",
    options={"disp": True, "maxiter": 50, "gtol": 1e-6},
    callback=cost_callback
)
print(result)
```

             Current function value: -1.105868
             Iterations: 50
             Function evaluations: 2091
             Gradient evaluations: 51
      message: Maximum number of iterations has been exceeded.
      success: False
       status: 1
          fun: -1.1058675315265363
            x: [ 3.157e+00  2.124e+00 ...  1.591e+00  4.345e-01]
          nit: 50
          jac: [ 5.545e-05  1.662e-04 ...  5.196e-04 -2.392e-05]
     hess_inv: [[ 6.494e+00 -2.618e+00 ...  1.032e+01 -6.820e-01]
                [-2.618e+00  9.130e+00 ... -5.761e+00  3.409e+00]
                ...
                [ 1.032e+01 -5.761e+00 ...  2.391e+01 -1.763e+00]
                [-6.820e-01  3.409e+00 ... -1.763e+00  2.796e+00]]
         nfev: 2091
         njev: 51


    /Users/yuyamashiro/Library/Caches/pypoetry/virtualenvs/qamomile-s0Pfpxir-py3.10/lib/python3.10/site-packages/scipy/optimize/_minimize.py:726: OptimizeWarning: Maximum number of iterations has been exceeded.
      res = _minimize_bfgs(fun, x0, args, jac, callback, **options)



```python
import matplotlib.pyplot as plt
plt.plot(cost_history)
plt.plot(
    range(len(cost_history)),
    [molecule.fci_energy] * len(cost_history),
    linestyle="dashed",
    color="black",
    label="Exact Solution",
)
plt.legend()
plt.show()
```


    
![png](vqe_for_hydrogen_files/vqe_for_hydrogen_13_0.png)
    


## Change distance between atoms


```python
def hydrogen_molecule(bond_length):
    basis = "sto-3g"
    multiplicity = 1
    charge = 0
    geometry = [["H", [0, 0, 0]], ["H", [0, 0, bond_length]]]
    description = "tmp"
    molecule = of_chem.MolecularData(geometry, basis, multiplicity, charge, description)
    molecule = of_pyscf.run_pyscf(molecule, run_scf=True, run_fci=True)
    n_qubit = molecule.n_qubits
    n_electron = molecule.n_electrons
    fermionic_hamiltonian = of_trans.get_fermion_operator(
        molecule.get_molecular_hamiltonian()
    )
    jw_hamiltonian = of_trans.jordan_wigner(fermionic_hamiltonian)
    return openfermion_to_qamomile(jw_hamiltonian), molecule.fci_energy

bond_lengths = np.linspace(0.2, 1.5, 15)
energies = []
for bond_length in bond_lengths:
    hamiltonian, fci_energy = hydrogen_molecule(bond_length)
    
    ansatz = create_efficient_su2_circuit(
        hamiltonian.num_qubits, rotation_blocks=["ry", "rz"],
        reps=4, entanglement="linear"
    )

    qk_ansatz = qk_transpiler.transpile_circuit(ansatz)
    qk_hamiltonian = qk_transpiler.transpile_hamiltonian(hamiltonian)

    cost_history = []
    initial_params = np.random.uniform(0, np.pi, len(qk_ansatz.parameters))
    result = minimize(
        cost_estimator,
        initial_params,
        method="BFGS",
        options={"maxiter": 50, "gtol": 1e-6},
    )

    energies.append(result.fun)

    print("distance: ", bond_length, "energy: ", result.fun, "fci_energy: ", fci_energy)
```

    distance:  0.2 energy:  0.15754119488608387 fci_energy:  0.15748213479836348
    distance:  0.29285714285714287 energy:  -0.5679350331466697 fci_energy:  -0.5679447209710022
    distance:  0.38571428571428573 energy:  -0.8833020521044717 fci_energy:  -0.8833596636183383
    distance:  0.4785714285714286 energy:  -1.0335991644424345 fci_energy:  -1.0336011797110967
    distance:  0.5714285714285714 energy:  -1.1035710721430323 fci_energy:  -1.1042094222435161
    distance:  0.6642857142857144 energy:  -1.1322058758760072 fci_energy:  -1.132350882707551
    distance:  0.7571428571428571 energy:  -1.136784862771528 fci_energy:  -1.1369026717971324
    distance:  0.8500000000000001 energy:  -1.1281267827080066 fci_energy:  -1.1283618784581124
    distance:  0.9428571428571428 energy:  -1.1125670649192354 fci_energy:  -1.1127252078468768
    distance:  1.0357142857142858 energy:  -1.093269672823594 fci_energy:  -1.0934760882294043
    distance:  1.1285714285714286 energy:  -1.0725622262836512 fci_energy:  -1.0727578805453502
    distance:  1.2214285714285713 energy:  -1.0519588130652564 fci_energy:  -1.0520081621708446
    distance:  1.3142857142857143 energy:  -1.0322273864176297 fci_energy:  -1.032240030624708
    distance:  1.4071428571428573 energy:  -1.0137141437663768 fci_energy:  -1.014147058669549
    distance:  1.5 energy:  -0.9978997023749084 fci_energy:  -0.9981493534714101



```python
plt.plot(bond_lengths, energies, "-o")
plt.xlabel("Distance")
plt.ylabel("Energy")
plt.show()
```


    
![png](vqe_for_hydrogen_files/vqe_for_hydrogen_16_0.png)
    



```python

```
# Using the PennyLaneTranspiler in Qamomile
This tutorial demonstrates the usage of the PennyLaneTranspiler in Qamomile and provides key examples to guide users in applying it effectively.

## Translating a Hamiltonian into PennyLane

We begin by defining a Hamiltonian as a test example and use our transpiler to convert it into a PennyLane-compatible representation. This step shows how seamlessly the Hamiltonian defined in our own library’s format can be translated into operators recognized by PennyLane.


```python
import pennylane as qml
import numpy as np
import qamomile
from qamomile.pennylane.transpiler import PennylaneTranspiler
from qamomile.core.operator import Hamiltonian, Pauli, X, Y, Z
from qamomile.core.circuit import QuantumCircuit as QamomileCircuit
from qamomile.core.circuit import (
    QuantumCircuit,
    SingleQubitGate,
    TwoQubitGate,
    ParametricSingleQubitGate,
    ParametricTwoQubitGate,
    SingleQubitGateType,
    TwoQubitGateType,
    ParametricSingleQubitGateType,
    ParametricTwoQubitGateType,
    Parameter
)

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
```

In this snippet, we start from a custom-defined Hamiltonian using various Pauli operators (X, Y, Z) and then employ `PennylaneTranspiler` to convert it into a format directly suitable for PennyLane devices. By inspecting `ops_first_term` and printing out `pennylane_hamiltonian`, we can verify the correctness of the translation.


```python
hamiltonian = Hamiltonian()
hamiltonian += X(0)*Z(1)
hamiltonian += Y(0)*Y(1)*Z(2)*X(3)*X(4)

transpiler = PennylaneTranspiler()
pennylane_hamiltonian = transpiler.transpile_hamiltonian(hamiltonian)

ops_first_term = pennylane_hamiltonian.terms()[1][0]
print(pennylane_hamiltonian)
```

    1.0 * (X(0) @ Z(1) @ I(2) @ I(3) @ I(4)) + 1.0 * (Y(0) @ Y(1) @ Z(2) @ X(3) @ X(4))


## Constructing a Parameterized Quantum Circuit

Next, we build a parameterized quantum circuit using QamomileCircuit. We include single-qubit rotations (e.g., rx, ry, rz) and controlled variants (crx, crz, cry), as well as two-qubit entangling gates (rxx, ryy, rzz). The parameters (theta, beta, gamma) allow for flexible variational adjustments.


```python
qc = QamomileCircuit(3)
theta = Parameter("theta")
beta = Parameter("beta")
gamma = Parameter("gamma")

qc.rx(theta, 0)
qc.ry(beta, 1)
qc.rz(gamma, 2)
qc.crx(gamma, 0 ,1)
qc.crz(theta, 1 ,2)
qc.cry(beta, 2 ,0)
qc.rxx(gamma, 0 ,1)
qc.ryy(theta, 1 ,2)
qc.rzz(beta, 2 ,0)

transpiler = PennylaneTranspiler()
QNode = transpiler.transpile_circuit(qc)
```

## Formulating the MaxCut Problem and Converting it into a Quantum Form

In the following part, we demonstrate how to take a classical optimization problem—MaxCut—and encode it into an Ising-form Hamiltonian. We then construct a QAOA-style ansatz circuit that, when executed and optimized, attempts to solve the MaxCut instance.


```python
def maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem

def maxcut_instance():
    # Construct a simple graph for a MaxCut instance
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 4])
    G.add_edges_from([(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)])
    E = [list(edge) for edge in G.edges]
    instance_data = {"V": G.number_of_nodes(), "E": E}
    pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
    nx.draw_networkx(G, pos, node_size=500)
    return instance_data

problem = maxcut_problem()
instance_data = maxcut_instance()
compiled_instance = jmt.compile_model(problem, instance_data)

# Convert the compiled problem into a QAOA form.
qaoa_converter = qamomile.core.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode()

p = 5
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_8_0.png)
    



```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_9_0.png)
    


We have now translated the MaxCut problem into a cost Hamiltonian suitable for a QAOA-like algorithm. The parameter `p` determines the number of layers of problem and mixer Hamiltonians. Each layer’s parameters are variational and will be tuned to minimize the expvalue, ideally leading to a good solution to the MaxCut instance.

## Transpiling and Executing the QAOA Circuit in PennyLane

With the QAOA circuit and Hamiltonian defined, we use the transpiler again, this time to convert the QAOA circuit and cost Hamiltonian into PennyLane forms:


```python
from pennylane import numpy as p_np
transpiler = PennylaneTranspiler()
circ_func = transpiler.transpile_circuit(qaoa_circuit)
qml_hamiltonian = transpiler.transpile_hamiltonian(qaoa_hamiltonian)

dev = qml.device("default.qubit", wires=qaoa_circuit.num_qubits)

@qml.qnode(dev)
def circuit(params, return_samples=False):
    circ_func(params)
    if return_samples:
        return qml.sample()
    return qml.expval(qml_hamiltonian)

parameters = p_np.array([np.pi/4, np.pi/4]*p, requires_grad=True)
print("Initial Expectation Value:", circuit(parameters))
cost_history = []
cost_history.append(circuit(parameters))
```

    Initial Expectation Value: 0.6975904406316911


Here, `circ_func` is the PennyLane circuit function generated from the QAOA ansatz. Evaluating `circuit(p)` gives the expectation value of the cost Hamiltonian for the given set of parameters `p`.

## Optimizing the Parameters

Finally, we leverage PennyLane’s optimizers to update the parameters and attempt to find those that yield better results (e.g., lower cost for the MaxCut objective):


```python
max_iterations = 1000
optimizer = qml.GradientDescentOptimizer(stepsize=5e-2)
for i in range(max_iterations):
    parameters, loss= optimizer.step_and_cost(circuit, parameters)
    cost_history.append(loss)
    
print("Optimal Parameters")
print(parameters)
```

    Optimal Parameters
    [ 0.35271931  1.02327598  0.74961704  1.12583207  0.91321306 -0.38421535
      1.08607428  1.27879381  1.12025286  1.42425253]



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, max_iterations)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_16_0.png)
    


Once the optimized parameters are obtained, we use PennyLane's QNode to sample from the parameterized quantum circuit to get the circuit counts.


```python
dev_counts = qml.device("default.qubit", wires=qaoa_circuit.num_qubits, shots=1000)
@qml.qnode(dev_counts)
def circuit_counts(params):
    circ_func(params)
    return qml.counts()
result = circuit_counts(parameters)
```


```python
# Prepare data for plotting
keys = list(result.keys())
values = list(result.values())

# Plotting
plt.figure(figsize=(12, 6))
plt.bar(keys, values, width=0.6)
plt.xlabel("State", fontsize=12)
plt.ylabel("Frequency", fontsize=12)
plt.title("Distribution of State", fontsize=14)
plt.xticks(rotation=90, fontsize=10)
plt.tight_layout()
plt.show()
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_19_0.png)
    


## Evaluating the Results
From the `circuit_counts` obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(transpiler, result) 
plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](Using_the_PennyLaneTranspiler_in_Qamomile_files/Using_the_PennyLaneTranspiler_in_Qamomile_21_0.png)
    



```python

```
# Building Quantum Circuits

## Introduction
Welcome to this tutorial on building quantum circuits with Qamomile! While Qamomile is primarily designed for quantum optimization tasks, it also offers powerful capabilities for constructing arbitrary quantum circuits. This tutorial will guide you through the process of creating and manipulating quantum circuits using Qamomile's unique intermediate representation.


## Prerequisites
Before we begin, make sure you have:

- Qamomile Installed in your Python Environment


## Getting Started
First, let's import the necessary modules from Qamomile:


```python
import qamomile.core as qm
```

## Creating a Quantum Circuit
To create a quantum circuit in Qamomile, we start by initializing quantum and classical registers, then use these to create a QuantumCircuit object:


```python
circuit = qm.circuit.QuantumCircuit(2)  # Create a quantum circuit with 2 qubits
```

## Adding Gates to the Circuit
Qamomile supports a wide range of quantum gates. Let's add some common gates to our circuit:


```python
# Apply Hadamard gate to the first qubit
circuit.h(0)

# Apply CNOT gate with first qubit as control and second as target
circuit.cx(0, 1)

# Apply X-gate to the second qubit
circuit.x(1)
```

The quantum gates supported by Qamomile can be found at the following link: 
https://jij-inc.github.io/Qamomile/autoapi/core/circuit/circuit/index.html#core.circuit.circuit.QuantumCircuit

## Measurements
To perform measurements in Qamomile:


```python
circuit.measure_all()
```

## Visualizing the Circuit
Qamomile provides a method to visualize the quantum circuit:


```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(circuit)
```


    
![png](building_quantum_circuits_files/building_quantum_circuits_11_0.png)
    


## Circuit Composition

You can combine smaller circuits to create more complex ones:


```python
# Create two separate circuits
circuit1 = qm.circuit.QuantumCircuit(2)
circuit1.h(0)
circuit1.h(1)

circuit2 = qm.circuit.QuantumCircuit(2)
circuit2.cx(0, 1)


circuit1.append(circuit2)

plot_quantum_circuit(circuit1)
```


    
![png](building_quantum_circuits_files/building_quantum_circuits_13_0.png)
    


By specifying the `decompose_level` when plotting, you can display the circuit in more detail.


```python
plot_quantum_circuit(circuit1, decompose_level=1)
```


    
![png](building_quantum_circuits_files/building_quantum_circuits_15_0.png)
    


## Executing the Quantum Circuit

While Qamomile itself doesn't have the functionality to execute quantum circuits, it can translate the circuit to other quantum SDKs for execution.

### Qiskit Backend

Here's how you can execute a Qamomile circuit using Qiskit:

1- First import the necessary modules:


```python
from qamomile.qiskit import QiskitTranspiler
import qiskit.primitives as qk_pr
```

2- Create a QiskitTranspiler object:


```python
qk_transpiler = QiskitTranspiler()
```

3- Trasnpile your Qamomile circuit to a Qiskit circuit:


```python
qk_circuit = qk_transpiler.transpile_circuit(circuit)
```

4- Now you can use Qiskit's functionality to execute the circuit. For example, to run the circuit on a simulator:


```python
simulator = qk_pr.StatevectorSampler()
job = simulator.run([qk_circuit], shots=1000)
result = job.result()
```

5- The results can then be processed and analyzed using Qiskit's tools:


```python
result[0].data['c'].get_counts()
```




    {'10': 494, '01': 506}



### QURI-Parts with Qulacs Backend

Here's how you can execute a Qamomile circuit using QURI-Parts with Qulacs.

Execute the quantum circuit by converting it in the same way as Qiskit.


```python
from qamomile.quri_parts import QuriPartsTranspiler

# Transpile the circuit to QURI-Parts
qp_transpiler = QuriPartsTranspiler()
qp_circuit = qp_transpiler.transpile_circuit(circuit)
```

Now you can use Qulacs to execute the circuit:


```python
from quri_parts.core.state import quantum_state, apply_circuit
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
sampling_result = sampler(qp_circuit, 1000)
```


```python
sampling_result
```




    Counter({1: 501, 2: 499})



### Pennylane Backend

Here's how you can execute a Qamomile circuit using Pennylane.

Execute the quantum circuit by converting it in the same way as Qiskit.


```python
from qamomile.pennylane import PennylaneTranspiler

# Transpile the circuit to Pennylane
qml_transpiler = PennylaneTranspiler()
qml_circuit_func = qml_transpiler.transpile_circuit(circuit)
```


```python
import pennylane as qml

dev = qml.device("default.qubit", wires=circuit.num_qubits, shots=1000)
@qml.qnode(dev)
def qml_circuit(params):
    qml_circuit_func(params)
        
    return qml.counts()
```


```python
qml_circuit(None)
```




    {'01': 483, '10': 517}



## Conclusion

This tutorial has introduced you to building quantum circuits using Qamomile's intermediate representation and executing them using Qiskit and QURI-Parts. While Qamomile's primary focus is on quantum optimization, these circuit-building capabilities provide flexibility for various quantum computing tasks.  
Happy quantum computing with Qamomile!
## Using the QuTiPTranspiler in Qamomile

We will introduce applications in quantum annealing using Qamomile and QuTip. We focus on a Hamiltonian of the following form:

$$
H(s) = s H_0 + (1 - s) H_1
$$

where $ H_0 $ is the Hamiltonian for the Max-Cut problem we want to solve and often formulated in terms of an Ising model, and $ H_1 $ is the Hamiltonian for the transverse magnetic field. For further details on how to construct the Hamiltonian for the max-cut problem, please refer to [QAOA for Max-Cut](https://jij-inc.github.io/Qamomile/tutorial/maxcut.html).
The Hamiltonians are defined as follows: 

$$
H_0 = -\frac{1}{2} \sum_{(i,j) \in E} w_{i,j}(1 - s_i s_j)  , \quad H_1 = - \sum_{i=1}^N \sigma_i^x
$$


As the parameter $s$ gradually shifts from 0 to 1, the system gradually evolves from the ground state of $H_1$ to the ground state of  $H_0$, which corresponds to the solution to the optimization problem. 

First, let’s import the Qamomile library and other libraries used in this example.



```python
import jijmodeling as jm
import numpy as np
import qamomile.core.operator as qm_o
import matplotlib.pyplot as plt
import qamomile.qutip as qm_qt

def Maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    w = jm.Placeholder("w", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)

    problem = jm.Problem("Maxcut")
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = -1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem


problem = Maxcut_problem()
problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{Maxcut} & & \\& & \min \quad \displaystyle (-0.5) \cdot \sum_{e \in E} \left(- s_{e[0]} \cdot s_{e[1]} + 1\right) & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$




```python
import networkx as nx
from IPython.display import display, Latex

G = nx.Graph()
num_nodes = 5
edges = [(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)]
G.add_nodes_from(range(num_nodes))
G.add_edges_from(edges)

pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
plt.title("G=(V,E)")
plt.plot(figsize=(5, 4))

nx.draw_networkx(G, pos, node_size=500)
```


    
![png](quantum_annealing_files/quantum_annealing_3_0.png)
    



```python
import jijmodeling_transpiler.core as jmt
compiled_model = jmt.compile_model(problem, {"V": num_nodes, "E": edges})
```


```python
import qamomile.core as qm

# Obtain cost hamiltonian
qaoa_converter = qm.qaoa.QAOAConverter(compiled_model)
H0 = qaoa_converter.get_cost_hamiltonian()
```

Now transpile the qamomile’s hamiltonian to the qutip’s hamiltonian


```python
qt_transpiler = qm_qt.QuTiPTranspiler()
qt_H0= qt_transpiler.transpile_hamiltonian(H0)
```

Hamiltonian $H_1$ for the transverse magnetic field is also needed to be constructed


```python
H1 = qm_o.Hamiltonian()
for q1 in range(num_nodes):
    H1 -= qm_o.X(q1)
qt_H1= qt_transpiler.transpile_hamiltonian(H1)
```

We define the annealing time $T$ with $s = t / T$, where $s$ is the parameter in the Hamiltonian $H(s)$ introduced earlier. In Quantum Annealing, if $T$ is taken sufficiently large, the ground state of $H_0$ can theoretically be obtained. We perform quantum annealing for the Max-Cut problem and examine whether the final state $|\psi(T)\rangle$ is an optimal solution to the problem.

The entire Hamiltonian of the quantum annealing is given as a list where each element is a pair consisting of a Hamiltonian and its coefficient. Also, We create the initial state $ \psi(t)$ at $t = 0$, which is the ground state of $H_1$.


```python
from qutip import tensor, Qobj, mesolve

T=100

def coef0(t, args):
    return t/T

def coef1(t, args):
    return 1-t/T

H = [[qt_H0, coef0], [qt_H1, coef1]]
psi0 = tensor([Qobj([[1], [1]])/np.sqrt(2) for _ in range(num_nodes)])
```

To solve the Schrödinger equation, we use `mesolve`with the Hamiltonian, the initial state and a list of times.


```python
tlist = np.linspace(0.0, T, 101)
result = mesolve(H, psi0, tlist, [])
psi_final = result.states[-1]
```

We can visualize the probability distribution of the final state after annealing.


```python
probs = np.abs(psi_final.full())**2
plt.figure(figsize=(10, 6))
basis_labels = [f"{i:0{num_nodes}b}" for i in range(2**num_nodes)]
bars=plt.bar(range(len(probs)), probs.flatten())
plt.xticks(ticks=range(len(probs)), labels=basis_labels, rotation=90)
plt.xlabel("States")
plt.ylabel("Probability")
plt.title("Probability Distribution of Final States")

plt.show()
```


    
![png](quantum_annealing_files/quantum_annealing_16_0.png)
    


The final states and their corresponding probabilities are:


```python
final_states = []
for bar, label in zip(bars, basis_labels):
    if bar.get_height() > 1e-4:
        print(f"Final state: {label}, Probability: {bar.get_height():.4f}")
        array_label = np.array([int(bit) for bit in label])
        final_states.append((array_label, bar.get_height())) 
```

    Final state: 01100, Probability: 0.2500
    Final state: 01110, Probability: 0.2500
    Final state: 10001, Probability: 0.2500
    Final state: 10011, Probability: 0.2500


According to the result, there are four degenerate solutions. Let's visualize all the solutions. Meanswhile, we can refer to the result obtained using [QAOA](https://jij-inc.github.io/Qamomile/tutorial/maxcut.html)


```python
from qamomile.core.bitssample import BitsSample, BitsSampleSet
samples = []
for state,prob in final_states:
    sample = BitsSample(int(prob), state)
    samples.append(sample)

sample_set = BitsSampleSet(bitarrays=samples)

transformed_state = []
for transformed in qaoa_converter.decode_bits_to_sampleset(sample_set).data:
    transformed_state.append(transformed.var_values['x'].values)
print(transformed_state)
```

    [{(1,): 1.0, (4,): 1.0}, {(4,): 1.0, (2,): 1.0, (1,): 1.0}, {(0,): 1.0, (3,): 1.0}, {(2,): 1.0, (3,): 1.0, (0,): 1.0}]



```python
edge_colors = []

def get_edge_colors(graph, cut_solution, in_cut_color="r", not_in_cut_color="b"):
    cut_set_1 = [node[0] for node, value in cut_solution.items() if value == 1.0]
    cut_set_2 = [node for node in graph.nodes() if node not in cut_set_1]

    edge_colors = []
    for u, v, _ in graph.edges(data=True):
        if (u in cut_set_1 and v in cut_set_2) or (u in cut_set_2 and v in cut_set_1):
            edge_colors.append(in_cut_color)
        else:
            edge_colors.append(not_in_cut_color)
            
    node_colors = ["#2696EB" if node in cut_set_1 else "#EA9B26" for node in graph.nodes()]
    return edge_colors, node_colors

fig, axes = plt.subplots(2, 2, figsize=(10, 8)) 
axes = axes.flatten()

for i, cut_solution in enumerate(transformed_state):
    
    edge_colors, node_colors = get_edge_colors(G, cut_solution)
    
    # Create the plot
    ax = axes[i]  # Select subplot
    ax.set_title(f"Solution {i+1}")
    
    nx.draw_networkx(
        G,
        pos,
        node_size=500,
        width=3,
        with_labels=True,
        edge_color=edge_colors,
        node_color=node_colors,
        ax=ax,
    )

plt.tight_layout()
plt.show()
```


    
![png](quantum_annealing_files/quantum_annealing_21_0.png)
    


We can also visualize how the eigenenergy of the Hamiltonian changes as the parameter $s$ varies from 0 to 1 on the energy spectrum calculated by `eigenenergies`. 


```python
slist = np.linspace(0.0, 1.0, 101)
enegry_list = [[] for i in range(2**num_nodes)]

for s in slist:
    qt_H = s*qt_H0 + (1-s)*qt_H1
    enegry = qt_H.eigenenergies()
    for i in range(2**num_nodes):
        enegry_list[i].append(enegry[i])
```


```python
for i in range(2**num_nodes):
    plt.plot(slist, enegry_list[i], label=f"{i+1}th")

plt.xlabel("s")
plt.ylabel("Eigenenergies")
plt.title("Energy Spectrum")
plt.show()
```


    
![png](quantum_annealing_files/quantum_annealing_24_0.png)
    


We can see that there are four degenerate states that share the same lowest energy level, which agrees with the annealing result.

Masaphys. *PythonとQuTiPで量子アニーリングのダイナミクスを追う*. Qiita. Accessed October 30, 2024. [https://qiita.com/masaphys/items/38aeaee5313f81e15414](https://qiita.com/masaphys/items/38aeaee5313f81e15414)



```python

```
# Using the QuriPartsTranspiler in Qamomile
This tutorial demonstrates the usage of the QuriPartsTranspiler in Qamomile and provides key examples to guide users in applying it effectively.

## Translating a Hamiltonian into QuriParts

We begin by defining a Hamiltonian as a test example and use our transpiler to convert it into a QuriParts-compatible representation. 
This step shows how seamlessly the Hamiltonian defined in our own library’s format can be translated into operators recognized by QuriParts.


```python
import numpy as np
import qamomile
from qamomile.quri_parts.transpiler import QuriPartsTranspiler
from qamomile.core.operator import Hamiltonian, Pauli, X, Y, Z
from qamomile.core.circuit import QuantumCircuit as QamomileCircuit
from qamomile.core.circuit import (
    QuantumCircuit,
    SingleQubitGate,
    TwoQubitGate,
    ParametricSingleQubitGate,
    ParametricTwoQubitGate,
    SingleQubitGateType,
    TwoQubitGateType,
    ParametricSingleQubitGateType,
    ParametricTwoQubitGateType,
    Parameter
)

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
```

In this snippet, we start from a custom-defined Hamiltonian using various Pauli operators (X, Y, Z) and then employ `QuriPartsTranspiler` to convert it into a format directly suitable for QuriParts. By printing out `quriParts_hamiltonian`, we can verify the correctness of the translation.


```python
hamiltonian = Hamiltonian()
hamiltonian += X(0)*Z(1)
hamiltonian += Y(0)*Y(1)*Z(2)*X(3)*X(4)

transpiler = QuriPartsTranspiler()
quriParts_hamiltonian = transpiler.transpile_hamiltonian(hamiltonian)

quriParts_hamiltonian
```




    {frozenset({(0, <SinglePauli.X: 1>), (1, <SinglePauli.Z: 3>)}): 1.0,
     frozenset({(0, <SinglePauli.Y: 2>),
                (1, <SinglePauli.Y: 2>),
                (2, <SinglePauli.Z: 3>),
                (3, <SinglePauli.X: 1>),
                (4, <SinglePauli.X: 1>)}): 1.0}



## Constructing a Parameterized Quantum Circuit

Next, we build a parameterized quantum circuit using QamomileCircuit. We include single-qubit rotations (e.g., rx, ry, rz) and controlled variants (crx, crz, cry), as well as two-qubit entangling gates (rxx, ryy, rzz). The parameters (theta, beta, gamma) allow for flexible variational adjustments.


```python
qc = QamomileCircuit(3)
theta = Parameter("theta")
beta = Parameter("beta")
gamma = Parameter("gamma")

qc.rx(theta, 0)
qc.ry(beta, 1)
qc.rz(gamma, 2)
qc.rxx(gamma, 0 ,1)
qc.ryy(theta, 1 ,2)
qc.rzz(beta, 2 ,0)

transpiler = QuriPartsTranspiler()
qp_circuit = transpiler.transpile_circuit(qc)
```

## Formulating the MaxCut Problem and Converting it into a Quantum Form

In the following part, we demonstrate how to take a classical optimization problem—MaxCut—and encode it into an Ising-form Hamiltonian. We then construct a QAOA-style ansatz circuit that, when executed and optimized, attempts to solve the MaxCut instance.


```python
def maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem

def maxcut_instance():
    # Construct a simple graph for a MaxCut instance
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 4])
    G.add_edges_from([(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)])
    E = [list(edge) for edge in G.edges]
    instance_data = {"V": G.number_of_nodes(), "E": E}
    pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
    nx.draw_networkx(G, pos, node_size=500)
    return instance_data

problem = maxcut_problem()
instance_data = maxcut_instance()
compiled_instance = jmt.compile_model(problem, instance_data)

# Convert the compiled problem into a QAOA form.
qaoa_converter = qamomile.core.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode()

p = 5
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_8_0.png)
    



```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_9_0.png)
    


We have now translated the MaxCut problem into a cost Hamiltonian suitable for a QAOA-like algorithm. The parameter `p` determines the number of layers of problem and mixer Hamiltonians. Each layer’s parameters are variational and will be tuned to minimize the expvalue, ideally leading to a good solution to the MaxCut instance.

## Transpiling and Executing the QAOA Circuit in PennyLane

With the QAOA circuit and Hamiltonian defined, we use the transpiler again, this time to convert the QAOA circuit and cost Hamiltonian into QuriParts forms:


```python
transpiler = QuriPartsTranspiler()
# Transpile the QAOA circuit to QuriParts
qp_circuit = transpiler.transpile_circuit(qaoa_circuit)

# Transpile the QAOA Hamitltonian to QuriParts
qp_hamiltonian = transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qp_hamiltonian
```




    {frozenset({(0, <SinglePauli.Z: 3>), (1, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(0, <SinglePauli.Z: 3>), (2, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(1, <SinglePauli.Z: 3>), (3, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(1, <SinglePauli.Z: 3>), (4, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(3, <SinglePauli.Z: 3>), (4, <SinglePauli.Z: 3>)}): 0.5,
     frozenset({(2, <SinglePauli.Z: 3>), (4, <SinglePauli.Z: 3>)}): 0.5,
     PauliLabel(): -3.0}



Here, `qk_circuit` is the QuriParts circuit generated from the Qamomile QAOA ansatz and `qk_hamiltonian` is build from Qamomile Hamiltonian based on the mathematical model.

## Optimizing the Parameters

Finally, we optimize the variational parameter and attempt to find those that yield better results (e.g., lower cost for the MaxCut objective):


```python
from typing import Sequence
from scipy.optimize import minimize
from quri_parts.core.state import quantum_state, apply_circuit
from quri_parts.qulacs.estimator import create_qulacs_vector_parametric_estimator

cost_history = []
# Cost estimator function


cb_state = quantum_state(qp_circuit.qubit_count, bits=0)
parametric_state = apply_circuit(qp_circuit, cb_state)


estimator = create_qulacs_vector_parametric_estimator()

cost_history = []
def cost_fn(param_values: Sequence[float]) -> float:
    estimate = estimator(qp_hamiltonian, parametric_state, param_values)
    cost = estimate.value.real
    cost_history.append(cost)
    return cost


# Create initial parameters
initial_params = np.random.uniform(low=-np.pi / 4, high=np.pi / 4, size=2 * p)

# Run QAOA optimization
result = minimize(
    cost_fn,
    initial_params,
    method="COBYLA",
    options={"maxiter": 2000},
)
print(result)
```

     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -4.711600340952039
           x: [ 1.579e+00 -9.337e-01  2.224e+00  1.642e+00  9.104e-01
               -9.487e-01 -7.253e-01 -2.557e-01 -4.168e-01  8.613e-01]
        nfev: 2000
       maxcv: 0.0



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_16_0.png)
    


Once the optimized parameters are obtained, we use QuriParts's `create_qulacs_vector_sampler` to sample from the parameterized quantum circuit to get the circuit counts.


```python
# Run Optimized QAOA circuit
from quri_parts.qulacs.sampler import create_qulacs_vector_sampler

sampler = create_qulacs_vector_sampler()
bounded_circuit = qp_circuit.bind_parameters(result.x)
qp_result = sampler(bounded_circuit, 1000)
```


```python
bitcounts = {bin(i)[2:].zfill(qp_circuit.qubit_count): count for i, count in qp_result.items()}
```


```python
# Prepare data for plotting
keys = list(bitcounts.keys())
values = list(bitcounts.values())

# Plotting
plt.figure(figsize=(12, 6))
plt.bar(keys, values, width=0.6)
plt.xlabel("State", fontsize=12)
plt.ylabel("Frequency", fontsize=12)
plt.title("Distribution of State", fontsize=14)
plt.xticks(rotation=90, fontsize=10)
plt.tight_layout()
plt.show()
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_20_0.png)
    


## Evaluating the Results
From the `qp_result` and `qubit_count` obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
sampleset = qaoa_converter.decode(transpiler, (qp_result, qp_circuit.qubit_count))

plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](Using_the_QuriPartsTranspiler_in_Qamomile_files/Using_the_QuriPartsTranspiler_in_Qamomile_22_0.png)
    



```python

```
# Using the QiskitTranspiler in Qamomile
This tutorial demonstrates the usage of the QiskitTranspiler in Qamomile and provides key examples to guide users in applying it effectively.

## Translating a Hamiltonian into Qiskit

We begin by defining a Hamiltonian as a test example and use our transpiler to convert it into a Qiskit-compatible representation. 
This step shows how seamlessly the Hamiltonian defined in our own library’s format can be translated into operators recognized by Qiskit.


```python
import numpy as np
import qamomile
from qamomile.qiskit.transpiler import QiskitTranspiler
from qamomile.core.operator import Hamiltonian, Pauli, X, Y, Z
from qamomile.core.circuit import QuantumCircuit as QamomileCircuit
from qamomile.core.circuit import (
    QuantumCircuit,
    SingleQubitGate,
    TwoQubitGate,
    ParametricSingleQubitGate,
    ParametricTwoQubitGate,
    SingleQubitGateType,
    TwoQubitGateType,
    ParametricSingleQubitGateType,
    ParametricTwoQubitGateType,
    Parameter
)

import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
import networkx as nx
```

In this snippet, we start from a custom-defined Hamiltonian using various Pauli operators (X, Y, Z) and then employ `QiskitTranspiler` to convert it into a format directly suitable for Qiskit. By printing out `qiskit_hamiltonian`, we can verify the correctness of the translation.


```python
hamiltonian = Hamiltonian()
hamiltonian += X(0)*Z(1)
hamiltonian += Y(0)*Y(1)*Z(2)*X(3)*X(4)

transpiler = QiskitTranspiler()
qiskit_hamiltonian = transpiler.transpile_hamiltonian(hamiltonian)

qiskit_hamiltonian
```




    SparsePauliOp(['IIIZX', 'XXZYY'],
                  coeffs=[1.+0.j, 1.+0.j])



## Constructing a Parameterized Quantum Circuit

Next, we build a parameterized quantum circuit using QamomileCircuit. We include single-qubit rotations (e.g., rx, ry, rz) and controlled variants (crx, crz, cry), as well as two-qubit entangling gates (rxx, ryy, rzz). The parameters (theta, beta, gamma) allow for flexible variational adjustments.


```python
qc = QamomileCircuit(3)
theta = Parameter("theta")
beta = Parameter("beta")
gamma = Parameter("gamma")

qc.rx(theta, 0)
qc.ry(beta, 1)
qc.rz(gamma, 2)
qc.crx(gamma, 0 ,1)
qc.crz(theta, 1 ,2)
qc.cry(beta, 2 ,0)
qc.rxx(gamma, 0 ,1)
qc.ryy(theta, 1 ,2)
qc.rzz(beta, 2 ,0)

transpiler = QiskitTranspiler()
qk_circuit = transpiler.transpile_circuit(qc)
```

## Formulating the MaxCut Problem and Converting it into a Quantum Form

In the following part, we demonstrate how to take a classical optimization problem—MaxCut—and encode it into an Ising-form Hamiltonian. We then construct a QAOA-style ansatz circuit that, when executed and optimized, attempts to solve the MaxCut instance.


```python
def maxcut_problem() -> jm.Problem:
    V = jm.Placeholder("V")
    E = jm.Placeholder("E", ndim=2)
    x = jm.BinaryVar("x", shape=(V,))
    e = jm.Element("e", belong_to=E)
    i = jm.Element("i", belong_to=V)
    j = jm.Element("j", belong_to=V)

    problem = jm.Problem("Maxcut", sense=jm.ProblemSense.MAXIMIZE)
    si = 2 * x[e[0]] - 1
    sj = 2 * x[e[1]] - 1
    si.set_latex("s_{e[0]}")
    sj.set_latex("s_{e[1]}")
    obj = 1 / 2 * jm.sum(e, (1 - si * sj))
    problem += obj
    return problem

def maxcut_instance():
    # Construct a simple graph for a MaxCut instance
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 4])
    G.add_edges_from([(0, 1), (0, 4), (1, 2), (1, 3), (2, 3), (3, 4)])
    E = [list(edge) for edge in G.edges]
    instance_data = {"V": G.number_of_nodes(), "E": E}
    pos = {0: (1, 1), 1: (0, 1), 2: (-1, 0.5), 3: (0, 0), 4: (1, 0)}
    nx.draw_networkx(G, pos, node_size=500)
    return instance_data

problem = maxcut_problem()
instance_data = maxcut_instance()
compiled_instance = jmt.compile_model(problem, instance_data)

# Convert the compiled problem into a QAOA form.
qaoa_converter = qamomile.core.qaoa.QAOAConverter(compiled_instance)
qaoa_converter.ising_encode()

p = 5
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=p)
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_8_0.png)
    



```python
from qamomile.core.circuit.drawer import plot_quantum_circuit

plot_quantum_circuit(qaoa_circuit)
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_9_0.png)
    


We have now translated the MaxCut problem into a cost Hamiltonian suitable for a QAOA-like algorithm. The parameter `p` determines the number of layers of problem and mixer Hamiltonians. Each layer’s parameters are variational and will be tuned to minimize the expvalue, ideally leading to a good solution to the MaxCut instance.

## Transpiling and Executing the QAOA Circuit in Qiskit

With the QAOA circuit and Hamiltonian defined, we use the transpiler again, this time to convert the QAOA circuit and cost Hamiltonian into Qiskit forms:


```python
transpiler = QiskitTranspiler()
# Transpile the QAOA circuit to Qiskit
qk_circuit = transpiler.transpile_circuit(qaoa_circuit)

# Transpile the QAOA Hamitltonian to Qiskit
qk_hamiltonian = transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIIZZ', 'IIZIZ', 'IZIZI', 'ZIIZI', 'ZZIII', 'ZIZII', 'IIIII'],
                  coeffs=[ 0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j, -3. +0.j])



Here, `qk_circuit` is the Qiskit circuit generated from the Qamomile QAOA ansatz and `qk_hamiltonian` is build from Qamomile Hamiltonian based on the mathematical model.

## Optimizing the Parameters

Finally, we optimize the variational parameter and attempt to find those that yield better results (e.g., lower cost for the MaxCut objective):


```python
import qiskit.primitives as qk_pr
from scipy.optimize import minimize

cost_history = []
# Cost estimator function
estimator = qk_pr.StatevectorEstimator()


def estimate_cost(param_values):
    try:
        job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
        result = job.result()[0]
        cost = result.data["evs"]
        cost_history.append(cost)
        return cost
    except Exception as e:
        print(f"Error during cost estimation: {e}")
        return np.inf


# Create initial parameters
initial_params = np.random.uniform(low=-np.pi / 4, high=np.pi / 4, size=2 * p)

# Run QAOA optimization
result = minimize(
    estimate_cost,
    initial_params,
    method="COBYLA",
    options={"maxiter": 2000},
)
print(result)
```

     message: Maximum number of function evaluations has been exceeded.
     success: False
      status: 2
         fun: -4.948032219792361
           x: [-5.640e-01 -4.659e-01 -3.222e-01 -5.174e-01  3.372e-01
                4.496e-01  8.850e-01  1.022e+00  1.040e+00 -8.994e-02]
        nfev: 2000
       maxcv: 0.0



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xscale("log")
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_16_0.png)
    


Once the optimized parameters are obtained, we use Qiskit's `StatevectorSampler` to sample from the parameterized quantum circuit to get the circuit counts.


```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=10000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
```


```python
# Prepare data for plotting
keys = list(qaoa_counts.get_counts().keys())
values = list(qaoa_counts.get_counts().values())

# Plotting
plt.figure(figsize=(12, 6))
plt.bar(keys, values, width=0.6)
plt.xlabel("State", fontsize=12)
plt.ylabel("Frequency", fontsize=12)
plt.title("Distribution of State", fontsize=14)
plt.xticks(rotation=90, fontsize=10)
plt.tight_layout()
plt.show()
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_19_0.png)
    


## Evaluating the Results
From the `qaoa_counts` obtained earlier, we can transfer them to a sampleset by `qaoa_converter.decode`.
The sampleset can select only the feasible solutions and then we examine the distribution of the objective function values.


```python
sampleset = qaoa_converter.decode(transpiler, qaoa_counts) 
plot_data = {}
for sample in sampleset.feasibles():
    if sample.eval.objective in plot_data:
        plot_data[sample.eval.objective] += sample.num_occurrences
    else:
        plot_data[sample.eval.objective] = sample.num_occurrences

plt.bar(plot_data.keys(), plot_data.values(), width=0.5)
plt.title("cost distribution of feasible solution", fontsize=15)
plt.ylabel("Frequency", fontsize=15)
plt.xlabel("Energy", fontsize=15)
plt.show()
```


    
![png](Using_the_QiskitTranspiler_in_Qamomile_files/Using_the_QiskitTranspiler_in_Qamomile_21_0.png)
    



```python

```
# Write Hamiltonian Algebraically
This tutorial explains how to create a Qamomile Hamiltonian using an algebraic modeler `jijmodeling`.

Using this functionality will allow you to create Hamiltonians in a more intuitive way.


```python
import jijmodeling as jm
import qamomile.core.modeler as qm_m
```

## Write Algebraic Hamiltonian
Let us write Heisenberg model without the external field with periodic boundary condition by using qamomile modeler in this tutorial.

To define Pauli Operator Expression we need to use `qm_m.PauliExpr`.
In the Heisenberg model, there are $X$, $Y$ and $Z$ Pauli Operator, so let us define them first.


```python
N = jm.Placeholder("N")
Z = qm_m.PauliExpr.z(shape=(N,))
X = qm_m.PauliExpr.x(shape=(N,))
Y = qm_m.PauliExpr.y(shape=(N,))
Y
```




$$\displaystyle \hat{Y}$$



Next, let us define the Hamiltonian which is

$$
\hat{H} = - \sum_{i = 0}^{N-1} J_x X_i X_{i+1} + J_y Y_i Y_{i+1} + J_z Z_i Z_{i+1}
$$

Here we assume periodic boundary condition ( $X_N = X_0$ ).

We can define this by using `jijmodeling`.


```python
i = jm.Element("i", belong_to = (0,N))
J_x = jm.Placeholder("J_x")
J_y = jm.Placeholder("J_y")
J_z = jm.Placeholder("J_z")
expr = -jm.sum(i, J_x * X[i] * X[(i+1) % N] + J_y * Y[i] * Y[(i+1) % N] + J_z * Z[i] * Z[(i+1) % N])
h_expr = qm_m.HamiltonianExpr(expr)
h_expr
```




$$\displaystyle - \sum_{i = 0}^{N - 1} \left(J_x \cdot \hat{X}_{i} \cdot \hat{X}_{\left(i + 1\right) \bmod N} + J_y \cdot \hat{Y}_{i} \cdot \hat{Y}_{\left(i + 1\right) \bmod N} + J_z \cdot \hat{Z}_{i} \cdot \hat{Z}_{\left(i + 1\right) \bmod N}\right)$$



## Build Qamomile Hamiltonian from Algebraic Hamiltonian Expression
We can build qamomile `Hamiltonian` by inserting the value into `HamiltonianExpr`.

Let us create some data to insert first. 
We can provide the data as `dict`.

To make it easier to see whether the output of the results is correct, let's create some unusual data.


```python
instance_data = {"N":10, "J_x":1.0, "J_y":-1.0, "J_z":2.0}
```

We can use `HamiltonianBuilder` to insert the instance data into `HamiltonianExpr`.


```python

builder = qm_m.hamiltonian_expr.HamiltonianBuilder(h_expr,instance_data)
h = builder.build()
h
```




    Hamiltonian((X0, X1): -1.0, (Y0, Y1): 1.0, (Z0, Z1): -2.0, (X1, X2): -1.0, (Y1, Y2): 1.0, (Z1, Z2): -2.0, (X2, X3): -1.0, (Y2, Y3): 1.0, (Z2, Z3): -2.0, (X3, X4): -1.0, (Y3, Y4): 1.0, (Z3, Z4): -2.0, (X4, X5): -1.0, (Y4, Y5): 1.0, (Z4, Z5): -2.0, (X5, X6): -1.0, (Y5, Y6): 1.0, (Z5, Z6): -2.0, (X6, X7): -1.0, (Y6, Y7): 1.0, (Z6, Z7): -2.0, (X7, X8): -1.0, (Y7, Y8): 1.0, (Z7, Z8): -2.0, (X8, X9): -1.0, (Y8, Y9): 1.0, (Z8, Z9): -2.0, (X0, X9): -1.0, (Y0, Y9): 1.0, (Z0, Z9): -2.0)



If you also want to check the `Hamiltonian` in LaTex, you can do it as follows.


```python
import IPython.display as ipd

ipd.display(ipd.Latex("$" + h.to_latex() + "$"))
```


$-X_{0}X_{1}+Y_{0}Y_{1}-2.0Z_{0}Z_{1}-X_{1}X_{2}+Y_{1}Y_{2}-2.0Z_{1}Z_{2}-X_{2}X_{3}+Y_{2}Y_{3}-2.0Z_{2}Z_{3}-X_{3}X_{4}+Y_{3}Y_{4}-2.0Z_{3}Z_{4}-X_{4}X_{5}+Y_{4}Y_{5}-2.0Z_{4}Z_{5}-X_{5}X_{6}+Y_{5}Y_{6}-2.0Z_{5}Z_{6}-X_{6}X_{7}+Y_{6}Y_{7}-2.0Z_{6}Z_{7}-X_{7}X_{8}+Y_{7}Y_{8}-2.0Z_{7}Z_{8}-X_{8}X_{9}+Y_{8}Y_{9}-2.0Z_{8}Z_{9}-X_{0}X_{9}+Y_{0}Y_{9}-2.0Z_{0}Z_{9}$

# Qamomile Quickstart Guide

This guide will help you get started with Qamomile quickly, covering installation and basic usage.

## Installation

### Prerequisites
Before installing Qamomile, ensure you have the following:

- Python 3.10 or higher
- pip (Python package installer)

### Installing Qamomile

Install Qamomile using pip:

```bash
pip install qamomile
```

### Optional Dependencies

Depending on your needs, you might want to install additional packages:

- For Qiskit integration: `pip install "qamomile[qiskit]"`
- For Quri Parts integration: `pip install "qamomile[quri-parts]"`
- For Qutip integration: `pip install "qamomile[qutip]"`

## Basic Usages

Let's walk through a simple example to demonstrate how to use Qamomile.

### 1. Import Qamomile and JijModeling


```python
import qamomile.core as qm
import jijmodeling as jm
import jijmodeling_transpiler.core as jmt
```

### 2. Create a Mathematical Model with JijModeling


```python
# Simple QUBO

Q = jm.Placeholder("Q", ndim=2)
n = Q.len_at(0, latex="n")
x = jm.BinaryVar("x", shape=(n,))

problem = jm.Problem("qubo")
i, j = jm.Element("i", n), jm.Element("j", n)
problem += jm.sum([i, j], Q[i, j] * x[i] * x[j])

problem
```




$$\begin{array}{cccc}\text{Problem:} & \text{qubo} & & \\& & \min \quad \displaystyle \sum_{i = 0}^{n - 1} \sum_{j = 0}^{n - 1} Q_{i, j} \cdot x_{i} \cdot x_{j} & \\\text{{where}} & & & \\& x & 1\text{-dim binary variable}\\\end{array}$$




```python
# Prepare data
instance_data = {
    "Q": [[0.1, 0.2, -0.1],
          [0.2, 0.3, 0.4],
          [-0.1, 0.4, 0.0]]
}

# Compile the problem:
# Substitute the data into the problem.
compiled_instance = jmt.compile_model(problem, instance_data)
```

### 3. Create a Quantum Circuit and a Hamiltonian with Qamomile


```python
qaoa_converter = qm.qaoa.QAOAConverter(compiled_instance)

# Encode to Ising Hamiltonian
qaoa_converter.ising_encode()

# Get the QAOA circuit
qaoa_circuit = qaoa_converter.get_qaoa_ansatz(p=2)
# Get the cost Hamiltonian
qaoa_hamiltonian = qaoa_converter.get_cost_hamiltonian()
```

### 4. Transpile to a Quantum Computing SDK (Qiskit or Quri Parts)
In this example, we will use Qiskit.


```python
import qamomile.qiskit as qm_qk

qk_transpiler = qm_qk.QiskitTranspiler()

# Transpile the QAOA circuit to Qiskit
qk_circuit = qk_transpiler.transpile_circuit(qaoa_circuit)
qk_circuit.draw(output="mpl")
```




    
![png](quickstart_files/quickstart_9_0.png)
    




```python
# Transpile the QAOA Hamiltonian to Qiskit
qk_hamiltonian = qk_transpiler.transpile_hamiltonian(qaoa_hamiltonian)
qk_hamiltonian
```




    SparsePauliOp(['IIZ', 'IZI', 'ZII', 'IZZ', 'ZIZ', 'ZZI'],
                  coeffs=[-0.1 +0.j, -0.45+0.j, -0.15+0.j,  0.1 +0.j, -0.05+0.j,  0.2 +0.j])



### 5. Run the Quantum Circuit

Run the quantum circuit on a quantum simulator or a real quantum computer.  
In this example, we will use the Qiskit.  

In Qamomile, the execution of quantum circuits is delegated to the respective SDKs, allowing users to implement this part themselves if they choose to do so. Given that the primary applications of current quantum computers are research and education, we believe that the majority of cases where quantum optimization algorithms are executed will fall under these categories. To avoid turning Qamomile into a black box, the execution of quantum circuits is left to the users, making it easier to customize algorithms.


```python
import qiskit.primitives as qk_pr
import numpy as np
from scipy.optimize import minimize

cost_history = []
def cost_estimator(param_values):
    estimator = qk_pr.StatevectorEstimator()
    job = estimator.run([(qk_circuit, qk_hamiltonian, param_values)])
    result = job.result()[0]
    cost = result.data['evs']
    cost_history.append(cost)
    return cost

# Run QAOA optimization
result = minimize(
    cost_estimator,
    [np.pi / 4, np.pi / 2, np.pi / 2, np.pi / 4],
    method="COBYLA",
    options={"maxiter": 1000},
)
print(result)
```

     message: Optimization terminated successfully.
     success: True
      status: 1
         fun: -0.428242617622815
           x: [ 8.005e-01  1.940e+00  1.020e+00  1.509e+00]
        nfev: 281
       maxcv: 0.0



```python
import matplotlib.pyplot as plt

plt.title("Change of Cost", fontsize=15)
plt.xlabel("Iteration", fontsize=15)
plt.ylabel("Cost", fontsize=15)
plt.xlim(1, result.nfev)
plt.plot(cost_history, label="Cost", color="#2696EB")
plt.show()
```


    
![png](quickstart_files/quickstart_13_0.png)
    



```python
# Run Optimized QAOA circuit
sampler = qk_pr.StatevectorSampler()
qk_circuit.measure_all()
job = sampler.run([(qk_circuit, result.x)], shots=1000)
job_result = job.result()[0]
qaoa_counts = job_result.data["meas"]
qaoa_counts.get_counts()
```




    {'000': 622, '100': 107, '010': 8, '001': 226, '101': 35, '011': 1, '111': 1}



### 6. Decode the Result

After running the quantum circuit, decode the result to obtain the solution.


```python
from collections import defaultdict
import matplotlib.pyplot as plt

sampleset = qaoa_converter.decode(qk_transpiler, job_result.data["meas"])

# Initialize a dictionary to accumulate occurrences for each energy value
frequencies = defaultdict(int)

# Define the precision to which you want to round the energy values
for sample in sampleset:
    energy = round(sample.eval.objective, ndigits = 3)  
    frequencies[energy] += sample.num_occurrences

plt.bar(frequencies.keys(), frequencies.values(), width=0.05)
plt.xlabel('Objective')
plt.ylabel('Frequency')
plt.show()

```


    
![png](quickstart_files/quickstart_16_0.png)
    



```python

```
# API Reference

```{eval-rst}
.. autoapisummary::
