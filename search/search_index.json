{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qamomile","text":""},{"location":"#what-is-qamomile","title":"What is Qamomile","text":"<p>Qamomile is a library that supports running quantum optimization algorithms with various quantum computation libraries. Currently, Qamomile supports two quantum computation libraries, Qiskit and QURI-Part.</p> <p>QAMOMILE stands for \"Quantum Algorithm for Mathematical OptiMization with jIjmodeLing Extension\". It transforms mathematical models written by JijModeling into Ising Hamiltonians and various other encoded Hamiltonians such as Quantum Random Access Optimization.</p> <pre><code>graph LR\n    JijModeling --&gt; Instance\n    subgraph JijModelingTranspiler\n        Instance\n    end\n\n    subgraph Qiskit\n        QSKT[Hamiltonian]\n        QSKT --&gt; QSKTCIRC[Q Circuit] --&gt; QSKTR[Results]\n    end\n    subgraph Quri-Parts\n        QP[Hamiltonian]\n        QP --&gt; QPCIRC[Q Circuit] --&gt; QURIR[Results]\n    end\n\n\n\n    subgraph Qamomile\n        Instance --&gt; Encode\n        Encode{Encode}\n        Encode --&gt; QH[Quantum Hamiltonian]\n    end\n\n    QH --&gt; QSKT\n    QH --&gt; QP\n\n    subgraph Qamomile\n        QSKTR --&gt; Decode{Decode}\n        QURIR --&gt; Decode\n    end\n    Decode --&gt; Solutions\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>The installation for qiskit is  <pre><code># qamomile for qiskit\npip install \"qamomile[qiskit]\"\n</code></pre></p> <p>The installation for QURI Parts is <pre><code># qamomile for quri-parts\npip install \"qamomile[quri-parts]\"\n</code></pre></p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>In the following example, QAOA for the graph colouring problem is implemented using Qamomile. <pre><code>import jijmodeling as jm\nimport jijmodeling_transpiler.core as jtc\nimport qamomile.qiskit as qamo_qk\n\nfrom qiskit.primitives import Estimator, Sampler\nfrom qiskit.algorithms.minimum_eigensolvers import QAOA\nfrom qiskit.algorithms.optimizers import COBYLA\n\nimport networkx as nx\n\n# Create Mathematical Model\n# define variables\nV = jm.Placeholder(\"V\")\nE = jm.Placeholder(\"E\", ndim=2)\nN = jm.Placeholder(\"N\")\nx = jm.BinaryVar(\"x\", shape=(V, N))\nn = jm.Element(\"i\", belong_to=(0, N))\nv = jm.Element(\"v\", belong_to=(0, V))\ne = jm.Element(\"e\", belong_to=E)\n# set problem\nproblem = jm.Problem(\"Graph Coloring\")\n# set one-hot constraint that each vertex has only one color\n\nproblem += jm.Constraint(\"one-color\", x[v, :].sum() == 1, forall=v)\n# set objective function: minimize edges whose vertices connected by edges are the same color\nproblem += jm.sum([n, e], x[e[0], n] * x[e[1], n])\n\n# Create Problem Instance\nG = nx.Graph()\nG.add_nodes_from([0, 1, 2, 3, 4])\nG.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 3), (3, 4), (2, 4)])\ninst_E = [list(edge) for edge in G.edges]\ncolor_num = 3\nnum_nodes = G.number_of_nodes()\ninstance_data = {\"V\": num_nodes, \"N\": color_num, \"E\": inst_E}\nnum_qubits = num_nodes * color_num\n\n# Transpile mathematical model to Qiskit Ising Hamiltonian\ncompiled_instance = jtc.compile_model(problem, instance_data)\nqaoa_builder = qamo_qk.qaoa.transpile_to_qaoa_ansatz(compiled_instance,normalize=False,relax_method=jtc.pubo.RelaxationMethod.SquaredPenalty)\nhamiltonian, _ = qaoa_builder.get_hamiltonian(multipliers={\"one-color\": 1})\n\n# Run QAOA by Qiskit\nsampler = Sampler()\noptimizer = COBYLA()\nqaoa = QAOA(sampler, optimizer, reps=1)\nresult = qaoa.compute_minimum_eigenvalue(hamiltonian)\n\n# Analyze Result\nsampleset = qaoa_builder.decode_from_quasi_dist(result.eigenstate)\nsampleset.feasible()\n</code></pre></p>"},{"location":"#community","title":"Community","text":"<p>Join our discord channel!</p>"},{"location":"reference/SUMMARY/","title":"Reference","text":"<ul> <li>core<ul> <li>ising_qubo<ul> <li>ising_qubo</li> </ul> </li> <li>qrac<ul> <li>graph_coloring</li> </ul> </li> </ul> </li> <li>qiskit<ul> <li>minimal_encoding<ul> <li>cost_function</li> <li>to_minimal_encoding</li> </ul> </li> <li>qaoa<ul> <li>ising_hamiltonian</li> <li>to_qaoa</li> </ul> </li> <li>qrao<ul> <li>qrao21</li> <li>qrao31</li> <li>qrao32</li> <li>qrao_space_efficient</li> <li>to_qrac</li> </ul> </li> </ul> </li> <li>quri_parts<ul> <li>qaoa<ul> <li>to_qaoa</li> </ul> </li> <li>qrao<ul> <li>qrao21</li> <li>qrao31</li> <li>qrao32</li> <li>to_qrac</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/core/","title":"Core","text":""},{"location":"reference/core/#qamomile.core.IsingModel","title":"<code>IsingModel</code>  <code>dataclass</code>","text":"Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>@dataclasses.dataclass\nclass IsingModel:\n    quad: dict[tuple[int, int], float]\n    linear: dict[int, float]\n    constant: float\n\n    def calc_energy(self, state: list[int]) -&gt; float:\n        \"\"\"Calculates the energy of the state.\n\n        Examples:\n            &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n            &gt;&gt;&gt; ising.calc_energy([1, -1])\n            3.0\n\n        \"\"\"\n        energy = self.constant\n        for (i, j), value in self.quad.items():\n            energy += value * state[i] * state[j]\n        for i, value in self.linear.items():\n            energy += value * state[i]\n        return energy\n</code></pre>"},{"location":"reference/core/#qamomile.core.IsingModel.calc_energy","title":"<code>calc_energy(state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n&gt;&gt;&gt; ising.calc_energy([1, -1])\n3.0\n</code></pre> Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_energy(self, state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n        &gt;&gt;&gt; ising.calc_energy([1, -1])\n        3.0\n\n    \"\"\"\n    energy = self.constant\n    for (i, j), value in self.quad.items():\n        energy += value * state[i] * state[j]\n    for i, value in self.linear.items():\n        energy += value * state[i]\n    return energy\n</code></pre>"},{"location":"reference/core/#qamomile.core.greedy_graph_coloring","title":"<code>greedy_graph_coloring(graph: typ.Iterable[tuple[int, int]], max_color_group_size: int, init_coloring: typ.Optional[dict[int, int]] = None) -&gt; tuple[dict[int, int], dict[int, list[int]]]</code>","text":"<p>graph coloring for QRAC</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Iterable[tuple[int, int]]</code> <p>description</p> required <code>max_color_group_size</code> <code>int</code> <p>if you want to use for the qrac31, set 3.</p> required <code>init_coloring</code> <code>Optional[dict[int, int]]</code> <p>initial coloring. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[int, int], dict[int, list[int]]]</code> <p>tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n&gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n</code></pre> Source code in <code>qamomile/core/qrac/graph_coloring.py</code> <pre><code>def greedy_graph_coloring(\n    graph: typ.Iterable[tuple[int, int]],\n    max_color_group_size: int,\n    init_coloring: typ.Optional[dict[int, int]] = None,\n) -&gt; tuple[dict[int, int], dict[int, list[int]]]:\n    \"\"\"graph coloring for QRAC\n\n    Args:\n        graph (typ.Iterable[tuple[int, int]]): _description_\n        max_color_group_size (int): if you want to use for the qrac31, set 3.\n        init_coloring (typ.Optional[dict[int, int]], optional): initial coloring. Defaults to None.\n\n    Returns:\n        tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group\n\n\n    Examples:\n        &gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n        &gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n        ({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n\n    \"\"\"\n    coloring = {}\n    if init_coloring:\n        coloring.update(init_coloring)\n\n    max_color = max(coloring.values()) if coloring else -1\n\n    adj_matrix: dict[int, list[int]] = {}\n    for i, j in graph:\n        if i == j:\n            continue\n        if i not in adj_matrix:\n            adj_matrix[i] = []\n        if j not in adj_matrix:\n            adj_matrix[j] = []\n        adj_matrix[i].append(j)\n        adj_matrix[j].append(i)\n\n    color_group: dict[int, list[int]] = {}\n    for index, color in coloring.items():\n        if color not in coloring:\n            color_group[color] = []\n        color_group[color].append(index)\n\n    for i, neigborhoors in adj_matrix.items():\n        if i in coloring:\n            continue\n\n        neighbor_colors = [coloring[k] for k in neigborhoors if k in coloring]\n\n        done_coloring = False\n        for color in range(max_color + 1):\n            if color not in color_group or color not in neighbor_colors:\n                if color not in color_group or max_color_group_size &gt; len(\n                    color_group[color]\n                ):\n                    coloring[i] = color\n                    done_coloring = True\n                    if color not in color_group:\n                        color_group[color] = []\n                    color_group[color].append(i)\n                    break\n        if not done_coloring:\n            coloring[i] = max_color + 1\n            color_group[max_color + 1] = [i]\n            max_color += 1\n\n    return coloring, color_group\n</code></pre>"},{"location":"reference/core/#qamomile.core.qubo_to_ising","title":"<code>qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel</code>","text":"<p>Converts a QUBO to an Ising model.</p> <p>QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; binary = [1, 0]\n&gt;&gt;&gt; spin = [-1, 1]\n&gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n&gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n</code></pre> <pre><code>&gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; assert ising.constant == -0.5\n&gt;&gt;&gt; assert ising.linear == {}\n&gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n</code></pre> Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>def qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel:\n    \"\"\"Converts a QUBO to an Ising model.\n\n    QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i\n    Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}\n\n    Examples:\n        &gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; binary = [1, 0]\n        &gt;&gt;&gt; spin = [-1, 1]\n        &gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n        &gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n\n        &gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; assert ising.constant == -0.5\n        &gt;&gt;&gt; assert ising.linear == {}\n        &gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n\n    \"\"\"\n    ising_J: dict[tuple[int, int], float] = {}\n    ising_h: dict[int, float] = {}\n    constant = 0.0\n    for (i, j), value in qubo.items():\n        if i != j:\n            ising_J[(i, j)] = value / 4.0 + ising_J.get((i, j), 0.0)\n            constant += value / 4.0\n        else:\n            constant += value / 2.0\n        ising_h[i] = -value / 4.0 + ising_h.get(i, 0.0)\n        ising_h[j] = -value / 4.0 + ising_h.get(j, 0.0)\n\n    if simplify:\n        ising_J = {ij: value for ij, value in ising_J.items() if value != 0.0}\n        ising_h = {i: value for i, value in ising_h.items() if value != 0.0}\n    return IsingModel(ising_J, ising_h, constant)\n</code></pre>"},{"location":"reference/core/ising_qubo/","title":"Ising qubo","text":""},{"location":"reference/core/ising_qubo/#qamomile.core.ising_qubo.IsingModel","title":"<code>IsingModel</code>  <code>dataclass</code>","text":"Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>@dataclasses.dataclass\nclass IsingModel:\n    quad: dict[tuple[int, int], float]\n    linear: dict[int, float]\n    constant: float\n\n    def calc_energy(self, state: list[int]) -&gt; float:\n        \"\"\"Calculates the energy of the state.\n\n        Examples:\n            &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n            &gt;&gt;&gt; ising.calc_energy([1, -1])\n            3.0\n\n        \"\"\"\n        energy = self.constant\n        for (i, j), value in self.quad.items():\n            energy += value * state[i] * state[j]\n        for i, value in self.linear.items():\n            energy += value * state[i]\n        return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/#qamomile.core.ising_qubo.IsingModel.calc_energy","title":"<code>calc_energy(state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n&gt;&gt;&gt; ising.calc_energy([1, -1])\n3.0\n</code></pre> Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_energy(self, state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n        &gt;&gt;&gt; ising.calc_energy([1, -1])\n        3.0\n\n    \"\"\"\n    energy = self.constant\n    for (i, j), value in self.quad.items():\n        energy += value * state[i] * state[j]\n    for i, value in self.linear.items():\n        energy += value * state[i]\n    return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/#qamomile.core.ising_qubo.calc_qubo_energy","title":"<code>calc_qubo_energy(qubo: dict[tuple[int, int], float], state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calc_qubo_energy({(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}, [1, 1])\n6.0\n</code></pre> Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_qubo_energy(qubo: dict[tuple[int, int], float], state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; calc_qubo_energy({(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}, [1, 1])\n        6.0\n    \"\"\"\n    energy = 0.0\n    for (i, j), value in qubo.items():\n        energy += value * state[i] * state[j]\n    return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/#qamomile.core.ising_qubo.qubo_to_ising","title":"<code>qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel</code>","text":"<p>Converts a QUBO to an Ising model.</p> <p>QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; binary = [1, 0]\n&gt;&gt;&gt; spin = [-1, 1]\n&gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n&gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n</code></pre> <pre><code>&gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; assert ising.constant == -0.5\n&gt;&gt;&gt; assert ising.linear == {}\n&gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n</code></pre> Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>def qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel:\n    \"\"\"Converts a QUBO to an Ising model.\n\n    QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i\n    Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}\n\n    Examples:\n        &gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; binary = [1, 0]\n        &gt;&gt;&gt; spin = [-1, 1]\n        &gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n        &gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n\n        &gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; assert ising.constant == -0.5\n        &gt;&gt;&gt; assert ising.linear == {}\n        &gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n\n    \"\"\"\n    ising_J: dict[tuple[int, int], float] = {}\n    ising_h: dict[int, float] = {}\n    constant = 0.0\n    for (i, j), value in qubo.items():\n        if i != j:\n            ising_J[(i, j)] = value / 4.0 + ising_J.get((i, j), 0.0)\n            constant += value / 4.0\n        else:\n            constant += value / 2.0\n        ising_h[i] = -value / 4.0 + ising_h.get(i, 0.0)\n        ising_h[j] = -value / 4.0 + ising_h.get(j, 0.0)\n\n    if simplify:\n        ising_J = {ij: value for ij, value in ising_J.items() if value != 0.0}\n        ising_h = {i: value for i, value in ising_h.items() if value != 0.0}\n    return IsingModel(ising_J, ising_h, constant)\n</code></pre>"},{"location":"reference/core/ising_qubo/ising_qubo/","title":"Ising qubo","text":""},{"location":"reference/core/ising_qubo/ising_qubo/#qamomile.core.ising_qubo.ising_qubo.IsingModel","title":"<code>IsingModel</code>  <code>dataclass</code>","text":"Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>@dataclasses.dataclass\nclass IsingModel:\n    quad: dict[tuple[int, int], float]\n    linear: dict[int, float]\n    constant: float\n\n    def calc_energy(self, state: list[int]) -&gt; float:\n        \"\"\"Calculates the energy of the state.\n\n        Examples:\n            &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n            &gt;&gt;&gt; ising.calc_energy([1, -1])\n            3.0\n\n        \"\"\"\n        energy = self.constant\n        for (i, j), value in self.quad.items():\n            energy += value * state[i] * state[j]\n        for i, value in self.linear.items():\n            energy += value * state[i]\n        return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/ising_qubo/#qamomile.core.ising_qubo.ising_qubo.IsingModel.calc_energy","title":"<code>calc_energy(state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n&gt;&gt;&gt; ising.calc_energy([1, -1])\n3.0\n</code></pre> Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_energy(self, state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; ising = IsingModel({(0, 1): 2.0}, {0: 4.0, 1: 5.0}, 6.0)\n        &gt;&gt;&gt; ising.calc_energy([1, -1])\n        3.0\n\n    \"\"\"\n    energy = self.constant\n    for (i, j), value in self.quad.items():\n        energy += value * state[i] * state[j]\n    for i, value in self.linear.items():\n        energy += value * state[i]\n    return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/ising_qubo/#qamomile.core.ising_qubo.ising_qubo.calc_qubo_energy","title":"<code>calc_qubo_energy(qubo: dict[tuple[int, int], float], state: list[int]) -&gt; float</code>","text":"<p>Calculates the energy of the state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calc_qubo_energy({(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}, [1, 1])\n6.0\n</code></pre> Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>def calc_qubo_energy(qubo: dict[tuple[int, int], float], state: list[int]) -&gt; float:\n    \"\"\"Calculates the energy of the state.\n\n    Examples:\n        &gt;&gt;&gt; calc_qubo_energy({(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}, [1, 1])\n        6.0\n    \"\"\"\n    energy = 0.0\n    for (i, j), value in qubo.items():\n        energy += value * state[i] * state[j]\n    return energy\n</code></pre>"},{"location":"reference/core/ising_qubo/ising_qubo/#qamomile.core.ising_qubo.ising_qubo.qubo_to_ising","title":"<code>qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel</code>","text":"<p>Converts a QUBO to an Ising model.</p> <p>QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; binary = [1, 0]\n&gt;&gt;&gt; spin = [-1, 1]\n&gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n&gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n</code></pre> <pre><code>&gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n&gt;&gt;&gt; ising = qubo_to_ising(qubo)\n&gt;&gt;&gt; assert ising.constant == -0.5\n&gt;&gt;&gt; assert ising.linear == {}\n&gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n</code></pre> Source code in <code>qamomile/core/ising_qubo/ising_qubo.py</code> <pre><code>def qubo_to_ising(qubo: dict[tuple[int, int], float], simplify=True) -&gt; IsingModel:\n    \"\"\"Converts a QUBO to an Ising model.\n\n    QUBO: sum_{ij} Q_{ij} x_i x_j -&gt; Ising: sum_{ij} J_{ij} z_i z_j + sum_i h_i z_i\n    Correspondence - x_i = (1 - z_i) / 2, where x_i in {0, 1} and z_i in {-1, 1}\n\n    Examples:\n        &gt;&gt;&gt; qubo = {(0, 0): 1.0, (0, 1): 2.0, (1, 1): 3.0}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; binary = [1, 0]\n        &gt;&gt;&gt; spin = [-1, 1]\n        &gt;&gt;&gt; qubo_energy = calc_qubo_energy(qubo, binary)\n        &gt;&gt;&gt; assert qubo_energy == ising.calc_energy(spin)\n\n        &gt;&gt;&gt; qubo = {(0, 1): 2, (0, 0): -1, (1, 1): -1}\n        &gt;&gt;&gt; ising = qubo_to_ising(qubo)\n        &gt;&gt;&gt; assert ising.constant == -0.5\n        &gt;&gt;&gt; assert ising.linear == {}\n        &gt;&gt;&gt; assert ising.quad == {(0, 1): 0.5}\n\n    \"\"\"\n    ising_J: dict[tuple[int, int], float] = {}\n    ising_h: dict[int, float] = {}\n    constant = 0.0\n    for (i, j), value in qubo.items():\n        if i != j:\n            ising_J[(i, j)] = value / 4.0 + ising_J.get((i, j), 0.0)\n            constant += value / 4.0\n        else:\n            constant += value / 2.0\n        ising_h[i] = -value / 4.0 + ising_h.get(i, 0.0)\n        ising_h[j] = -value / 4.0 + ising_h.get(j, 0.0)\n\n    if simplify:\n        ising_J = {ij: value for ij, value in ising_J.items() if value != 0.0}\n        ising_h = {i: value for i, value in ising_h.items() if value != 0.0}\n    return IsingModel(ising_J, ising_h, constant)\n</code></pre>"},{"location":"reference/core/qrac/","title":"Qrac","text":"<p>This module provides utilities for the Quantum Random Access Coding (QRAC). Ex: QRAC utilizes are used Quantum Random Access Optimization (QRAO).</p>"},{"location":"reference/core/qrac/#qamomile.core.qrac.check_linear_term","title":"<code>check_linear_term(color_group: dict[int, list[int]], linear_term_index: list[int], max_color_group_size: int) -&gt; dict[int, list[int]]</code>","text":"<p>Search for items within the index of linear term that have not been assigned to the color_group, and add them.</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>color_group</p> required <code>linear_term_index</code> <code>list[int]</code> <p>list of index of linear term</p> required <code>max_color_group_size</code> <code>int</code> <p>the maximum number of encoding qubits. if you want to use for the qrac31, set 3.</p> required <p>Returns:</p> Type Description <code>dict[int, list[int]]</code> <p>dict[int, list[int]]: color_group which added items within the index of linear term that have not been assigned to the color_group.</p> Source code in <code>qamomile/core/qrac/graph_coloring.py</code> <pre><code>def check_linear_term(\n    color_group: dict[int, list[int]],\n    linear_term_index: list[int],\n    max_color_group_size: int,\n) -&gt; dict[int, list[int]]:\n    \"\"\"Search for items within the index of linear term that have not been assigned to the color_group, and add them.\n\n    Args:\n        color_group (dict[int, list[int]]): color_group\n        linear_term_index (list[int]): list of index of linear term\n        max_color_group_size (int): the maximum number of encoding qubits. if you want to use for the qrac31, set 3.\n\n    Returns:\n        dict[int, list[int]]: color_group which added items within the index of linear term that have not been assigned to the color_group.\n    \"\"\"\n    idx_in_color_group = []\n    for v in color_group.values():\n        idx_in_color_group.extend(v)\n\n    # We're adding a bit to the next index of the 'quad' qubit, affecting only the linear term. \n    # If the Ising Hamiltonian has only linear terms, making 'quad' empty and causing a 'max' error, we return index 0 to avoid this.\n    qubit_index_for_linear = max(color_group.keys()) + 1 if color_group else 0\n    bits_in_qubits_counter = 1\n    for idx in linear_term_index:\n        if idx not in idx_in_color_group:\n            if bits_in_qubits_counter == 1:\n                color_group[qubit_index_for_linear] = []\n\n            color_group[qubit_index_for_linear].append(idx)\n            bits_in_qubits_counter += 1\n\n            if bits_in_qubits_counter &gt; max_color_group_size:\n                qubit_index_for_linear += 1\n                bits_in_qubits_counter = 1\n\n    return color_group\n</code></pre>"},{"location":"reference/core/qrac/#qamomile.core.qrac.greedy_graph_coloring","title":"<code>greedy_graph_coloring(graph: typ.Iterable[tuple[int, int]], max_color_group_size: int, init_coloring: typ.Optional[dict[int, int]] = None) -&gt; tuple[dict[int, int], dict[int, list[int]]]</code>","text":"<p>graph coloring for QRAC</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Iterable[tuple[int, int]]</code> <p>description</p> required <code>max_color_group_size</code> <code>int</code> <p>if you want to use for the qrac31, set 3.</p> required <code>init_coloring</code> <code>Optional[dict[int, int]]</code> <p>initial coloring. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[int, int], dict[int, list[int]]]</code> <p>tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n&gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n</code></pre> Source code in <code>qamomile/core/qrac/graph_coloring.py</code> <pre><code>def greedy_graph_coloring(\n    graph: typ.Iterable[tuple[int, int]],\n    max_color_group_size: int,\n    init_coloring: typ.Optional[dict[int, int]] = None,\n) -&gt; tuple[dict[int, int], dict[int, list[int]]]:\n    \"\"\"graph coloring for QRAC\n\n    Args:\n        graph (typ.Iterable[tuple[int, int]]): _description_\n        max_color_group_size (int): if you want to use for the qrac31, set 3.\n        init_coloring (typ.Optional[dict[int, int]], optional): initial coloring. Defaults to None.\n\n    Returns:\n        tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group\n\n\n    Examples:\n        &gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n        &gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n        ({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n\n    \"\"\"\n    coloring = {}\n    if init_coloring:\n        coloring.update(init_coloring)\n\n    max_color = max(coloring.values()) if coloring else -1\n\n    adj_matrix: dict[int, list[int]] = {}\n    for i, j in graph:\n        if i == j:\n            continue\n        if i not in adj_matrix:\n            adj_matrix[i] = []\n        if j not in adj_matrix:\n            adj_matrix[j] = []\n        adj_matrix[i].append(j)\n        adj_matrix[j].append(i)\n\n    color_group: dict[int, list[int]] = {}\n    for index, color in coloring.items():\n        if color not in coloring:\n            color_group[color] = []\n        color_group[color].append(index)\n\n    for i, neigborhoors in adj_matrix.items():\n        if i in coloring:\n            continue\n\n        neighbor_colors = [coloring[k] for k in neigborhoors if k in coloring]\n\n        done_coloring = False\n        for color in range(max_color + 1):\n            if color not in color_group or color not in neighbor_colors:\n                if color not in color_group or max_color_group_size &gt; len(\n                    color_group[color]\n                ):\n                    coloring[i] = color\n                    done_coloring = True\n                    if color not in color_group:\n                        color_group[color] = []\n                    color_group[color].append(i)\n                    break\n        if not done_coloring:\n            coloring[i] = max_color + 1\n            color_group[max_color + 1] = [i]\n            max_color += 1\n\n    return coloring, color_group\n</code></pre>"},{"location":"reference/core/qrac/graph_coloring/","title":"Graph coloring","text":""},{"location":"reference/core/qrac/graph_coloring/#qamomile.core.qrac.graph_coloring.check_linear_term","title":"<code>check_linear_term(color_group: dict[int, list[int]], linear_term_index: list[int], max_color_group_size: int) -&gt; dict[int, list[int]]</code>","text":"<p>Search for items within the index of linear term that have not been assigned to the color_group, and add them.</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>color_group</p> required <code>linear_term_index</code> <code>list[int]</code> <p>list of index of linear term</p> required <code>max_color_group_size</code> <code>int</code> <p>the maximum number of encoding qubits. if you want to use for the qrac31, set 3.</p> required <p>Returns:</p> Type Description <code>dict[int, list[int]]</code> <p>dict[int, list[int]]: color_group which added items within the index of linear term that have not been assigned to the color_group.</p> Source code in <code>qamomile/core/qrac/graph_coloring.py</code> <pre><code>def check_linear_term(\n    color_group: dict[int, list[int]],\n    linear_term_index: list[int],\n    max_color_group_size: int,\n) -&gt; dict[int, list[int]]:\n    \"\"\"Search for items within the index of linear term that have not been assigned to the color_group, and add them.\n\n    Args:\n        color_group (dict[int, list[int]]): color_group\n        linear_term_index (list[int]): list of index of linear term\n        max_color_group_size (int): the maximum number of encoding qubits. if you want to use for the qrac31, set 3.\n\n    Returns:\n        dict[int, list[int]]: color_group which added items within the index of linear term that have not been assigned to the color_group.\n    \"\"\"\n    idx_in_color_group = []\n    for v in color_group.values():\n        idx_in_color_group.extend(v)\n\n    # We're adding a bit to the next index of the 'quad' qubit, affecting only the linear term. \n    # If the Ising Hamiltonian has only linear terms, making 'quad' empty and causing a 'max' error, we return index 0 to avoid this.\n    qubit_index_for_linear = max(color_group.keys()) + 1 if color_group else 0\n    bits_in_qubits_counter = 1\n    for idx in linear_term_index:\n        if idx not in idx_in_color_group:\n            if bits_in_qubits_counter == 1:\n                color_group[qubit_index_for_linear] = []\n\n            color_group[qubit_index_for_linear].append(idx)\n            bits_in_qubits_counter += 1\n\n            if bits_in_qubits_counter &gt; max_color_group_size:\n                qubit_index_for_linear += 1\n                bits_in_qubits_counter = 1\n\n    return color_group\n</code></pre>"},{"location":"reference/core/qrac/graph_coloring/#qamomile.core.qrac.graph_coloring.greedy_graph_coloring","title":"<code>greedy_graph_coloring(graph: typ.Iterable[tuple[int, int]], max_color_group_size: int, init_coloring: typ.Optional[dict[int, int]] = None) -&gt; tuple[dict[int, int], dict[int, list[int]]]</code>","text":"<p>graph coloring for QRAC</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Iterable[tuple[int, int]]</code> <p>description</p> required <code>max_color_group_size</code> <code>int</code> <p>if you want to use for the qrac31, set 3.</p> required <code>init_coloring</code> <code>Optional[dict[int, int]]</code> <p>initial coloring. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[int, int], dict[int, list[int]]]</code> <p>tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n&gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n</code></pre> Source code in <code>qamomile/core/qrac/graph_coloring.py</code> <pre><code>def greedy_graph_coloring(\n    graph: typ.Iterable[tuple[int, int]],\n    max_color_group_size: int,\n    init_coloring: typ.Optional[dict[int, int]] = None,\n) -&gt; tuple[dict[int, int], dict[int, list[int]]]:\n    \"\"\"graph coloring for QRAC\n\n    Args:\n        graph (typ.Iterable[tuple[int, int]]): _description_\n        max_color_group_size (int): if you want to use for the qrac31, set 3.\n        init_coloring (typ.Optional[dict[int, int]], optional): initial coloring. Defaults to None.\n\n    Returns:\n        tuple[dict[int, int], dict[int, list[int]]]: coloring, color_group\n\n\n    Examples:\n        &gt;&gt;&gt; graph = [(0, 1), (1, 2), (2, 0), (0, 4)]\n        &gt;&gt;&gt; greedy_graph_coloring(graph, 2)\n        ({0: 0, 1: 1, 2: 2, 4: 1}, {0: [0], 1: [1, 4], 2: [2]})\n\n    \"\"\"\n    coloring = {}\n    if init_coloring:\n        coloring.update(init_coloring)\n\n    max_color = max(coloring.values()) if coloring else -1\n\n    adj_matrix: dict[int, list[int]] = {}\n    for i, j in graph:\n        if i == j:\n            continue\n        if i not in adj_matrix:\n            adj_matrix[i] = []\n        if j not in adj_matrix:\n            adj_matrix[j] = []\n        adj_matrix[i].append(j)\n        adj_matrix[j].append(i)\n\n    color_group: dict[int, list[int]] = {}\n    for index, color in coloring.items():\n        if color not in coloring:\n            color_group[color] = []\n        color_group[color].append(index)\n\n    for i, neigborhoors in adj_matrix.items():\n        if i in coloring:\n            continue\n\n        neighbor_colors = [coloring[k] for k in neigborhoors if k in coloring]\n\n        done_coloring = False\n        for color in range(max_color + 1):\n            if color not in color_group or color not in neighbor_colors:\n                if color not in color_group or max_color_group_size &gt; len(\n                    color_group[color]\n                ):\n                    coloring[i] = color\n                    done_coloring = True\n                    if color not in color_group:\n                        color_group[color] = []\n                    color_group[color].append(i)\n                    break\n        if not done_coloring:\n            coloring[i] = max_color + 1\n            color_group[max_color + 1] = [i]\n            max_color += 1\n\n    return coloring, color_group\n</code></pre>"},{"location":"reference/qiskit/","title":"Qiskit","text":""},{"location":"reference/qiskit/#qamomile.qiskit.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method: jmt.core.pubo.RelaxationMethod = jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>qamomile/qiskit/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method: jmt.core.pubo.RelaxationMethod = jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/#qamomile.qiskit.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/#qamomile.qiskit.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/#qamomile.qiskit.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/#qamomile.qiskit.transpile_to_qrac_space_efficient_hamiltonian","title":"<code>transpile_to_qrac_space_efficient_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize=True) -&gt; QRACSpaceEfficientBuilder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.</p> <pre><code>This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\nIn this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRACSpaceEfficientBuilder</code> <code>QRACSpaceEfficientBuilder</code> <p>Space-efficient QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac_space_efficient_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize=True\n) -&gt; QRACSpaceEfficientBuilder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.\n\n        This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n        In this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRACSpaceEfficientBuilder: Space-efficient QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRACSpaceEfficientBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/","title":"Minimal encoding","text":""},{"location":"reference/qiskit/minimal_encoding/#qamomile.qiskit.minimal_encoding.transpile_to_minimal_encoding","title":"<code>transpile_to_minimal_encoding(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; MinimalEncodingBuilder</code>","text":"<p>Function to transpile a compiled instance to a minimal encoding builder</p> <pre><code>Generating Minimal Encoding Builder from a compiled instance.\nMinimal encoding is a method to reduce the number of qubits and classical bits.\nThe method is first proposed by Tan, Benjamin, et al. \"Qubit-efficient encoding schemes for binary optimisation problems.\" Quantum 5 (2021): 454.\nMore information is on https://quantum-journal.org/papers/q-2021-05-04-454/\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>compiled instance</p> required <code>normalize</code> <code>bool</code> <p>whether to normalize the coefficients or not. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>MinimalEncodingBuilder</code> <code>MinimalEncodingBuilder</code> <p>minimal encoding builder</p> Source code in <code>qamomile/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def transpile_to_minimal_encoding(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; MinimalEncodingBuilder:\n    \"\"\"Function to transpile a compiled instance to a minimal encoding builder\n\n        Generating Minimal Encoding Builder from a compiled instance.\n        Minimal encoding is a method to reduce the number of qubits and classical bits.\n        The method is first proposed by Tan, Benjamin, et al. \"Qubit-efficient encoding schemes for binary optimisation problems.\" Quantum 5 (2021): 454.\n        More information is on https://quantum-journal.org/papers/q-2021-05-04-454/\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): compiled instance\n        normalize (bool, optional): whether to normalize the coefficients or not. Defaults to True.\n\n    Returns:\n        MinimalEncodingBuilder: minimal encoding builder\n    \"\"\"\n\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return MinimalEncodingBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/cost_function/","title":"Cost function","text":""},{"location":"reference/qiskit/minimal_encoding/cost_function/#qamomile.qiskit.minimal_encoding.cost_function.define_pauli_op","title":"<code>define_pauli_op(num_register_bits: int, ancilla: bool = False) -&gt; list[qk_info.SparsePauliOp]</code>","text":"<p>Function to define pauli operators</p> <p>Parameters:</p> Name Type Description Default <code>num_register_bits</code> <code>int</code> <p>number of register bits</p> required <code>ancilla</code> <code>bool</code> <p>whether to add ancilla qubit |1&gt; or not. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if num_register_bits &lt; 1</p> <p>Returns:</p> Type Description <code>list[SparsePauliOp]</code> <p>list[qk_info.SparsePauliOp]: list of pauli operators</p> Source code in <code>qamomile/qiskit/minimal_encoding/cost_function.py</code> <pre><code>def define_pauli_op(\n    num_register_bits: int, ancilla: bool = False\n) -&gt; list[qk_info.SparsePauliOp]:\n    \"\"\"Function to define pauli operators\n\n    Args:\n        num_register_bits (int): number of register bits\n        ancilla (bool, optional): whether to add ancilla qubit |1&gt; or not. Defaults to False.\n\n    Raises:\n        ValueError: if num_register_bits &lt; 1\n\n    Returns:\n        list[qk_info.SparsePauliOp]: list of pauli operators\n    \"\"\"\n\n    if num_register_bits &lt; 1:\n        raise ValueError(\"num_register_bits must be greater than 0\")\n\n    z = [[False], [True]]\n    x = [[False], [False]]\n    zero_op = qk_info.SparsePauliOp(\n        qk_info.PauliList.from_symplectic(z, x), coeffs=[1 / 2, 1 / 2]\n    )\n\n    one_op = qk_info.SparsePauliOp(\n        qk_info.PauliList.from_symplectic(z, x), coeffs=[1 / 2, -1 / 2]\n    )\n\n    identity_op = qk_info.SparsePauliOp(qk_info.Pauli(([0], [0])))\n\n    ancilla_operator = one_op if ancilla else identity_op\n\n    pauli_ops = []\n\n    if num_register_bits == 1:\n        for _op in [one_op, zero_op]:\n            pauli_ops.append(_op.tensor(ancilla_operator))\n    else:\n        for val in itertools.product(\n            [one_op, zero_op], repeat=num_register_bits\n        ):\n            pauli_op = val[0]\n            for _op in val[1:]:\n                pauli_op = pauli_op.tensor(_op)\n\n            pauli_ops.append(pauli_op.tensor(ancilla_operator))\n\n    return pauli_ops\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/cost_function/#qamomile.qiskit.minimal_encoding.cost_function.initialize_cost_function","title":"<code>initialize_cost_function(qubo: dict[tuple[int, int], float], num_cbits: int) -&gt; Callable[[np.array], float]</code>","text":"<p>Function to initialize cost function for minimal encoding</p> <p>Parameters:</p> Name Type Description Default <code>qubo</code> <code>dict[tuple[int, int], float]</code> <p>QUBO Matrix</p> required <code>num_cbit</code> <code>int</code> <p>number of classical bits</p> required <p>Returns:</p> Type Description <code>Callable[[array], float]</code> <p>Callable[[np.array], float]: cost function for minimal encoding</p> Source code in <code>qamomile/qiskit/minimal_encoding/cost_function.py</code> <pre><code>def initialize_cost_function(\n    qubo: dict[tuple[int, int], float], num_cbits: int\n) -&gt; Callable[[np.array], float]:\n    \"\"\"Function to initialize cost function for minimal encoding\n\n    Args:\n        qubo (dict[tuple[int, int], float]): QUBO Matrix\n        num_cbit (int): number of classical bits\n\n    Returns:\n        Callable[[np.array], float]: cost function for minimal encoding\n    \"\"\"\n\n    # define cost function\n    def cost_function(one_coeffs: np.array) -&gt; float:\n        \"\"\"Function to compute value of cost function for minimal encoding\n\n        Args:\n            one_coeffs (np.array): the ratio of the expectation value of each pauli operator for when ancilla qubit is |1&gt; and the expectation value of each pauli operator ignoring ancilla qubit\n\n        Returns:\n            float: value of cost function\n        \"\"\"\n\n        cost = 0\n        for i in range(num_cbits):\n            for j in range(i, num_cbits):\n                if i != j:\n                    cost += 2 * qubo[(i, j)] * one_coeffs[i] * one_coeffs[j]\n                else:\n                    cost += qubo[(i, j)] * one_coeffs[i]\n\n        return cost\n\n    return cost_function\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/","title":"To minimal encoding","text":""},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#qamomile.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodedInstance","title":"<code>MinimalEncodedInstance</code>","text":"Source code in <code>qamomile/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>class MinimalEncodedInstance:\n    def __init__(\n        self,\n        qubo: dict[tuple[int, int], float],\n        constant: float,\n        minimal_encoding_builder: MinimalEncodingBuilder,\n    ):\n        self.qubo = qubo\n        self.constant = constant\n        self.minimal_encoding_builder = minimal_encoding_builder\n        self._calculate_register_qubits(self.qubo)\n\n    def _calculate_register_qubits(self, qubo: dict[tuple[int, int], float]):\n        \"\"\"Function to calculate the number of register qubits\n\n        Args:\n            qubo (dict[tuple[int, int], float]): QUBO Matrix\n\n        Returns:\n            int: number of register qubits\n        \"\"\"\n        self.num_cbits = max(max(i, j) for i, j in qubo.keys()) + 1\n        self.num_register_bits = np.ceil(np.log2(self.num_cbits)).astype(int)\n\n    def _get_cost_function(self) -&gt; Callable[[np.array], float]:\n        return initialize_cost_function(self.qubo, self.num_cbits)\n\n    def get_minimized_function(\n        self,\n        ansatz: qk.circuit.quantumcircuit.QuantumCircuit,\n        num_shots: int = None,\n    ) -&gt; Callable[[dict], float]:\n        \"\"\"Method to generate cost function which should be minimized by classical optimizer\n\n            In minimal encoding, rather than directly minimizing the value of the Hamiltonian,\n            we minimize the cost function calculated using the expected values obtained from the quantum device.\n            Therefore, this function returns a function that carries out a process not just for the Hamiltonian,\n            but also for the calculation of expected values and the subsequent calculation of the cost function.\n\n        Args:\n            ansatz (qk.circuit.quantumcircuit.QuantumCircuit): variational ansatz (parameterized quantum circuit)\n            num_shots (int, optional): The number of shots. If None, it calculates the exact expectation values. Otherwise, it samples from normal distributions with standard errors as standard deviations using normal distribution approximation. Defaults to None.\n\n        Returns:\n            Callable[[dict], float]: function to be minimized by classical optimizer\n        \"\"\"\n        # get expectation values from a circuit\n        # get a list of H (observables), which is a list of SparsePauliOp\n        H = define_pauli_op(self.num_register_bits)\n        Ha = define_pauli_op(self.num_register_bits, ancilla=True)\n\n        cost_function = self._get_cost_function()\n\n        estimator = Estimator()\n        if num_shots is not None:\n            estimator.set_options(shots=num_shots)\n\n        def minimized_func(params: Sequence[float]) -&gt; float:\n            \"\"\"Function to be minimized by classical optimizer\n\n            Args:\n                params (Sequence[float]): parameters of the circuit\n\n            Returns:\n                float: value of the cost function\n            \"\"\"\n\n            job1 = estimator.run([ansatz] * len(H), H, [params] * len(H))\n            P = job1.result()\n\n            job2 = estimator.run([ansatz] * len(Ha), Ha, [params] * len(Ha))\n            P1 = job2.result()\n\n            one_coeffs = P1.values / P.values\n\n            cost = cost_function(one_coeffs)\n\n            return cost\n\n        return minimized_func\n\n    def get_optimized_state(\n        self,\n        circuit: qk.circuit.quantumcircuit.QuantumCircuit,\n        params: Sequence[float],\n    ) -&gt; jm.SampleSet:\n        \"\"\"Function to get final binary list from the circuit and optimised parameters.\n\n            In minimal encoding, we estimate the state not through simple quantum state sampling,\n            but as a specific amount of expected values.\n            Therefore, in this function, we calculate the expected values for state estimation based on the parameters obtained through optimization.\n\n        Args:\n            circuit (qk.circuit.quantumcircuit.QuantumCircuit): parameterised quantum circuit\n            params (Sequence[float]): optimised parameters\n\n        Returns:\n            jm.Sampleset: samplset of the results\n        \"\"\"\n        estimator = Estimator()\n        # define observable to calculate expectation value\n        H = define_pauli_op(self.num_register_bits, ancilla=False)\n        Ha = define_pauli_op(self.num_register_bits, ancilla=True)\n        # get expectation values from\n        job1 = estimator.run([circuit] * len(H), H, [params] * len(H))\n        P = job1.result()\n\n        job2 = estimator.run([circuit] * len(Ha), Ha, [params] * len(Ha))\n        P1 = job2.result()\n        prob_one = (P1.values / P.values) ** 2\n        final_binary = np.array(prob_one &gt;= 0.5, dtype=int)\n\n        sample_set = self._decode_from_binary_values(\n            [final_binary[: self.num_cbits]]\n        )\n\n        return sample_set\n\n    def _decode_from_binary_values(\n        self, binary_list: typ.Iterable[list[int]]\n    ) -&gt; jm.SampleSet:\n        binary_results = [\n            {i: value for i, value in enumerate(binary)}\n            for binary in binary_list\n        ]\n        binary_encoder = (\n            self.minimal_encoding_builder.pubo_builder.binary_encoder\n        )\n        decoded: jm.SampleSet = (\n            jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n                binary_results,\n                binary_encoder,\n                self.minimal_encoding_builder.compiled_instance,\n            )\n        )\n\n        num_occurrences = [1] * len(binary_results)\n        decoded = jm.SampleSet(\n            record=jm.Record(\n                num_occurrences=num_occurrences,\n                solution=decoded.record.solution,\n            ),\n            evaluation=decoded.evaluation,\n            measuring_time=decoded.measuring_time,\n            metadata=decoded.metadata,\n        )\n        return decoded\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#qamomile.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodedInstance.get_minimized_function","title":"<code>get_minimized_function(ansatz: qk.circuit.quantumcircuit.QuantumCircuit, num_shots: int = None) -&gt; Callable[[dict], float]</code>","text":"<p>Method to generate cost function which should be minimized by classical optimizer</p> <pre><code>In minimal encoding, rather than directly minimizing the value of the Hamiltonian,\nwe minimize the cost function calculated using the expected values obtained from the quantum device.\nTherefore, this function returns a function that carries out a process not just for the Hamiltonian,\nbut also for the calculation of expected values and the subsequent calculation of the cost function.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ansatz</code> <code>QuantumCircuit</code> <p>variational ansatz (parameterized quantum circuit)</p> required <code>num_shots</code> <code>int</code> <p>The number of shots. If None, it calculates the exact expectation values. Otherwise, it samples from normal distributions with standard errors as standard deviations using normal distribution approximation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[dict], float]</code> <p>Callable[[dict], float]: function to be minimized by classical optimizer</p> Source code in <code>qamomile/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def get_minimized_function(\n    self,\n    ansatz: qk.circuit.quantumcircuit.QuantumCircuit,\n    num_shots: int = None,\n) -&gt; Callable[[dict], float]:\n    \"\"\"Method to generate cost function which should be minimized by classical optimizer\n\n        In minimal encoding, rather than directly minimizing the value of the Hamiltonian,\n        we minimize the cost function calculated using the expected values obtained from the quantum device.\n        Therefore, this function returns a function that carries out a process not just for the Hamiltonian,\n        but also for the calculation of expected values and the subsequent calculation of the cost function.\n\n    Args:\n        ansatz (qk.circuit.quantumcircuit.QuantumCircuit): variational ansatz (parameterized quantum circuit)\n        num_shots (int, optional): The number of shots. If None, it calculates the exact expectation values. Otherwise, it samples from normal distributions with standard errors as standard deviations using normal distribution approximation. Defaults to None.\n\n    Returns:\n        Callable[[dict], float]: function to be minimized by classical optimizer\n    \"\"\"\n    # get expectation values from a circuit\n    # get a list of H (observables), which is a list of SparsePauliOp\n    H = define_pauli_op(self.num_register_bits)\n    Ha = define_pauli_op(self.num_register_bits, ancilla=True)\n\n    cost_function = self._get_cost_function()\n\n    estimator = Estimator()\n    if num_shots is not None:\n        estimator.set_options(shots=num_shots)\n\n    def minimized_func(params: Sequence[float]) -&gt; float:\n        \"\"\"Function to be minimized by classical optimizer\n\n        Args:\n            params (Sequence[float]): parameters of the circuit\n\n        Returns:\n            float: value of the cost function\n        \"\"\"\n\n        job1 = estimator.run([ansatz] * len(H), H, [params] * len(H))\n        P = job1.result()\n\n        job2 = estimator.run([ansatz] * len(Ha), Ha, [params] * len(Ha))\n        P1 = job2.result()\n\n        one_coeffs = P1.values / P.values\n\n        cost = cost_function(one_coeffs)\n\n        return cost\n\n    return minimized_func\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#qamomile.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodedInstance.get_optimized_state","title":"<code>get_optimized_state(circuit: qk.circuit.quantumcircuit.QuantumCircuit, params: Sequence[float]) -&gt; jm.SampleSet</code>","text":"<p>Function to get final binary list from the circuit and optimised parameters.</p> <pre><code>In minimal encoding, we estimate the state not through simple quantum state sampling,\nbut as a specific amount of expected values.\nTherefore, in this function, we calculate the expected values for state estimation based on the parameters obtained through optimization.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>QuantumCircuit</code> <p>parameterised quantum circuit</p> required <code>params</code> <code>Sequence[float]</code> <p>optimised parameters</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.Sampleset: samplset of the results</p> Source code in <code>qamomile/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def get_optimized_state(\n    self,\n    circuit: qk.circuit.quantumcircuit.QuantumCircuit,\n    params: Sequence[float],\n) -&gt; jm.SampleSet:\n    \"\"\"Function to get final binary list from the circuit and optimised parameters.\n\n        In minimal encoding, we estimate the state not through simple quantum state sampling,\n        but as a specific amount of expected values.\n        Therefore, in this function, we calculate the expected values for state estimation based on the parameters obtained through optimization.\n\n    Args:\n        circuit (qk.circuit.quantumcircuit.QuantumCircuit): parameterised quantum circuit\n        params (Sequence[float]): optimised parameters\n\n    Returns:\n        jm.Sampleset: samplset of the results\n    \"\"\"\n    estimator = Estimator()\n    # define observable to calculate expectation value\n    H = define_pauli_op(self.num_register_bits, ancilla=False)\n    Ha = define_pauli_op(self.num_register_bits, ancilla=True)\n    # get expectation values from\n    job1 = estimator.run([circuit] * len(H), H, [params] * len(H))\n    P = job1.result()\n\n    job2 = estimator.run([circuit] * len(Ha), Ha, [params] * len(Ha))\n    P1 = job2.result()\n    prob_one = (P1.values / P.values) ** 2\n    final_binary = np.array(prob_one &gt;= 0.5, dtype=int)\n\n    sample_set = self._decode_from_binary_values(\n        [final_binary[: self.num_cbits]]\n    )\n\n    return sample_set\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#qamomile.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodingBuilder","title":"<code>MinimalEncodingBuilder</code>","text":"Source code in <code>qamomile/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>class MinimalEncodingBuilder:\n    def __init__(\n        self,\n        pubo_builder: jmt.core.pubo.PuboBuilder,\n        compiled_instance: jmt.core.CompiledInstance,\n    ):\n        self.pubo_builder = pubo_builder\n        self.compiled_instance = compiled_instance\n\n    def get_encoded_instance(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[Callable[[np.array], float], float]:\n        \"\"\"method to get encoded instance\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[Callable[[np.array], float], float]: _description_\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        return MinimalEncodedInstance(qubo, constant, self)\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#qamomile.qiskit.minimal_encoding.to_minimal_encoding.MinimalEncodingBuilder.get_encoded_instance","title":"<code>get_encoded_instance(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[Callable[[np.array], float], float]</code>","text":"<p>method to get encoded instance</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Callable[[array], float], float]</code> <p>tuple[Callable[[np.array], float], float]: description</p> Source code in <code>qamomile/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def get_encoded_instance(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[Callable[[np.array], float], float]:\n    \"\"\"method to get encoded instance\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[Callable[[np.array], float], float]: _description_\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    return MinimalEncodedInstance(qubo, constant, self)\n</code></pre>"},{"location":"reference/qiskit/minimal_encoding/to_minimal_encoding/#qamomile.qiskit.minimal_encoding.to_minimal_encoding.transpile_to_minimal_encoding","title":"<code>transpile_to_minimal_encoding(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; MinimalEncodingBuilder</code>","text":"<p>Function to transpile a compiled instance to a minimal encoding builder</p> <pre><code>Generating Minimal Encoding Builder from a compiled instance.\nMinimal encoding is a method to reduce the number of qubits and classical bits.\nThe method is first proposed by Tan, Benjamin, et al. \"Qubit-efficient encoding schemes for binary optimisation problems.\" Quantum 5 (2021): 454.\nMore information is on https://quantum-journal.org/papers/q-2021-05-04-454/\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>compiled instance</p> required <code>normalize</code> <code>bool</code> <p>whether to normalize the coefficients or not. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>MinimalEncodingBuilder</code> <code>MinimalEncodingBuilder</code> <p>minimal encoding builder</p> Source code in <code>qamomile/qiskit/minimal_encoding/to_minimal_encoding.py</code> <pre><code>def transpile_to_minimal_encoding(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; MinimalEncodingBuilder:\n    \"\"\"Function to transpile a compiled instance to a minimal encoding builder\n\n        Generating Minimal Encoding Builder from a compiled instance.\n        Minimal encoding is a method to reduce the number of qubits and classical bits.\n        The method is first proposed by Tan, Benjamin, et al. \"Qubit-efficient encoding schemes for binary optimisation problems.\" Quantum 5 (2021): 454.\n        More information is on https://quantum-journal.org/papers/q-2021-05-04-454/\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): compiled instance\n        normalize (bool, optional): whether to normalize the coefficients or not. Defaults to True.\n\n    Returns:\n        MinimalEncodingBuilder: minimal encoding builder\n    \"\"\"\n\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return MinimalEncodingBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qaoa/","title":"Qaoa","text":""},{"location":"reference/qiskit/qaoa/ising_hamiltonian/","title":"Ising hamiltonian","text":""},{"location":"reference/qiskit/qaoa/ising_hamiltonian/#qamomile.qiskit.qaoa.ising_hamiltonian.to_ising_operator_from_qubo","title":"<code>to_ising_operator_from_qubo(qubo: dict[tuple[int, int], float], n_qubit: int) -&gt; tuple[qk_ope.SparsePauliOp, float]</code>","text":"<p>Returns a quantum circuit that represents the QUBO.</p> <p>Parameters:</p> Name Type Description Default <code>qubo</code> <code>dict[tuple[int, int], float]</code> <p>QUBO dictionary</p> required <code>n_qubit</code> <code>int</code> <p>number of qubits</p> required <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float]</code> <p>tuple[qk_ope.SparsePauliOp, float]: The Ising operator and the constant offset.</p> Source code in <code>qamomile/qiskit/qaoa/ising_hamiltonian.py</code> <pre><code>def to_ising_operator_from_qubo(\n    qubo: dict[tuple[int, int], float], n_qubit: int\n) -&gt; tuple[qk_ope.SparsePauliOp, float]:\n    \"\"\"Returns a quantum circuit that represents the QUBO.\n\n    Args:\n        qubo (dict[tuple[int, int], float]): QUBO dictionary\n        n_qubit (int):number of qubits\n\n    Returns:\n        tuple[qk_ope.SparsePauliOp, float]: The Ising operator and the constant offset.\n    \"\"\"\n    ising = qubo_to_ising(qubo)\n    pauli_terms: list[qk_ope.SparsePauliOp] = []\n\n    offset = ising.constant\n    zero = np.zeros(n_qubit, dtype=bool)\n\n    # convert linear parts of the objective function into Hamiltonian.\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        z_p = zero.copy()\n        z_p[idx] = True\n\n        pauli_terms.append(qk_ope.SparsePauliOp(qk_ope.Pauli((z_p, zero)), coeff))\n\n    # create Pauli terms\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n        else:\n            z_p = zero.copy()\n            z_p[i] = True\n            z_p[j] = True\n            pauli_terms.append(qk_ope.SparsePauliOp(qk_ope.Pauli((z_p, zero)), coeff))\n\n    if pauli_terms:\n        # Remove paulis whose coefficients are zeros.\n        qubit_op = sum(pauli_terms).simplify(atol=0)\n    else:\n        # If there is no variable, we set num_nodes=1 so that qubit_op should be an operator.\n        # If num_nodes=0, I^0 = 1 (int).\n        n_qubit = max(1, n_qubit)\n        qubit_op = qk_ope.SparsePauliOp(\"I\" * n_qubit, 0)\n\n    return qubit_op, offset\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/","title":"To qaoa","text":""},{"location":"reference/qiskit/qaoa/to_qaoa/#qamomile.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder","title":"<code>QAOAAnsatzBuilder</code>","text":"Source code in <code>qamomile/qiskit/qaoa/to_qaoa.py</code> <pre><code>class QAOAAnsatzBuilder:\n    def __init__(\n        self,\n        pubo_builder: jmt.core.pubo.PuboBuilder,\n        num_vars: int,\n        compiled_instance: jmt.core.CompiledInstance,\n    ):\n        \"\"\"Initialize the QAOAAnsatzBuilder.\n\n        Args:\n            pubo_builder (jmt.core.pubo.PuboBuilder): The PUBO builder to be used.\n            num_vars (int): The number of variables.\n            compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        \"\"\"\n        self.pubo_builder = pubo_builder\n        self.num_vars = num_vars\n        self.compiled_instance = compiled_instance\n\n    @property\n    def var_map(self) -&gt; dict[str, tuple[int, ...]]:\n        return self.compiled_instance.var_map.var_map\n\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float]:\n        \"\"\"Get the Ising Hamiltonian\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float]: The Ising operator and the constant offset.\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising_operator, ising_const = to_ising_operator_from_qubo(\n            qubo, self.num_vars\n        )\n        return ising_operator, ising_const + constant\n\n    def get_qaoa_ansatz(\n        self,\n        p: int,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]:\n        \"\"\"Get the QAOA Ansatz.\n\n        Args:\n            p (int): The number of layers in the QAOA circuit.\n            multipliers (typ.Optional[dict[str, float]], optional):Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]: The QAOA ansatz, the Ising operator, and the constant offset.\n        \"\"\"\n        ising_operator, constant = self.get_hamiltonian(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        qaoa_ansatz = qk.circuit.library.QAOAAnsatz(ising_operator, reps=p)\n        return qaoa_ansatz, ising_operator, constant\n\n    def decode_from_counts(self, counts: dict[str, int]) -&gt; jm.SampleSet:\n        \"\"\"Decode the counts to the SampleSet.\n\n        Args:\n            counts (dict[str, int]): The counts to be decoded.\n\n        Returns:\n            jm.SampleSet: The decoded sample set.\n        \"\"\"\n        samples = []\n        num_occurrences = []\n        for binary_str, count_num in counts.items():\n            binary_values = {idx: int(b) for idx, b in enumerate(binary_str)}\n            samples.append(binary_values)\n            num_occurrences.append(count_num)\n\n        binary_encoder = self.pubo_builder.binary_encoder\n        decoded: jm.SampleSet = (\n            jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n                samples, binary_encoder, self.compiled_instance\n            )\n        )\n        decoded = jm.SampleSet(\n            record=jm.Record(\n                num_occurrences=num_occurrences,\n                solution=decoded.record.solution,\n            ),\n            evaluation=decoded.evaluation,\n            measuring_time=decoded.measuring_time,\n            metadata=decoded.metadata,\n        )\n        return decoded\n\n    def decode_from_quasi_dist(\n        self, quasi_dist: qk.result.QuasiDistribution\n    ) -&gt; jm.SampleSet:\n        \"\"\"Decode the result from the probabilities.\n\n        Args:\n            quasi_dist (qk.result.QuasiDistribution): The probabilities to be decoded.\n\n        Returns:\n            jm.SampleSet: The decoded sample set.\n        \"\"\"\n        binary_prob: dict[str, float] = quasi_dist.binary_probabilities()\n\n        shots: int\n        if quasi_dist.shots:\n            shots = quasi_dist.shots\n        else:\n            if self.num_vars &lt; 15:\n                shots = max(2**self.num_vars, 100)\n            else:\n                shots = 30000\n\n        binary_counts = {\n            key: int(prob * shots) for key, prob in binary_prob.items()\n        }\n\n        return self.decode_from_counts(binary_counts)\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#qamomile.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.__init__","title":"<code>__init__(pubo_builder: jmt.core.pubo.PuboBuilder, num_vars: int, compiled_instance: jmt.core.CompiledInstance)</code>","text":"<p>Initialize the QAOAAnsatzBuilder.</p> <p>Parameters:</p> Name Type Description Default <code>pubo_builder</code> <code>PuboBuilder</code> <p>The PUBO builder to be used.</p> required <code>num_vars</code> <code>int</code> <p>The number of variables.</p> required <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required Source code in <code>qamomile/qiskit/qaoa/to_qaoa.py</code> <pre><code>def __init__(\n    self,\n    pubo_builder: jmt.core.pubo.PuboBuilder,\n    num_vars: int,\n    compiled_instance: jmt.core.CompiledInstance,\n):\n    \"\"\"Initialize the QAOAAnsatzBuilder.\n\n    Args:\n        pubo_builder (jmt.core.pubo.PuboBuilder): The PUBO builder to be used.\n        num_vars (int): The number of variables.\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n    \"\"\"\n    self.pubo_builder = pubo_builder\n    self.num_vars = num_vars\n    self.compiled_instance = compiled_instance\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#qamomile.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.decode_from_counts","title":"<code>decode_from_counts(counts: dict[str, int]) -&gt; jm.SampleSet</code>","text":"<p>Decode the counts to the SampleSet.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>dict[str, int]</code> <p>The counts to be decoded.</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.SampleSet: The decoded sample set.</p> Source code in <code>qamomile/qiskit/qaoa/to_qaoa.py</code> <pre><code>def decode_from_counts(self, counts: dict[str, int]) -&gt; jm.SampleSet:\n    \"\"\"Decode the counts to the SampleSet.\n\n    Args:\n        counts (dict[str, int]): The counts to be decoded.\n\n    Returns:\n        jm.SampleSet: The decoded sample set.\n    \"\"\"\n    samples = []\n    num_occurrences = []\n    for binary_str, count_num in counts.items():\n        binary_values = {idx: int(b) for idx, b in enumerate(binary_str)}\n        samples.append(binary_values)\n        num_occurrences.append(count_num)\n\n    binary_encoder = self.pubo_builder.binary_encoder\n    decoded: jm.SampleSet = (\n        jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n            samples, binary_encoder, self.compiled_instance\n        )\n    )\n    decoded = jm.SampleSet(\n        record=jm.Record(\n            num_occurrences=num_occurrences,\n            solution=decoded.record.solution,\n        ),\n        evaluation=decoded.evaluation,\n        measuring_time=decoded.measuring_time,\n        metadata=decoded.metadata,\n    )\n    return decoded\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#qamomile.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.decode_from_quasi_dist","title":"<code>decode_from_quasi_dist(quasi_dist: qk.result.QuasiDistribution) -&gt; jm.SampleSet</code>","text":"<p>Decode the result from the probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>quasi_dist</code> <code>QuasiDistribution</code> <p>The probabilities to be decoded.</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.SampleSet: The decoded sample set.</p> Source code in <code>qamomile/qiskit/qaoa/to_qaoa.py</code> <pre><code>def decode_from_quasi_dist(\n    self, quasi_dist: qk.result.QuasiDistribution\n) -&gt; jm.SampleSet:\n    \"\"\"Decode the result from the probabilities.\n\n    Args:\n        quasi_dist (qk.result.QuasiDistribution): The probabilities to be decoded.\n\n    Returns:\n        jm.SampleSet: The decoded sample set.\n    \"\"\"\n    binary_prob: dict[str, float] = quasi_dist.binary_probabilities()\n\n    shots: int\n    if quasi_dist.shots:\n        shots = quasi_dist.shots\n    else:\n        if self.num_vars &lt; 15:\n            shots = max(2**self.num_vars, 100)\n        else:\n            shots = 30000\n\n    binary_counts = {\n        key: int(prob * shots) for key, prob in binary_prob.items()\n    }\n\n    return self.decode_from_counts(binary_counts)\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#qamomile.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float]</code>","text":"<p>Get the Ising Hamiltonian</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float]</code> <p>tuple[qk_info.SparsePauliOp, float]: The Ising operator and the constant offset.</p> Source code in <code>qamomile/qiskit/qaoa/to_qaoa.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float]:\n    \"\"\"Get the Ising Hamiltonian\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float]: The Ising operator and the constant offset.\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising_operator, ising_const = to_ising_operator_from_qubo(\n        qubo, self.num_vars\n    )\n    return ising_operator, ising_const + constant\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#qamomile.qiskit.qaoa.to_qaoa.QAOAAnsatzBuilder.get_qaoa_ansatz","title":"<code>get_qaoa_ansatz(p: int, multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]</code>","text":"<p>Get the QAOA Ansatz.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>The number of layers in the QAOA circuit.</p> required <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[QAOAAnsatz, SparsePauliOp, float]</code> <p>tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]: The QAOA ansatz, the Ising operator, and the constant offset.</p> Source code in <code>qamomile/qiskit/qaoa/to_qaoa.py</code> <pre><code>def get_qaoa_ansatz(\n    self,\n    p: int,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]:\n    \"\"\"Get the QAOA Ansatz.\n\n    Args:\n        p (int): The number of layers in the QAOA circuit.\n        multipliers (typ.Optional[dict[str, float]], optional):Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[qk.circuit.library.QAOAAnsatz, qk_info.SparsePauliOp, float]: The QAOA ansatz, the Ising operator, and the constant offset.\n    \"\"\"\n    ising_operator, constant = self.get_hamiltonian(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    qaoa_ansatz = qk.circuit.library.QAOAAnsatz(ising_operator, reps=p)\n    return qaoa_ansatz, ising_operator, constant\n</code></pre>"},{"location":"reference/qiskit/qaoa/to_qaoa/#qamomile.qiskit.qaoa.to_qaoa.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method: jmt.core.pubo.RelaxationMethod = jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>qamomile/qiskit/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method: jmt.core.pubo.RelaxationMethod = jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/","title":"Qrao","text":""},{"location":"reference/qiskit/qrao/#qamomile.qiskit.qrao.color_group_to_qrac_encode","title":"<code>color_group_to_qrac_encode(color_group: dict[int, list[int]]) -&gt; dict[int, tuple[int, Pauli]]</code>","text":"<p>qrac encode</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>key is color (qubit's index). value is list of bit's index.</p> required <p>Returns:</p> Type Description <code>dict[int, tuple[int, Pauli]]</code> <p>dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n&gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n{0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n</code></pre> Source code in <code>qamomile/qiskit/qrao/qrao31.py</code> <pre><code>def color_group_to_qrac_encode(\n    color_group: dict[int, list[int]]\n) -&gt; dict[int, tuple[int, Pauli]]:\n    \"\"\"qrac encode\n\n    Args:\n        color_group (dict[int, list[int]]): key is color (qubit's index). value is list of bit's index.\n\n    Returns:\n        dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.\n\n    Examples:\n        &gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n        &gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n        {0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n\n    \"\"\"\n    qrac31 = {}\n    pauli_ope = [Pauli.Z, Pauli.X, Pauli.Y]\n    for color, group in color_group.items():\n        for ope_idx, bit_index in enumerate(group):\n            qrac31[bit_index] = (color, pauli_ope[ope_idx])\n    return qrac31\n</code></pre>"},{"location":"reference/qiskit/qrao/#qamomile.qiskit.qrao.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/#qamomile.qiskit.qrao.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/#qamomile.qiskit.qrao.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/#qamomile.qiskit.qrao.transpile_to_qrac_space_efficient_hamiltonian","title":"<code>transpile_to_qrac_space_efficient_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize=True) -&gt; QRACSpaceEfficientBuilder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.</p> <pre><code>This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\nIn this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRACSpaceEfficientBuilder</code> <code>QRACSpaceEfficientBuilder</code> <p>Space-efficient QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac_space_efficient_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize=True\n) -&gt; QRACSpaceEfficientBuilder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.\n\n        This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n        In this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRACSpaceEfficientBuilder: Space-efficient QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRACSpaceEfficientBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/qrao21/","title":"Qrao21","text":""},{"location":"reference/qiskit/qrao/qrao31/","title":"Qrao31","text":""},{"location":"reference/qiskit/qrao/qrao31/#qamomile.qiskit.qrao.qrao31.color_group_to_qrac_encode","title":"<code>color_group_to_qrac_encode(color_group: dict[int, list[int]]) -&gt; dict[int, tuple[int, Pauli]]</code>","text":"<p>qrac encode</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>key is color (qubit's index). value is list of bit's index.</p> required <p>Returns:</p> Type Description <code>dict[int, tuple[int, Pauli]]</code> <p>dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n&gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n{0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n</code></pre> Source code in <code>qamomile/qiskit/qrao/qrao31.py</code> <pre><code>def color_group_to_qrac_encode(\n    color_group: dict[int, list[int]]\n) -&gt; dict[int, tuple[int, Pauli]]:\n    \"\"\"qrac encode\n\n    Args:\n        color_group (dict[int, list[int]]): key is color (qubit's index). value is list of bit's index.\n\n    Returns:\n        dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.\n\n    Examples:\n        &gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n        &gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n        {0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n\n    \"\"\"\n    qrac31 = {}\n    pauli_ope = [Pauli.Z, Pauli.X, Pauli.Y]\n    for color, group in color_group.items():\n        for ope_idx, bit_index in enumerate(group):\n            qrac31[bit_index] = (color, pauli_ope[ope_idx])\n    return qrac31\n</code></pre>"},{"location":"reference/qiskit/qrao/qrao32/","title":"Qrao32","text":""},{"location":"reference/qiskit/qrao/qrao_space_efficient/","title":"Qrao space efficient","text":""},{"location":"reference/qiskit/qrao/to_qrac/","title":"To qrac","text":""},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.QRAC21Builder","title":"<code>QRAC21Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>class QRAC21Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 2\n\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac21_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.QRAC21Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float, QRACEncodingCache]</code> <p>tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 2\n\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac21_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.QRAC31Builder","title":"<code>QRAC31Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>class QRAC31Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 3\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac31_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.QRAC31Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float, QRACEncodingCache]</code> <p>tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 3\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac31_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.QRAC32Builder","title":"<code>QRAC32Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>class QRAC32Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 3\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac32_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.QRAC32Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float, QRACEncodingCache]</code> <p>tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 3\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac32_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.QRACSpaceEfficientBuilder","title":"<code>QRACSpaceEfficientBuilder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>class QRACSpaceEfficientBuilder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on space-efficient QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: Space-efficient QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        qrac_hamiltonian, offset, encoding = qrac_space_efficient_encode_ising(\n            ising\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group={}, encoding=encoding),\n        )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.QRACSpaceEfficientBuilder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on space-efficient QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[SparsePauliOp, float, QRACEncodingCache]</code> <p>tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: Space-efficient QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on space-efficient QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[qk_info.SparsePauliOp, float, QRACEncodingCache]: Space-efficient QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    qrac_hamiltonian, offset, encoding = qrac_space_efficient_encode_ising(\n        ising\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group={}, encoding=encoding),\n    )\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/qiskit/qrao/to_qrac/#qamomile.qiskit.qrao.to_qrac.transpile_to_qrac_space_efficient_hamiltonian","title":"<code>transpile_to_qrac_space_efficient_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize=True) -&gt; QRACSpaceEfficientBuilder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.</p> <pre><code>This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\nIn this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRACSpaceEfficientBuilder</code> <code>QRACSpaceEfficientBuilder</code> <p>Space-efficient QRAC Hamiltonian builder</p> Source code in <code>qamomile/qiskit/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac_space_efficient_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize=True\n) -&gt; QRACSpaceEfficientBuilder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on space-efficient QRAC builder.\n\n        This relaxation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n        In this paper, this method is called as Space Compression Ratio Preserving Quantum Relaxation.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRACSpaceEfficientBuilder: Space-efficient QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRACSpaceEfficientBuilder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/","title":"Quri parts","text":""},{"location":"reference/quri_parts/#qamomile.quri_parts.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/","title":"Qaoa","text":""},{"location":"reference/quri_parts/qaoa/#qamomile.quri_parts.qaoa.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/","title":"To qaoa","text":""},{"location":"reference/quri_parts/qaoa/to_qaoa/#qamomile.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder","title":"<code>QAOAAnsatzBuilder</code>","text":"Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>class QAOAAnsatzBuilder:\n    def __init__(\n        self,\n        pubo_builder: jmt.core.pubo.PuboBuilder,\n        num_vars: int,\n        compiled_instance: jmt.core.CompiledInstance,\n    ):\n        \"\"\"Initialize the QAOAAnsatzBuilder.\n\n        Args:\n            pubo_builder (jmt.core.pubo.PuboBuilder): The PUBO builder to be used.\n            num_vars (int): The number of variables.\n            compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        \"\"\"\n        self.pubo_builder = pubo_builder\n        self.num_vars = num_vars\n        self.compiled_instance = compiled_instance\n\n    @property\n    def var_map(self) -&gt; dict[str, tuple[int, ...]]:\n        return self.compiled_instance.var_map.var_map\n\n    def get_ising_dict(\n        self,\n        multipliers: dict = None,\n        detail_parameters: dict = None,\n    ) -&gt; IsingModel:\n        \"\"\"Get the Ising dictionary.\n\n        Args:\n            multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[dict[tuple[int, int], float], dict[int, float], float]: The Ising dictionary, the constant offset, and the constant offset.\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = qubo_to_ising(qubo)\n        ising.constant += constant\n        return ising\n\n    def get_hamiltonian(\n        self,\n        multipliers: dict = None,\n        detail_parameters: dict = None,\n    ) -&gt; tuple[Operator, float]:\n        \"\"\"Get the Ising Hamiltonian.\n\n        Args:\n            multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[Operator, float]: The Ising operator and the constant offset.\n        \"\"\"\n        ising = self.get_ising_dict(multipliers, detail_parameters)\n\n        return ising_to_hamiltonian(ising)\n\n    def get_qaoa_ansatz(\n        self,\n        p: int,\n        multipliers: dict = None,\n        detail_parameters: dict = None,\n    ) -&gt; tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]:\n        \"\"\"Get the QAOA ansatz.\n\n        Args:\n            p (int): The number of layers in the QAOA circuit.\n            multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n            detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n        Returns:\n            tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]: The QAOA ansatz, the Ising operator, and the constant offset.\n        \"\"\"\n        ising = self.get_ising_dict(multipliers, detail_parameters)\n        QAOAAnsatz = LinearMappedUnboundParametricQuantumCircuit(self.num_vars)\n        # Create the QAOA ansatz\n        for i in range(self.num_vars):\n            QAOAAnsatz.add_H_gate(i)\n\n        for p_level in range(p):\n            gamma = QAOAAnsatz.add_parameter(f\"gamma{p_level}\")\n            beta = QAOAAnsatz.add_parameter(f\"beta{p_level}\")\n\n            for idx, coeff in ising.linear.items():\n                if coeff != 0.0:\n                    QAOAAnsatz.add_ParametricRZ_gate(\n                        idx,\n                        angle={gamma: 2 * coeff}\n                    )\n            for (i, j), coeff in ising.quad.items():\n                if coeff != 0.0:\n                    QAOAAnsatz.add_ParametricPauliRotation_gate(\n                        [i, j],\n                        pauli_ids=(3, 3),\n                        angle={gamma: 2 * coeff},\n                    )\n            for i in range(self.num_vars):\n                QAOAAnsatz.add_ParametricRX_gate(\n                    i, {beta: 2}\n                )\n\n        ising_operator, constant = ising_to_hamiltonian(ising)\n\n        return QAOAAnsatz, ising_operator, constant\n\n    def decode_from_counts(self, counts: dict[str, int]) -&gt; jm.SampleSet:\n        \"\"\"Decode the result from the counts.\n\n        Args:\n            counts (dict[str, int]): The counts to be decoded.\n\n        Returns:\n            jm.SampleSet: The decoded sample set.\n        \"\"\"\n        samples = []\n        num_occurrences = []\n        for binary_str, count_num in counts.items():\n            binary_values = {idx: int(b) for idx, b in enumerate(binary_str)}\n            samples.append(binary_values)\n            num_occurrences.append(count_num)\n\n        binary_encoder = self.pubo_builder.binary_encoder\n        decoded: jm.SampleSet = (\n            jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n                samples, binary_encoder, self.compiled_instance\n            )\n        )\n        decoded = jm.SampleSet(\n            record=jm.Record(\n                num_occurrences=num_occurrences,\n                solution=decoded.record.solution,\n            ),\n            evaluation=decoded.evaluation,\n            measuring_time=decoded.measuring_time,\n            metadata=decoded.metadata,\n        )\n        return decoded\n\n    def decode_from_probs(self, probs: np.array) -&gt; jm.SampleSet:\n        \"\"\"Decode the result from the probabilities.\n\n        Args:\n            probs (np.array): The probabilities to be decoded.\n\n        Returns:\n            jm.SampleSet: The decoded sample set.\n        \"\"\"\n        shots = 10000\n        z_basis = [\n            format(i, \"b\").zfill(self.num_vars) for i in range(len(probs))\n        ]\n        binary_counts = {\n            i: int(value * shots) for i, value in zip(z_basis, probs)\n        }\n\n        return self.decode_from_counts(binary_counts)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#qamomile.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.__init__","title":"<code>__init__(pubo_builder: jmt.core.pubo.PuboBuilder, num_vars: int, compiled_instance: jmt.core.CompiledInstance)</code>","text":"<p>Initialize the QAOAAnsatzBuilder.</p> <p>Parameters:</p> Name Type Description Default <code>pubo_builder</code> <code>PuboBuilder</code> <p>The PUBO builder to be used.</p> required <code>num_vars</code> <code>int</code> <p>The number of variables.</p> required <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def __init__(\n    self,\n    pubo_builder: jmt.core.pubo.PuboBuilder,\n    num_vars: int,\n    compiled_instance: jmt.core.CompiledInstance,\n):\n    \"\"\"Initialize the QAOAAnsatzBuilder.\n\n    Args:\n        pubo_builder (jmt.core.pubo.PuboBuilder): The PUBO builder to be used.\n        num_vars (int): The number of variables.\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n    \"\"\"\n    self.pubo_builder = pubo_builder\n    self.num_vars = num_vars\n    self.compiled_instance = compiled_instance\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#qamomile.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.decode_from_counts","title":"<code>decode_from_counts(counts: dict[str, int]) -&gt; jm.SampleSet</code>","text":"<p>Decode the result from the counts.</p> <p>Parameters:</p> Name Type Description Default <code>counts</code> <code>dict[str, int]</code> <p>The counts to be decoded.</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.SampleSet: The decoded sample set.</p> Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def decode_from_counts(self, counts: dict[str, int]) -&gt; jm.SampleSet:\n    \"\"\"Decode the result from the counts.\n\n    Args:\n        counts (dict[str, int]): The counts to be decoded.\n\n    Returns:\n        jm.SampleSet: The decoded sample set.\n    \"\"\"\n    samples = []\n    num_occurrences = []\n    for binary_str, count_num in counts.items():\n        binary_values = {idx: int(b) for idx, b in enumerate(binary_str)}\n        samples.append(binary_values)\n        num_occurrences.append(count_num)\n\n    binary_encoder = self.pubo_builder.binary_encoder\n    decoded: jm.SampleSet = (\n        jmt.core.pubo.binary_decode.decode_from_dict_binary_result(\n            samples, binary_encoder, self.compiled_instance\n        )\n    )\n    decoded = jm.SampleSet(\n        record=jm.Record(\n            num_occurrences=num_occurrences,\n            solution=decoded.record.solution,\n        ),\n        evaluation=decoded.evaluation,\n        measuring_time=decoded.measuring_time,\n        metadata=decoded.metadata,\n    )\n    return decoded\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#qamomile.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.decode_from_probs","title":"<code>decode_from_probs(probs: np.array) -&gt; jm.SampleSet</code>","text":"<p>Decode the result from the probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>probs</code> <code>array</code> <p>The probabilities to be decoded.</p> required <p>Returns:</p> Type Description <code>SampleSet</code> <p>jm.SampleSet: The decoded sample set.</p> Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def decode_from_probs(self, probs: np.array) -&gt; jm.SampleSet:\n    \"\"\"Decode the result from the probabilities.\n\n    Args:\n        probs (np.array): The probabilities to be decoded.\n\n    Returns:\n        jm.SampleSet: The decoded sample set.\n    \"\"\"\n    shots = 10000\n    z_basis = [\n        format(i, \"b\").zfill(self.num_vars) for i in range(len(probs))\n    ]\n    binary_counts = {\n        i: int(value * shots) for i, value in zip(z_basis, probs)\n    }\n\n    return self.decode_from_counts(binary_counts)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#qamomile.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: dict = None, detail_parameters: dict = None) -&gt; tuple[Operator, float]</code>","text":"<p>Get the Ising Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>dict</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>dict</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Operator, float]</code> <p>tuple[Operator, float]: The Ising operator and the constant offset.</p> Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: dict = None,\n    detail_parameters: dict = None,\n) -&gt; tuple[Operator, float]:\n    \"\"\"Get the Ising Hamiltonian.\n\n    Args:\n        multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[Operator, float]: The Ising operator and the constant offset.\n    \"\"\"\n    ising = self.get_ising_dict(multipliers, detail_parameters)\n\n    return ising_to_hamiltonian(ising)\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#qamomile.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.get_ising_dict","title":"<code>get_ising_dict(multipliers: dict = None, detail_parameters: dict = None) -&gt; IsingModel</code>","text":"<p>Get the Ising dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>dict</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>dict</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>IsingModel</code> <p>tuple[dict[tuple[int, int], float], dict[int, float], float]: The Ising dictionary, the constant offset, and the constant offset.</p> Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def get_ising_dict(\n    self,\n    multipliers: dict = None,\n    detail_parameters: dict = None,\n) -&gt; IsingModel:\n    \"\"\"Get the Ising dictionary.\n\n    Args:\n        multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[dict[tuple[int, int], float], dict[int, float], float]: The Ising dictionary, the constant offset, and the constant offset.\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = qubo_to_ising(qubo)\n    ising.constant += constant\n    return ising\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#qamomile.quri_parts.qaoa.to_qaoa.QAOAAnsatzBuilder.get_qaoa_ansatz","title":"<code>get_qaoa_ansatz(p: int, multipliers: dict = None, detail_parameters: dict = None) -&gt; tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]</code>","text":"<p>Get the QAOA ansatz.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>The number of layers in the QAOA circuit.</p> required <code>multipliers</code> <code>dict</code> <p>Multipliers for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>dict</code> <p>Detailed parameters for the Ising Hamiltonian. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]</code> <p>tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]: The QAOA ansatz, the Ising operator, and the constant offset.</p> Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def get_qaoa_ansatz(\n    self,\n    p: int,\n    multipliers: dict = None,\n    detail_parameters: dict = None,\n) -&gt; tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]:\n    \"\"\"Get the QAOA ansatz.\n\n    Args:\n        p (int): The number of layers in the QAOA circuit.\n        multipliers (dict, optional): Multipliers for the Ising Hamiltonian. Defaults to None.\n        detail_parameters (dict, optional): Detailed parameters for the Ising Hamiltonian. Defaults to None.\n\n    Returns:\n        tuple[LinearMappedUnboundParametricQuantumCircuit, Operator, float]: The QAOA ansatz, the Ising operator, and the constant offset.\n    \"\"\"\n    ising = self.get_ising_dict(multipliers, detail_parameters)\n    QAOAAnsatz = LinearMappedUnboundParametricQuantumCircuit(self.num_vars)\n    # Create the QAOA ansatz\n    for i in range(self.num_vars):\n        QAOAAnsatz.add_H_gate(i)\n\n    for p_level in range(p):\n        gamma = QAOAAnsatz.add_parameter(f\"gamma{p_level}\")\n        beta = QAOAAnsatz.add_parameter(f\"beta{p_level}\")\n\n        for idx, coeff in ising.linear.items():\n            if coeff != 0.0:\n                QAOAAnsatz.add_ParametricRZ_gate(\n                    idx,\n                    angle={gamma: 2 * coeff}\n                )\n        for (i, j), coeff in ising.quad.items():\n            if coeff != 0.0:\n                QAOAAnsatz.add_ParametricPauliRotation_gate(\n                    [i, j],\n                    pauli_ids=(3, 3),\n                    angle={gamma: 2 * coeff},\n                )\n        for i in range(self.num_vars):\n            QAOAAnsatz.add_ParametricRX_gate(\n                i, {beta: 2}\n            )\n\n    ising_operator, constant = ising_to_hamiltonian(ising)\n\n    return QAOAAnsatz, ising_operator, constant\n</code></pre>"},{"location":"reference/quri_parts/qaoa/to_qaoa/#qamomile.quri_parts.qaoa.to_qaoa.transpile_to_qaoa_ansatz","title":"<code>transpile_to_qaoa_ansatz(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True, relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian) -&gt; QAOAAnsatzBuilder</code>","text":"<p>Transpile to a QAOA ansatz builder.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>The compiled instance to be used.</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize the objective function. Defaults to True.</p> <code>True</code> <code>relax_method</code> <code>RelaxationMethod</code> <p>The relaxation method to be used. Defaults to AugmentedLagrangian.</p> <code>AugmentedLagrangian</code> <p>Returns:</p> Name Type Description <code>QAOAAnsatzBuilder</code> <code>QAOAAnsatzBuilder</code> <p>The QAOA ansatz builder.</p> Source code in <code>qamomile/quri_parts/qaoa/to_qaoa.py</code> <pre><code>def transpile_to_qaoa_ansatz(\n    compiled_instance: jmt.core.CompiledInstance,\n    normalize: bool = True,\n    relax_method=jmt.core.pubo.RelaxationMethod.AugmentedLagrangian,\n) -&gt; QAOAAnsatzBuilder:\n    \"\"\"Transpile to a QAOA ansatz builder.\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): The compiled instance to be used.\n        normalize (bool, optional): Whether to normalize the objective function. Defaults to True.\n        relax_method (jmt.core.pubo.RelaxationMethod, optional): The relaxation method to be used. Defaults to AugmentedLagrangian.\n\n    Returns:\n        QAOAAnsatzBuilder: The QAOA ansatz builder.\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize, relax_method=relax_method\n    )\n    var_num = compiled_instance.var_map.var_num\n    return QAOAAnsatzBuilder(pubo_builder, var_num, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/","title":"Qrao","text":""},{"location":"reference/quri_parts/qrao/#qamomile.quri_parts.qrao.color_group_to_qrac_encode","title":"<code>color_group_to_qrac_encode(color_group: dict[int, list[int]]) -&gt; dict[int, tuple[int, Pauli]]</code>","text":"<p>qrac encode</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>key is color (qubit's index). value is list of bit's index.</p> required <p>Returns:</p> Type Description <code>dict[int, tuple[int, Pauli]]</code> <p>dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n&gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n{0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n</code></pre> Source code in <code>qamomile/quri_parts/qrao/qrao31.py</code> <pre><code>def color_group_to_qrac_encode(\n    color_group: dict[int, list[int]]\n) -&gt; dict[int, tuple[int, Pauli]]:\n    \"\"\"qrac encode\n\n    Args:\n        color_group (dict[int, list[int]]): key is color (qubit's index). value is list of bit's index.\n\n    Returns:\n        dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.\n\n    Examples:\n        &gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n        &gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n        {0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n\n    \"\"\"\n    qrac31 = {}\n    pauli_ope = [Pauli.Z, Pauli.X, Pauli.Y]\n    for color, group in color_group.items():\n        for ope_idx, bit_index in enumerate(group):\n            qrac31[bit_index] = (color, pauli_ope[ope_idx])\n    return qrac31\n</code></pre>"},{"location":"reference/quri_parts/qrao/#qamomile.quri_parts.qrao.qrac21_encode_ising","title":"<code>qrac21_encode_ising(ising: IsingModel, color_group: dict[int, list[int]]) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]</code>","text":"<p>Encode an Ising model and a color group into QRAC21.</p> <p>This function encodes an Ising model into the operators, and returns as the QURI Parts Operator, the offset(constant) of the Ising model, and the encoded operation as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>ising</code> <code>IsingModel</code> <p>The Ising model to be encoded.</p> required <code>color_group</code> <code>dict[int, list[int]]</code> <p>The color group mapping for encoding.</p> required <p>Returns:</p> Type Description <code>Operator</code> <p>tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,</p> <code>float</code> <p>the offset of the Ising model, and the encoded operation as a dictionary.</p> Source code in <code>qamomile/quri_parts/qrao/qrao21.py</code> <pre><code>def qrac21_encode_ising(\n    ising: IsingModel, color_group: dict[int, list[int]]\n) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]:\n    \"\"\"Encode an Ising model and a color group into QRAC21.\n\n    This function encodes an Ising model into the operators, and returns as the QURI Parts Operator,\n    the offset(constant) of the Ising model, and the encoded operation as a dictionary.\n\n    Args:\n        ising (IsingModel): The Ising model to be encoded.\n        color_group (dict[int, list[int]]): The color group mapping for encoding.\n\n    Returns:\n        tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,\n        the offset of the Ising model, and the encoded operation as a dictionary.\n    \"\"\"\n    encoded_ope = color_group_to_qrac_encode(color_group)\n\n    pauli_terms: list[Operator] = []\n\n    offset = ising.constant\n    n_qubit = len(color_group)\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        color, pauli_kind = encoded_ope[idx]\n        pauli_str = create_pauli_term([pauli_kind], [color], n_qubit)\n        pauli_terms.append(\n            Operator({pauli_label(pauli_str): np.sqrt(2) * coeff})\n        )\n\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n            continue\n\n        color_i, pauli_kind_i = encoded_ope[i]\n\n        color_j, pauli_kind_j = encoded_ope[j]\n\n        pauli_str = create_pauli_term(\n            [pauli_kind_i, pauli_kind_j], [color_i, color_j], n_qubit\n        )\n\n        pauli_terms.append(Operator({pauli_label(pauli_str): 2 * coeff}))\n\n    if pauli_terms:\n        qubit_op = Operator()\n        for term in pauli_terms:\n            qubit_op += term\n    else:\n        n_qubit = max(1, n_qubit)\n        qubit_op = Operator({PAULI_IDENTITY * n_qubit: 0})\n\n    return qubit_op, offset, encoded_ope\n</code></pre>"},{"location":"reference/quri_parts/qrao/#qamomile.quri_parts.qrao.qrac31_encode_ising","title":"<code>qrac31_encode_ising(ising: IsingModel, color_group: dict[int, list[int]]) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]</code>","text":"<p>Encode an Ising model and a color group into QRAC31.</p> <p>Parameters:</p> Name Type Description Default <code>ising</code> <code>IsingModel</code> <p>The Ising model to be encoded.</p> required <code>color_group</code> <code>dict[int, list[int]]</code> <p>The color group mapping for encoding.</p> required <p>Returns:</p> Type Description <code>Operator</code> <p>tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,</p> <code>float</code> <p>the offset of the Ising model, and the encoded operation as a dictionary.</p> Source code in <code>qamomile/quri_parts/qrao/qrao31.py</code> <pre><code>def qrac31_encode_ising(\n    ising: IsingModel, color_group: dict[int, list[int]]\n) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]:\n    \"\"\"Encode an Ising model and a color group into QRAC31.\n\n    Args:\n        ising (IsingModel): The Ising model to be encoded.\n        color_group (dict[int, list[int]]): The color group mapping for encoding.\n\n    Returns:\n        tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,\n        the offset of the Ising model, and the encoded operation as a dictionary.\n    \"\"\"\n    encoded_ope = color_group_to_qrac_encode(color_group)\n\n    pauli_terms: list[Operator] = []\n\n    offset = ising.constant\n    n_qubit = len(color_group)\n\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        color, pauli_kind = encoded_ope[idx]\n        pauli_operator = create_pauli_term([pauli_kind], [color], n_qubit)\n\n        pauli_terms.append(\n            Operator({pauli_label(pauli_operator): np.sqrt(3) * coeff})\n        )\n\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n            continue\n\n        color_i, pauli_kind_i = encoded_ope[i]\n\n        color_j, pauli_kind_j = encoded_ope[j]\n\n        pauli_ope = create_pauli_term(\n            [pauli_kind_i, pauli_kind_j], [color_i, color_j], n_qubit\n        )\n        pauli_terms.append(Operator({pauli_label(pauli_ope): 3 * coeff}))\n\n    if pauli_terms:\n        qubit_op = Operator()\n        for term in pauli_terms:\n            qubit_op += term\n    else:\n        n_qubit = max(1, n_qubit)\n        qubit_op = Operator({PAULI_IDENTITY * n_qubit: 0})\n\n    return qubit_op, offset, encoded_ope\n</code></pre>"},{"location":"reference/quri_parts/qrao/#qamomile.quri_parts.qrao.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/#qamomile.quri_parts.qrao.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/#qamomile.quri_parts.qrao.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao21/","title":"Qrao21","text":""},{"location":"reference/quri_parts/qrao/qrao21/#qamomile.quri_parts.qrao.qrao21.qrac21_encode_ising","title":"<code>qrac21_encode_ising(ising: IsingModel, color_group: dict[int, list[int]]) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]</code>","text":"<p>Encode an Ising model and a color group into QRAC21.</p> <p>This function encodes an Ising model into the operators, and returns as the QURI Parts Operator, the offset(constant) of the Ising model, and the encoded operation as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>ising</code> <code>IsingModel</code> <p>The Ising model to be encoded.</p> required <code>color_group</code> <code>dict[int, list[int]]</code> <p>The color group mapping for encoding.</p> required <p>Returns:</p> Type Description <code>Operator</code> <p>tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,</p> <code>float</code> <p>the offset of the Ising model, and the encoded operation as a dictionary.</p> Source code in <code>qamomile/quri_parts/qrao/qrao21.py</code> <pre><code>def qrac21_encode_ising(\n    ising: IsingModel, color_group: dict[int, list[int]]\n) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]:\n    \"\"\"Encode an Ising model and a color group into QRAC21.\n\n    This function encodes an Ising model into the operators, and returns as the QURI Parts Operator,\n    the offset(constant) of the Ising model, and the encoded operation as a dictionary.\n\n    Args:\n        ising (IsingModel): The Ising model to be encoded.\n        color_group (dict[int, list[int]]): The color group mapping for encoding.\n\n    Returns:\n        tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,\n        the offset of the Ising model, and the encoded operation as a dictionary.\n    \"\"\"\n    encoded_ope = color_group_to_qrac_encode(color_group)\n\n    pauli_terms: list[Operator] = []\n\n    offset = ising.constant\n    n_qubit = len(color_group)\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        color, pauli_kind = encoded_ope[idx]\n        pauli_str = create_pauli_term([pauli_kind], [color], n_qubit)\n        pauli_terms.append(\n            Operator({pauli_label(pauli_str): np.sqrt(2) * coeff})\n        )\n\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n            continue\n\n        color_i, pauli_kind_i = encoded_ope[i]\n\n        color_j, pauli_kind_j = encoded_ope[j]\n\n        pauli_str = create_pauli_term(\n            [pauli_kind_i, pauli_kind_j], [color_i, color_j], n_qubit\n        )\n\n        pauli_terms.append(Operator({pauli_label(pauli_str): 2 * coeff}))\n\n    if pauli_terms:\n        qubit_op = Operator()\n        for term in pauli_terms:\n            qubit_op += term\n    else:\n        n_qubit = max(1, n_qubit)\n        qubit_op = Operator({PAULI_IDENTITY * n_qubit: 0})\n\n    return qubit_op, offset, encoded_ope\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao31/","title":"Qrao31","text":""},{"location":"reference/quri_parts/qrao/qrao31/#qamomile.quri_parts.qrao.qrao31.color_group_to_qrac_encode","title":"<code>color_group_to_qrac_encode(color_group: dict[int, list[int]]) -&gt; dict[int, tuple[int, Pauli]]</code>","text":"<p>qrac encode</p> <p>Parameters:</p> Name Type Description Default <code>color_group</code> <code>dict[int, list[int]]</code> <p>key is color (qubit's index). value is list of bit's index.</p> required <p>Returns:</p> Type Description <code>dict[int, tuple[int, Pauli]]</code> <p>dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n&gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n{0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n</code></pre> Source code in <code>qamomile/quri_parts/qrao/qrao31.py</code> <pre><code>def color_group_to_qrac_encode(\n    color_group: dict[int, list[int]]\n) -&gt; dict[int, tuple[int, Pauli]]:\n    \"\"\"qrac encode\n\n    Args:\n        color_group (dict[int, list[int]]): key is color (qubit's index). value is list of bit's index.\n\n    Returns:\n        dict[int, tuple[int, Pauli]]: key is bit's index. value is tuple of qubit's index and Pauli operator kind.\n\n    Examples:\n        &gt;&gt;&gt; color_group = {0: [0, 1, 2], 1: [3, 4], 2: [6,]}\n        &gt;&gt;&gt; color_group_for_qrac_encode(color_group)\n        {0: (0, &lt;Pauli.Z: 3&gt;), 1: (0, &lt;Pauli.X: 1&gt;), 2: (0, &lt;Pauli.Y: 2&gt;), 3: (1, &lt;Pauli.Z: 3&gt;), 4: (1, &lt;Pauli.X: 1&gt;), 6: (2, &lt;Pauli.Z: 3&gt;)}\n\n    \"\"\"\n    qrac31 = {}\n    pauli_ope = [Pauli.Z, Pauli.X, Pauli.Y]\n    for color, group in color_group.items():\n        for ope_idx, bit_index in enumerate(group):\n            qrac31[bit_index] = (color, pauli_ope[ope_idx])\n    return qrac31\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao31/#qamomile.quri_parts.qrao.qrao31.create_pauli_term","title":"<code>create_pauli_term(operators: list[Pauli], indices: list[int], n_qubit: int) -&gt; str</code>","text":"<p>Create a Pauli term string given a list of operators and indices.</p> <p>Parameters:</p> Name Type Description Default <code>operators</code> <code>list[Pauli]</code> <p>A list of Pauli operators.</p> required <code>indices</code> <code>list[int]</code> <p>A list of indices corresponding to each operator.</p> required <code>n_qubit</code> <code>int</code> <p>The total number of qubits.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The created Pauli term string.</p> Source code in <code>qamomile/quri_parts/qrao/qrao31.py</code> <pre><code>def create_pauli_term(\n    operators: list[Pauli], indices: list[int], n_qubit: int\n) -&gt; str:\n    \"\"\"Create a Pauli term string given a list of operators and indices.\n\n    Args:\n        operators (list[Pauli]): A list of Pauli operators.\n        indices (list[int]): A list of indices corresponding to each operator.\n        n_qubit (int): The total number of qubits.\n\n    Returns:\n        str: The created Pauli term string.\n    \"\"\"\n    pauli_str = \"\"\n    for ope, idx in zip(operators, indices):\n        if ope == Pauli.X:\n            pauli_str += f\"X{idx} \"\n        elif ope == Pauli.Y:\n            pauli_str += f\"Y{idx} \"\n        elif ope == Pauli.Z:\n            pauli_str += f\"Z{idx} \"\n    return pauli_str.rstrip()\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao31/#qamomile.quri_parts.qrao.qrao31.qrac31_encode_ising","title":"<code>qrac31_encode_ising(ising: IsingModel, color_group: dict[int, list[int]]) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]</code>","text":"<p>Encode an Ising model and a color group into QRAC31.</p> <p>Parameters:</p> Name Type Description Default <code>ising</code> <code>IsingModel</code> <p>The Ising model to be encoded.</p> required <code>color_group</code> <code>dict[int, list[int]]</code> <p>The color group mapping for encoding.</p> required <p>Returns:</p> Type Description <code>Operator</code> <p>tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,</p> <code>float</code> <p>the offset of the Ising model, and the encoded operation as a dictionary.</p> Source code in <code>qamomile/quri_parts/qrao/qrao31.py</code> <pre><code>def qrac31_encode_ising(\n    ising: IsingModel, color_group: dict[int, list[int]]\n) -&gt; tuple[Operator, float, dict[int, tuple[int, Pauli]]]:\n    \"\"\"Encode an Ising model and a color group into QRAC31.\n\n    Args:\n        ising (IsingModel): The Ising model to be encoded.\n        color_group (dict[int, list[int]]): The color group mapping for encoding.\n\n    Returns:\n        tuple[Operator, float, dict[int, tuple[int, Pauli]]]: The encoded quantum operator,\n        the offset of the Ising model, and the encoded operation as a dictionary.\n    \"\"\"\n    encoded_ope = color_group_to_qrac_encode(color_group)\n\n    pauli_terms: list[Operator] = []\n\n    offset = ising.constant\n    n_qubit = len(color_group)\n\n    for idx, coeff in ising.linear.items():\n        if coeff == 0.0:\n            continue\n\n        color, pauli_kind = encoded_ope[idx]\n        pauli_operator = create_pauli_term([pauli_kind], [color], n_qubit)\n\n        pauli_terms.append(\n            Operator({pauli_label(pauli_operator): np.sqrt(3) * coeff})\n        )\n\n    for (i, j), coeff in ising.quad.items():\n        if coeff == 0.0:\n            continue\n\n        if i == j:\n            offset += coeff\n            continue\n\n        color_i, pauli_kind_i = encoded_ope[i]\n\n        color_j, pauli_kind_j = encoded_ope[j]\n\n        pauli_ope = create_pauli_term(\n            [pauli_kind_i, pauli_kind_j], [color_i, color_j], n_qubit\n        )\n        pauli_terms.append(Operator({pauli_label(pauli_ope): 3 * coeff}))\n\n    if pauli_terms:\n        qubit_op = Operator()\n        for term in pauli_terms:\n            qubit_op += term\n    else:\n        n_qubit = max(1, n_qubit)\n        qubit_op = Operator({PAULI_IDENTITY * n_qubit: 0})\n\n    return qubit_op, offset, encoded_ope\n</code></pre>"},{"location":"reference/quri_parts/qrao/qrao32/","title":"Qrao32","text":""},{"location":"reference/quri_parts/qrao/to_qrac/","title":"To qrac","text":""},{"location":"reference/quri_parts/qrao/to_qrac/#qamomile.quri_parts.qrao.to_qrac.QRAC21Builder","title":"<code>QRAC21Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>class QRAC21Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[Operator, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[Operator, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 2\n\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac21_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#qamomile.quri_parts.qrao.to_qrac.QRAC21Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[Operator, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Operator, float, QRACEncodingCache]</code> <p>tuple[Operator, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[Operator, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[Operator, float, QRACEncodingCache]: (2,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 2\n\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac21_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#qamomile.quri_parts.qrao.to_qrac.QRAC31Builder","title":"<code>QRAC31Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>class QRAC31Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[Operator, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[Operator, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 3\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac31_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#qamomile.quri_parts.qrao.to_qrac.QRAC31Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[Operator, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Operator, float, QRACEncodingCache]</code> <p>tuple[Operator, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[Operator, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[Operator, float, QRACEncodingCache]: (3,1,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 3\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac31_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#qamomile.quri_parts.qrao.to_qrac.QRAC32Builder","title":"<code>QRAC32Builder</code>","text":"<p>             Bases: <code>QRACBuilder</code></p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>class QRAC32Builder(QRACBuilder):\n    def get_hamiltonian(\n        self,\n        multipliers: typ.Optional[dict[str, float]] = None,\n        detail_parameters: typ.Optional[\n            dict[str, dict[tuple[int, ...], tuple[float, float]]]\n        ] = None,\n    ) -&gt; tuple[Operator, float, QRACEncodingCache]:\n        \"\"\"Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.\n\n        Args:\n            multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n            detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n        Returns:\n            tuple[Operator, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n        \"\"\"\n        qubo, constant = self.pubo_builder.get_qubo_dict(\n            multipliers=multipliers, detail_parameters=detail_parameters\n        )\n        ising = jmt_qc.qubo_to_ising(qubo)\n        max_color_group_size = 3\n        _, color_group = jmt_qc.greedy_graph_coloring(\n            ising.quad.keys(), max_color_group_size=max_color_group_size\n        )\n        color_group = jmt_qc.qrac.check_linear_term(\n            color_group, ising.linear.keys(), max_color_group_size\n        )\n        qrac_hamiltonian, offset, encoding = qrac32_encode_ising(\n            ising, color_group\n        )\n        return (\n            qrac_hamiltonian,\n            offset + constant,\n            QRACEncodingCache(color_group, encoding),\n        )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#qamomile.quri_parts.qrao.to_qrac.QRAC32Builder.get_hamiltonian","title":"<code>get_hamiltonian(multipliers: typ.Optional[dict[str, float]] = None, detail_parameters: typ.Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]] = None) -&gt; tuple[Operator, float, QRACEncodingCache]</code>","text":"<p>Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.</p> <p>Parameters:</p> Name Type Description Default <code>multipliers</code> <code>Optional[dict[str, float]]</code> <p>a multiplier for each penalty. Defaults to None.</p> <code>None</code> <code>detail_parameters</code> <code>Optional[dict[str, dict[tuple[int, ...], tuple[float, float]]]]</code> <p>detail parameters for each penalty. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Operator, float, QRACEncodingCache]</code> <p>tuple[Operator, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding</p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>def get_hamiltonian(\n    self,\n    multipliers: typ.Optional[dict[str, float]] = None,\n    detail_parameters: typ.Optional[\n        dict[str, dict[tuple[int, ...], tuple[float, float]]]\n    ] = None,\n) -&gt; tuple[Operator, float, QRACEncodingCache]:\n    \"\"\"Get Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC.\n\n    Args:\n        multipliers (typ.Optional[dict[str, float]], optional): a multiplier for each penalty. Defaults to None.\n        detail_parameters (typ.Optional[ dict[str, dict[tuple[int, ...], tuple[float, float]]] ], optional): detail parameters for each penalty. Defaults to None.\n\n    Returns:\n        tuple[Operator, float, QRACEncodingCache]: (3,2,p)-QRAC Hamiltonian, constant term, and encoding cache for decoding\n    \"\"\"\n    qubo, constant = self.pubo_builder.get_qubo_dict(\n        multipliers=multipliers, detail_parameters=detail_parameters\n    )\n    ising = jmt_qc.qubo_to_ising(qubo)\n    max_color_group_size = 3\n    _, color_group = jmt_qc.greedy_graph_coloring(\n        ising.quad.keys(), max_color_group_size=max_color_group_size\n    )\n    color_group = jmt_qc.qrac.check_linear_term(\n        color_group, ising.linear.keys(), max_color_group_size\n    )\n    qrac_hamiltonian, offset, encoding = qrac32_encode_ising(\n        ising, color_group\n    )\n    return (\n        qrac_hamiltonian,\n        offset + constant,\n        QRACEncodingCache(color_group, encoding),\n    )\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#qamomile.quri_parts.qrao.to_qrac.transpile_to_qrac21_hamiltonian","title":"<code>transpile_to_qrac21_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC21Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC21Builder</code> <code>QRAC21Builder</code> <p>(2,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac21_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC21Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (2,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC21Builder: (2,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC21Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#qamomile.quri_parts.qrao.to_qrac.transpile_to_qrac31_hamiltonian","title":"<code>transpile_to_qrac31_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC31Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.</p> <pre><code>The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC31Builder</code> <code>QRAC31Builder</code> <p>(3,1,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac31_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC31Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,1,p)-QRAC builder.\n\n        The generation method is based on the [B. Fuller et al., arXiv (2021)](https://arxiv.org/abs/2111.03167).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC31Builder: (3,1,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC31Builder(pubo_builder, compiled_instance)\n</code></pre>"},{"location":"reference/quri_parts/qrao/to_qrac/#qamomile.quri_parts.qrao.to_qrac.transpile_to_qrac32_hamiltonian","title":"<code>transpile_to_qrac32_hamiltonian(compiled_instance: jmt.core.CompiledInstance, normalize: bool = True) -&gt; QRAC32Builder</code>","text":"<p>Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.</p> <pre><code>The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>compiled_instance</code> <code>CompiledInstance</code> <p>Compiled model</p> required <code>normalize</code> <code>bool</code> <p>Normalize objective function. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>QRAC32Builder</code> <code>QRAC32Builder</code> <p>(3,2,p)-QRAC Hamiltonian builder</p> Source code in <code>qamomile/quri_parts/qrao/to_qrac.py</code> <pre><code>def transpile_to_qrac32_hamiltonian(\n    compiled_instance: jmt.core.CompiledInstance, normalize: bool = True\n) -&gt; QRAC32Builder:\n    \"\"\"Generate Quantum Relaxation Hamiltonian based on (3,2,p)-QRAC builder.\n\n        The generation method is based on the [K. Teramoto et al., arXiv (2023)](https://arxiv.org/abs/2302.09481).\n\n    Args:\n        compiled_instance (jmt.core.CompiledInstance): Compiled model\n        normalize (bool, optional): Normalize objective function. Defaults to True.\n\n    Returns:\n        QRAC32Builder: (3,2,p)-QRAC Hamiltonian builder\n    \"\"\"\n    pubo_builder = jmt.core.pubo.transpile_to_pubo(\n        compiled_instance, normalize=normalize\n    )\n    return QRAC32Builder(pubo_builder, compiled_instance)\n</code></pre>"}]}